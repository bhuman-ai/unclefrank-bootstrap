<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncle Frank's Bootstrap Core</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/diff-match-patch@1.0.5/index.js"></script>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // GitHub API Service
        const GitHubService = {
            baseUrl: 'https://api.github.com',
            owner: 'bhuman-ai',
            repo: 'unclefrank-bootstrap',

            async getBranches() {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/branches`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch branches:', error);
                    return [];
                }
            },

            async getBranchDetails(branchName) {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/branches/${branchName}`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch branch details:', error);
                    return null;
                }
            },

            async getCommitDiff(baseBranch = 'master', headBranch) {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                    return null;
                }
            },

            async createPullRequest(title, body, headBranch, baseBranch = 'master') {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/pulls`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            // Note: In production, you'd need proper authentication
                        },
                        body: JSON.stringify({
                            title,
                            body,
                            head: headBranch,
                            base: baseBranch
                        })
                    });
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to create PR:', error);
                    return null;
                }
            },

            getCompareUrl(baseBranch = 'master', headBranch) {
                return `https://github.com/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`;
            },

            getBranchUrl(branchName) {
                return `https://github.com/${this.owner}/${this.repo}/tree/${branchName}`;
            }
        };

        // Review Actions Component
        const ReviewActions = ({ task, onViewChanges, onRunTests, onApprove, onRequestChanges }) => {
            const [testStatus, setTestStatus] = useState(null);
            const [loading, setLoading] = useState(false);

            const handleRunTests = async () => {
                setLoading(true);
                setTestStatus('running');
                
                try {
                    // FRANK'S REAL TEST EXECUTION - NO SIMULATIONS
                    setTestStatus('running');
                    addLog(`Running real tests for ${task.name}...`, 'info');
                    
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            task: task,
                            criteria: task.acceptanceCriteria || 'Task completion validation',
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (testResponse.ok) {
                        const testData = await testResponse.json();
                        const status = testData.passed ? 'passed' : 'failed';
                        setTestStatus(status);
                        addLog(`Test result: ${status.toUpperCase()} - ${testData.details}`, 
                               status === 'passed' ? 'success' : 'error');
                        if (status === 'passed') onRunTests(task);
                    } else {
                        setTestStatus('failed');
                        addLog('Test execution failed', 'error');
                    }
                } catch (error) {
                    setTestStatus('failed');
                    addLog(`Test error: ${error.message}`, 'error');
                } finally {
                    setLoading(false);
                }
            };

            const getTestStatusColor = () => {
                switch (testStatus) {
                    case 'running': return 'bg-blue-600';
                    case 'passed': return 'bg-green-600';
                    case 'failed': return 'bg-red-600';
                    default: return 'bg-gray-600';
                }
            };

            return (
                <div className="flex gap-1">
                    <button 
                        onClick={() => onViewChanges(task)}
                        className="px-2 py-1 bg-gray-600 hover:bg-gray-700 rounded text-xs transition"
                    >
                        View Changes
                    </button>
                    <button 
                        onClick={handleRunTests}
                        disabled={loading}
                        className={`px-2 py-1 rounded text-xs transition ${getTestStatusColor()} hover:opacity-80 disabled:opacity-50`}
                    >
                        {loading ? 'Running...' : testStatus === 'passed' ? '✓ Tests' : testStatus === 'failed' ? '✗ Tests' : 'Run Tests'}
                    </button>
                    <button 
                        onClick={() => onApprove(task)}
                        className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-xs transition"
                    >
                        {task.prUrl ? 'Open PR' : 'Create PR'}
                    </button>
                    <button 
                        onClick={() => onRequestChanges(task)}
                        className="px-2 py-1 bg-orange-600 hover:bg-orange-700 rounded text-xs transition"
                    >
                        Request Changes
                    </button>
                </div>
            );
        };

        // Diff Viewer Component
        const DiffViewer = ({ isOpen, onClose, task, diffData }) => {
            const [loading, setLoading] = useState(false);
            const [files, setFiles] = useState([]);

            useEffect(() => {
                if (isOpen && task && task.branch) {
                    fetchDiffData();
                }
            }, [isOpen, task]);

            const fetchDiffData = async () => {
                setLoading(true);
                try {
                    const diff = await GitHubService.getCommitDiff('master', task.branch);
                    if (diff && diff.files) {
                        setFiles(diff.files);
                    }
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                } finally {
                    setLoading(false);
                }
            };

            const renderDiffLines = (patch) => {
                if (!patch) return null;
                
                const lines = patch.split('\n');
                return lines.map((line, index) => {
                    let className = 'font-mono text-sm px-4 py-1 ';
                    if (line.startsWith('+')) {
                        className += 'bg-green-900 text-green-200';
                    } else if (line.startsWith('-')) {
                        className += 'bg-red-900 text-red-200';
                    } else if (line.startsWith('@@')) {
                        className += 'bg-blue-900 text-blue-200 font-semibold';
                    } else {
                        className += 'bg-gray-800 text-gray-300';
                    }
                    
                    return (
                        <div key={index} className={className}>
                            {line || ' '}
                        </div>
                    );
                });
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-gray-800 rounded-lg max-w-6xl max-h-[90vh] w-full mx-4 flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h2 className="text-xl font-semibold">
                                Changes for: {task?.name}
                            </h2>
                            <button 
                                onClick={onClose}
                                className="text-gray-400 hover:text-white text-2xl"
                            >
                                ×
                            </button>
                        </div>
                        
                        <div className="flex-1 overflow-auto p-4">
                            {loading ? (
                                <div className="text-center py-8">
                                    <div className="text-blue-400">Loading diff...</div>
                                </div>
                            ) : files.length > 0 ? (
                                <div className="space-y-6">
                                    {files.map((file, index) => (
                                        <div key={index} className="border border-gray-700 rounded">
                                            <div className="bg-gray-700 px-4 py-2 font-mono text-sm">
                                                <span className="text-gray-300">{file.filename}</span>
                                                <span className="ml-4 text-green-400">+{file.additions}</span>
                                                <span className="ml-2 text-red-400">-{file.deletions}</span>
                                            </div>
                                            <div className="max-h-96 overflow-auto">
                                                {renderDiffLines(file.patch)}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="text-center py-8">
                                    <div className="text-gray-500">No changes found</div>
                                    <a 
                                        href={GitHubService.getCompareUrl('master', task?.branch)}
                                        target="_blank"
                                        className="text-blue-400 hover:underline mt-2 inline-block"
                                    >
                                        View on GitHub →
                                    </a>
                                </div>
                            )}
                        </div>
                        
                        <div className="p-4 border-t border-gray-700 flex justify-end gap-2">
                            <button 
                                onClick={onClose}
                                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
                            >
                                Close
                            </button>
                            <a 
                                href={GitHubService.getCompareUrl('master', task?.branch)}
                                target="_blank"
                                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
                            >
                                View on GitHub
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // Task Queue Component
        const TaskQueue = ({ tasks, onUpdateTaskStatus, onViewChanges, onRunTests, onApprove, onRequestChanges }) => {
            const [filter, setFilter] = useState('Awaiting Review');
            
            const filteredTasks = tasks.filter(task => 
                !filter || task.status === filter
            );

            const StatusBadge = ({ status }) => {
                const colors = {
                    'Awaiting Review': 'bg-yellow-600',
                    'In Review': 'bg-blue-600',
                    'Approved': 'bg-green-600',
                    'Changes Requested': 'bg-red-600',
                    'Merged': 'bg-purple-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status}
                    </span>
                );
            };

            return (
                <div className="bg-gray-800 rounded-lg p-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-xl font-semibold">Task Queue</h2>
                        <div className="flex gap-2">
                            <button 
                                onClick={() => window.location.reload()}
                                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                            >
                                Refresh from GitHub
                            </button>
                            <select 
                                value={filter}
                                onChange={(e) => setFilter(e.target.value)}
                                className="px-3 py-1 bg-gray-700 rounded border border-gray-600 text-sm"
                            >
                                <option value="">All Tasks</option>
                                <option value="Awaiting Review">Awaiting Review</option>
                                <option value="In Review">In Review</option>
                                <option value="Approved">Approved</option>
                                <option value="Changes Requested">Changes Requested</option>
                                <option value="Merged">Merged</option>
                            </select>
                        </div>
                    </div>
                    
                    <div className="overflow-x-auto">
                        <table className="w-full text-sm">
                            <thead>
                                <tr className="border-b border-gray-700">
                                    <th className="text-left py-2 px-3">Task Name</th>
                                    <th className="text-left py-2 px-3">Status</th>
                                    <th className="text-left py-2 px-3">Branch</th>
                                    <th className="text-left py-2 px-3">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {filteredTasks.map(task => (
                                    <tr key={task.id} className="border-b border-gray-700 hover:bg-gray-750">
                                        <td className="py-3 px-3">
                                            <div>
                                                <div className="font-medium">{task.name}</div>
                                                <div className="text-xs text-gray-400">{task.objective}</div>
                                            </div>
                                        </td>
                                        <td className="py-3 px-3">
                                            <StatusBadge status={task.status} />
                                        </td>
                                        <td className="py-3 px-3">
                                            <div className="space-y-1">
                                                {task.branch ? (
                                                    <a 
                                                        href={GitHubService.getBranchUrl(task.branch)}
                                                        target="_blank"
                                                        className="text-blue-400 hover:underline text-xs block"
                                                    >
                                                        {task.branch}
                                                    </a>
                                                ) : (
                                                    <span className="text-gray-500 text-xs">No branch</span>
                                                )}
                                                {task.prUrl && (
                                                    <a 
                                                        href={task.prUrl}
                                                        target="_blank"
                                                        className="text-green-400 hover:underline text-xs block"
                                                    >
                                                        View PR →
                                                    </a>
                                                )}
                                            </div>
                                        </td>
                                        <td className="py-3 px-3">
                                            <ReviewActions 
                                                task={task}
                                                onViewChanges={onViewChanges}
                                                onRunTests={onRunTests}
                                                onApprove={onApprove}
                                                onRequestChanges={onRequestChanges}
                                            />
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                        {filteredTasks.length === 0 && (
                            <div className="text-center py-8 text-gray-500">
                                No tasks found with status "{filter}"
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // State management
        const initialState = {
            request: 'Implement Task Review UI that shows completed tasks awaiting human review with GitHub integration. This must include: 1) Task Queue view showing tasks with "Awaiting Review" status after Terragon completes them, 2) Display the GitHub branch created by Terragon, 3) Show acceptance criteria as a review checklist, 4) Provide View Changes, Run Tests, Approve, and Request Changes buttons, 5) Integration with GitHub API to detect branches and create PRs, 6) Merge Review Screen showing diffs, 7) Update task status from "sent" through "completed", "awaiting review", to "merged"',
            projectContext: `# Current State
The system can execute tasks in Terragon, which creates GitHub branches, but there's no UI to review and approve these completed tasks. According to Interface.md, we need screens #3 (Task Queue), #7 (Merge Review), #9 (GitHub Integration), and #15 (Escalation Notifications).

# Requirements from Interface.md
- Task Queue must show task status management
- Merge Review Screen must show Draft vs Production diff viewer  
- GitHub Integration Panel must show repo browser and PR statuses
- System must enforce the immutable flow - no bypassing allowed
- Every action must have immediate feedback

# Technical Context
- Tasks are executed in Terragon and push to branches like "terragon/project-md-validation-system"
- System uses GitHub API for integration
- React-based UI in public/index.html
- Task state is managed in React component state`,
            task: null,
            checkpoints: [],
            executionStatus: {},
            sessionId: null,
            logs: [],
            activeThreads: {}, // Track thread IDs for each checkpoint
            taskThreadId: null, // One thread per task
            checkpointQueue: [], // Queue of checkpoints to execute
            currentCheckpointIndex: 0, // Current position in queue
            reviewTasks: [
                {
                    id: 'task-1',
                    name: 'Task Review UI Implementation',
                    objective: 'Build review interface for completed Terragon tasks with GitHub integration',
                    status: 'Awaiting Review',
                    branch: 'terragon/task-review-ui-github-integration',
                    threadId: 'thread-123',
                    acceptanceCriteria: [
                        'Task Queue component renders without errors',
                        'GitHub API integration works correctly',
                        'Review actions update task status',
                        'PR creation flow functions properly'
                    ]
                },
                {
                    id: 'task-2',
                    name: 'Discord Bot Integration',
                    objective: 'Add Discord bot for task notifications',
                    status: 'In Review',
                    branch: 'terragon/discord-bot-integration',
                    threadId: 'thread-456',
                    acceptanceCriteria: [
                        'Bot connects to Discord successfully',
                        'Notifications sent on task completion'
                    ]
                }
            ]
        };

        function App() {
            const [state, setState] = useState(initialState);
            const [loading, setLoading] = useState(false);
            const [loadingTasks, setLoadingTasks] = useState(true);
            const [executing, setExecuting] = useState(false);
            const [diffViewerOpen, setDiffViewerOpen] = useState(false);
            const [selectedTask, setSelectedTask] = useState(null);
            const executionInterval = useRef(null);

            const API_URL = '/api/task';
            const EXECUTE_URL = '/api/execute';

            // Load tasks from GitHub PRs on component mount
            useEffect(() => {
                loadTasksFromGitHub();
            }, []);

            // Load tasks by checking GitHub PR status
            const loadTasksFromGitHub = async () => {
                setLoadingTasks(true);
                addLog('Loading task status from GitHub PRs...', 'info');
                
                try {
                    // Get list of branches that match terragon pattern
                    const branches = await GitHubService.getBranches();
                    const terragonBranches = branches.filter(branch => 
                        branch.name.startsWith('terragon/')
                    );
                    
                    const updatedTasks = [];
                    
                    for (const branch of terragonBranches) {
                        try {
                            // Check if PR exists for this branch
                            const response = await fetch(`https://api.github.com/repos/bhuman-ai/unclefrank-bootstrap/pulls?head=bhuman-ai:${branch.name}&state=all`);
                            const prs = await response.json();
                            
                            let status = 'Awaiting Review'; // Default if no PR
                            let prUrl = null;
                            
                            if (prs && prs.length > 0) {
                                const pr = prs[0]; // Get most recent PR for this branch
                                prUrl = pr.html_url;
                                
                                if (pr.state === 'open') {
                                    // Check if changes are requested
                                    const reviewsResponse = await fetch(`https://api.github.com/repos/bhuman-ai/unclefrank-bootstrap/pulls/${pr.number}/reviews`);
                                    const reviews = await reviewsResponse.json();
                                    const hasRequestedChanges = reviews && reviews.some(review => review.state === 'CHANGES_REQUESTED');
                                    
                                    status = hasRequestedChanges ? 'Changes Requested' : 'In Review';
                                } else if (pr.merged) {
                                    status = 'Merged';
                                } else if (pr.state === 'closed') {
                                    status = 'Approved';
                                }
                            }
                            
                            // Create task object from branch info
                            const taskName = branch.name.replace('terragon/', '').replace(/-/g, ' ')
                                .replace(/\b\w/g, l => l.toUpperCase());
                            
                            updatedTasks.push({
                                id: `task-${branch.name}`,
                                name: taskName,
                                objective: `Implementation of ${taskName}`,
                                status: status,
                                branch: branch.name,
                                threadId: `thread-${branch.name}`,
                                prUrl: prUrl,
                                acceptanceCriteria: [
                                    'Implementation completed successfully',
                                    'Tests pass',
                                    'Code review approved'
                                ]
                            });
                            
                        } catch (error) {
                            console.error(`Error checking PR for branch ${branch.name}:`, error);
                        }
                    }
                    
                    // Update state with GitHub-sourced tasks
                    setState(prev => ({
                        ...prev,
                        reviewTasks: updatedTasks
                    }));
                    
                    addLog(`Loaded ${updatedTasks.length} tasks from GitHub`, 'success');
                    
                } catch (error) {
                    addLog(`Failed to load tasks from GitHub: ${error.message}`, 'error');
                    // FRANK'S RULE: NO FALLBACKS - FAIL FAST AND HONEST
                    addLog('System requires GitHub integration to function. Fix the connection.', 'error');
                    setTasks([]);
                }
                
                setLoadingTasks(false);
            };

            // Add log entry
            const addLog = (message, level = 'info') => {
                setState(prev => ({
                    ...prev,
                    logs: [...prev.logs, {
                        timestamp: new Date().toLocaleTimeString(),
                        message,
                        level
                    }]
                }));
            };

            // Classify request
            const classifyRequest = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('Classifying request...', 'info');
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'classify', request: state.request })
                    });
                    
                    const data = await response.json();
                    if (response.ok) {
                        addLog(`Classification: ${data.classification.type} (${(data.classification.confidence * 100).toFixed(0)}%)`, 'success');
                    } else {
                        addLog(data.error || 'Classification failed', 'error');
                    }
                } catch (error) {
                    addLog(error.message, 'error');
                }
                setLoading(false);
            };

            // Decompose task
            const decomposeTask = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('Decomposing task into checkpoints...', 'info');
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'decompose', 
                            request: state.request, 
                            projectContext: state.projectContext 
                        })
                    });
                    
                    const data = await response.json();
                    if (response.ok) {
                        setState(prev => ({
                            ...prev,
                            task: data.task,
                            checkpoints: data.checkpoints,
                            executionStatus: data.checkpoints.reduce((acc, cp) => ({
                                ...acc,
                                [cp.id]: { status: 'pending', logs: [] }
                            }), {})
                        }));
                        addLog(`Task decomposed into ${data.checkpoints.length} checkpoints`, 'success');
                    } else {
                        addLog(data.error || 'Decomposition failed', 'error');
                    }
                } catch (error) {
                    addLog(error.message, 'error');
                }
                setLoading(false);
            };

            // Execute checkpoints sequentially
            const executeCheckpointsSequentially = async () => {
                if (!state.checkpoints.length || !state.task) {
                    alert('No checkpoints to execute');
                    return;
                }
                
                setExecuting(true);
                addLog('Starting sequential checkpoint execution with Pass/Fail testing...', 'info');
                
                try {
                    // FRANK'S FIX: Send ONLY the first checkpoint, not context dump
                    const firstCheckpoint = state.checkpoints[0];
                    if (!firstCheckpoint) {
                        throw new Error('No checkpoints found to execute');
                    }
                    
                    const firstCheckpointMessage = `# CHECKPOINT 1: ${firstCheckpoint.name}

## Objective
${firstCheckpoint.objective}

## Task Context
${state.task.name}: ${state.task.objective}

## Blocking Status
${firstCheckpoint.blocking ? '🚫 BLOCKING - Must pass before continuing' : '⚡ NON-BLOCKING - Can fail without halting'}

## Instructions
${firstCheckpoint.instructions.map((inst, j) => `${j + 1}. ${inst}`).join('\n')}

## Pass Criteria (Must verify ALL):
${firstCheckpoint.passCriteria.map((pc, i) => `✓ ${i + 1}. ${pc.description}`).join('\n')}

Execute this checkpoint and report when complete. After completion, I will run tests to verify all pass criteria before proceeding to the next checkpoint.

SACRED FLOW: This is checkpoint 1 of ${state.checkpoints.length}. Each checkpoint will be sent individually after the previous one passes its tests.`;

                    // Create Terragon thread with FIRST CHECKPOINT ONLY
                    const dashboardPayload = [{
                        message: {
                            type: 'user',
                            model: 'sonnet',
                            parts: [{
                                type: 'rich-text',
                                nodes: [{
                                    type: 'text',
                                    text: firstCheckpointMessage
                                }]
                            }],
                            timestamp: new Date().toISOString()
                        },
                        githubRepoFullName: 'bhuman-ai/unclefrank-bootstrap',
                        repoBaseBranchName: 'master',
                        saveAsDraft: false
                    }];

                    const response = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'create-task',
                            payload: dashboardPayload
                        })
                    });
                    
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `Failed to create Terragon task: ${response.status}`);
                    }
                    
                    const threadId = result.threadId;
                    const threadUrl = `https://www.terragonlabs.com/task/${threadId}`;
                    
                    addLog(`✅ Checkpoint 1 sent to Terragon thread: ${threadId}`, 'success');
                    addLog(`Monitor at: ${threadUrl}`, 'info');
                    
                    // Initialize state - mark checkpoint 1 as executing (since we just sent it)
                    setState(prev => {
                        const firstCheckpoint = prev.checkpoints[0];
                        const newExecutionStatus = {
                            [firstCheckpoint.id]: {
                                status: 'executing',
                                threadId: threadId,
                                startTime: new Date().toISOString(),
                                logs: [{ 
                                    message: `Checkpoint 1 sent to Terragon`,
                                    url: threadUrl
                                }]
                            }
                        };
                        
                        const newState = { 
                            ...prev, 
                            sessionId: threadId,
                            taskThreadId: threadId,
                            checkpointQueue: [...prev.checkpoints],
                            currentCheckpointIndex: 0,
                            executionStatus: newExecutionStatus
                        };
                        
                        // FRANK'S REAL FIX: Poll Terragon until actual completion
                        setTimeout(() => {
                            addLog('🔍 Polling Terragon thread for actual completion...', 'info');
                            pollTerragonForCompletion(threadId, firstCheckpoint, newState.checkpointQueue, 0);
                        }, 5000); // Give it 5 seconds to start, then poll
                        
                        return newState;
                    });
                    
                } catch (error) {
                    addLog(`Execution error: ${error.message}`, 'error');
                    setExecuting(false);
                }
            };

            // FRANK'S UI-BASED COMPLETION DETECTION - TRACK UI INDICATORS
            const messageTracker = {}; // Store message state per thread
            
            const pollTerragonForCompletion = async (threadId, checkpoint, queue, currentIndex, pollCount = 0) => {
                const maxPolls = 120; // Max 10 minutes of polling (5 seconds * 120)
                const checkpointNumber = currentIndex + 1;
                
                // Initialize tracker for this thread if needed
                if (!messageTracker[threadId]) {
                    messageTracker[threadId] = {
                        lastMessageCount: 0,
                        lastMessageTime: Date.now(),
                        uiQuietCount: 0 // Track polls without UI activity
                    };
                }
                
                addLog(`🔄 Polling attempt ${pollCount + 1}: Checking if Terragon completed checkpoint ${checkpointNumber}`, 'info');
                
                try {
                    // Check Terragon thread status via our API
                    const statusResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'check-terragon-status',
                            threadId: threadId,
                            lastMessageCount: messageTracker[threadId].lastMessageCount,
                            lastMessageTime: messageTracker[threadId].lastMessageTime
                        })
                    });
                    
                    if (statusResponse.ok) {
                        const statusResult = await statusResponse.json();
                        
                        // Update message tracker
                        if (statusResult.messageCount !== undefined) {
                            if (statusResult.messageCount > messageTracker[threadId].lastMessageCount) {
                                // New messages detected
                                addLog(`📝 New message detected (${statusResult.messageCount} total messages)`, 'info');
                                messageTracker[threadId].lastMessageCount = statusResult.messageCount;
                                messageTracker[threadId].lastMessageTime = statusResult.lastMessageTime;
                                
                                // Try to detect branch from message
                                if (statusResult.lastResponse) {
                                    try {
                                        const branchExtract = await fetch('/api/branch-tracker', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({
                                                action: 'extract',
                                                message: statusResult.lastResponse
                                            })
                                        });
                                        
                                        if (branchExtract.ok) {
                                            const branchData = await branchExtract.json();
                                            if (branchData.branch) {
                                                // Record the branch for this thread
                                                await fetch('/api/branch-tracker', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({
                                                        action: 'record',
                                                        threadId: threadId,
                                                        branchName: branchData.branch
                                                    })
                                                });
                                                addLog(`🔍 Detected branch: ${branchData.branch}`, 'info');
                                            }
                                        }
                                    } catch (e) {
                                        console.error('Branch extraction failed:', e);
                                    }
                                }
                                
                            }
                        }
                        
                        // Status-based updates
                        if (statusResult.status === 'starting') {
                            addLog(`⏳ Terragon is starting up...`, 'info');
                        } else if (statusResult.status === 'checkpointing') {
                            addLog(`💾 Terragon is creating a checkpoint...`, 'info');
                        }
                        
                        if (statusResult.completed && statusResult.status === 'completed') {
                            addLog(`✅ Terragon completed execution!`, 'success');
                            
                            // Wait for Terragon to push changes before testing
                            addLog(`⏳ Waiting for Terragon to push changes...`, 'info');
                            
                            // Poll for branch push confirmation (check if branch exists on GitHub)
                            const waitForPush = async (branchName, maxAttempts = 10) => {
                                for (let i = 0; i < maxAttempts; i++) {
                                    try {
                                        // Check if branch exists on GitHub
                                        const checkResponse = await fetch(`https://api.github.com/repos/bhuman-ai/unclefrank-bootstrap/branches/${branchName}`, {
                                            headers: {
                                                'Accept': 'application/vnd.github.v3+json'
                                            }
                                        });
                                        
                                        if (checkResponse.ok) {
                                            addLog(`✅ Branch ${branchName} pushed to GitHub!`, 'success');
                                            return true;
                                        }
                                    } catch (e) {
                                        console.error('Error checking branch:', e);
                                    }
                                    
                                    if (i < maxAttempts - 1) {
                                        addLog(`⏳ Branch not found yet, checking again in 5 seconds... (${i + 1}/${maxAttempts})`, 'info');
                                        await new Promise(resolve => setTimeout(resolve, 5000));
                                    }
                                }
                                return false;
                            };
                            
                            // Get the branch Terragon is working on
                            let targetBranch = 'master';
                            try {
                                const branchResponse = await fetch('/api/branch-tracker', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        action: 'get',
                                        threadId: threadId
                                    })
                                });
                                
                                if (branchResponse.ok) {
                                    const branchData = await branchResponse.json();
                                    if (branchData.branch) {
                                        targetBranch = branchData.branch;
                                        addLog(`🔍 Detected Terragon branch: ${targetBranch}`, 'info');
                                    }
                                }
                            } catch (e) {
                                console.error('Branch detection failed:', e);
                            }
                            
                            // Wait for push if not on master
                            if (targetBranch !== 'master') {
                                const pushed = await waitForPush(targetBranch);
                                if (!pushed) {
                                    addLog(`⚠️ Branch ${targetBranch} not pushed after timeout, testing anyway...`, 'warning');
                                }
                            }
                            
                            // NOW run contextless tests after push confirmed
                            setTimeout(() => {
                                testCheckpointAndContinue(checkpoint, queue, currentIndex, threadId);
                            }, 1000);
                            return;
                        } else if (statusResult.completed && statusResult.status === 'error') {
                            addLog(`❌ Terragon encountered an error in checkpoint ${checkpointNumber}`, 'error');
                            addLog(`📝 Error details: ${statusResult.message}`, 'error');
                            addLog(`🚫 Checkpoint execution failed - stopping`, 'error');
                            setExecuting(false);
                            return;
                        } else if (statusResult.status === 'error') {
                            addLog(`❌ Terragon encountered an error`, 'error');
                            clearInterval(pollInterval);
                            reject(new Error('Terragon execution failed'));
                            return;
                        }
                    } else {
                        addLog(`⚠️ Could not check Terragon status, assuming still working...`, 'info');
                    }
                    
                    // Continue polling if not complete and under max attempts
                    if (pollCount < maxPolls) {
                        setTimeout(() => {
                            pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1);
                        }, 5000); // Poll every 5 seconds
                    } else {
                        addLog(`🕐 Max polling time reached (5 minutes). Proceeding with tests anyway...`, 'error');
                        testCheckpointAndContinue(checkpoint, queue, currentIndex, threadId);
                    }
                    
                } catch (error) {
                    addLog(`Polling error: ${error.message}`, 'error');
                    
                    // If polling fails, wait a bit more and continue
                    if (pollCount < 5) {
                        setTimeout(() => {
                            pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1);
                        }, 10000);
                    } else {
                        addLog(`Polling failed multiple times, proceeding with tests...`, 'error');
                        testCheckpointAndContinue(checkpoint, queue, currentIndex, threadId);
                    }
                }
            };

            // FRANK'S REAL TEST AND CONTINUE FUNCTION
            const testCheckpointAndContinue = async (checkpoint, queue, currentIndex, executionThreadId) => {
                const checkpointNumber = currentIndex + 1;
                addLog(`🧪 Testing checkpoint ${checkpointNumber}: ${checkpoint.name}`, 'info');
                
                try {
                    addLog(`🎯 Running contextless tests for checkpoint ${checkpointNumber}`, 'info');
                    // Pass the execution thread ID so we test the right branch
                    const testResult = await testCheckpoint(checkpoint, executionThreadId);
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        if (currentIndex + 1 < queue.length) {
                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                        } else {
                            addLog('🎉 All checkpoints completed!', 'success');
                            await validateTaskCompletion();
                            setExecuting(false);
                        }
                        
                    } else {
                        addLog(`❌ Checkpoint ${checkpointNumber} FAILED tests!`, 'error');
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'fail',
                                    testResults: testResult,
                                    failedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        if (checkpoint.blocking) {
                            addLog('🚫 Blocking checkpoint failed - execution stopped', 'error');
                            setExecuting(false);
                        } else {
                            addLog('⚡ Non-blocking checkpoint failed - continuing', 'info');
                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                        }
                    }
                } catch (error) {
                    addLog(`Test error: ${error.message}`, 'error');
                    setExecuting(false);
                }
            };

            // Execute next checkpoint with explicit parameters (avoids stale closure)
            const executeNextCheckpointWithQueue = async (queue, currentIndex, threadId) => {
                console.log('executeNextCheckpointWithQueue called with:', {
                    queueLength: queue?.length || 0,
                    currentIndex,
                    threadId
                });
                
                addLog(`Checking execution: index=${currentIndex}, queue length=${queue?.length || 0}`, 'info');
                
                if (!queue || queue.length === 0) {
                    addLog('ERROR: No checkpoints found in queue!', 'error');
                    setExecuting(false);
                    return;
                }
                
                if (currentIndex >= queue.length) {
                    addLog('All checkpoints completed, running final validation...', 'info');
                    await validateTaskCompletion();
                    setExecuting(false);
                    return;
                }
                
                const checkpoint = queue[currentIndex];
                const checkpointNumber = currentIndex + 1;
                addLog(`=== Starting Checkpoint ${checkpointNumber}/${queue.length}: ${checkpoint.name} ===`, 'info');
                
                // Update current checkpoint index in state
                setState(prev => ({
                    ...prev,
                    currentCheckpointIndex: currentIndex
                }));
                
                // Continue with checkpoint execution...
                await executeCheckpointWithParams(checkpoint, queue, currentIndex, threadId);
            };

            // Execute individual checkpoint with explicit parameters
            const executeCheckpointWithParams = async (checkpoint, queue, currentIndex, threadId) => {
                const checkpointNumber = currentIndex + 1;
                
                // Validate dependencies before execution
                const dependenciesValid = await validateDependencies(checkpoint);
                if (!dependenciesValid) {
                    addLog(`Dependencies not met for ${checkpoint.name}, waiting...`, 'error');
                    setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex, threadId), 2000);
                    return;
                }
                
                // Get current retry count
                const currentStatus = state.executionStatus[checkpoint.id];
                const retryCount = currentStatus?.retryCount || 0;
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { 
                            status: 'in_progress', 
                            logs: [], 
                            retryCount: retryCount,
                            startTime: new Date().toISOString()
                        }
                    }
                }));
                
                try {
                    // Send checkpoint to Terragon via API proxy
                    const execResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: threadId
                        })
                    });
                    
                    if (!execResponse.ok) {
                        const errorData = await execResponse.json();
                        throw new Error(errorData.error || 'Failed to execute checkpoint');
                    }
                    
                    const execData = await execResponse.json();
                    addLog(`Checkpoint sent to thread: ${execData.threadId}`, 'info');
                    
                    // Update status to executing
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                ...prev.executionStatus[checkpoint.id],
                                status: 'executing',
                                threadId: threadId,
                                logs: [{ 
                                    message: `Executing in thread: ${threadId}`,
                                    url: `https://www.terragonlabs.com/task/${threadId}`
                                }]
                            }
                        }
                    }));
                    
                    addLog(`✅ Checkpoint ${checkpointNumber} sent to Terragon thread: ${threadId}`, 'success');
                    addLog(`Monitor at: https://www.terragonlabs.com/task/${threadId}`, 'info');
                    
                    // FRANK'S REAL POLLING - NO FAKE TIMING
                    addLog(`🔍 Waiting for Terragon to complete checkpoint ${checkpointNumber}...`, 'info');
                    setTimeout(() => {
                        pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex);
                    }, 2000); // Small delay before polling starts
                    
                    return; // Exit here - polling will handle the rest
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                        
                    } else {
                        // Handle failure with retry logic
                        const newRetryCount = retryCount + 1;
                        
                        if (newRetryCount < 3) {
                            addLog(`❌ Checkpoint ${checkpointNumber} FAILED - Retry ${newRetryCount}/3`, 'error');
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'retrying',
                                        retryCount: newRetryCount,
                                        testResults: testResult
                                    }
                                }
                            }));
                            
                            // Retry same checkpoint
                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex, threadId), 3000);
                        } else {
                            addLog(`🛑 Checkpoint ${checkpointNumber} FAILED after 3 attempts!`, 'error');
                            if (checkpoint.blocking) {
                                addLog(`🚫 This is a BLOCKING checkpoint - execution halted`, 'error');
                            }
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'fail',
                                        testResults: testResult,
                                        failedTime: new Date().toISOString()
                                    }
                                }
                            }));
                            
                            // If blocking checkpoint failed, stop execution
                            if (checkpoint.blocking) {
                                setExecuting(false);
                                addLog('Execution stopped due to blocking checkpoint failure', 'error');
                            } else {
                                // Non-blocking can continue
                                addLog('Non-blocking checkpoint failed, continuing...', 'info');
                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                            }
                        }
                    }
                    
                } catch (error) {
                    addLog(`Checkpoint execution error: ${error.message}`, 'error');
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }],
                                error: error.message
                            }
                        }
                    }));
                    
                    if (checkpoint.blocking) {
                        setExecuting(false);
                        addLog('Execution stopped due to error in blocking checkpoint', 'error');
                    } else {
                        // Try next checkpoint for non-blocking
                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                    }
                }
            };

            // Execute next checkpoint in queue (legacy - uses state)
            const executeNextCheckpoint = async () => {
                console.log('executeNextCheckpoint called');
                console.log('Current state:', {
                    currentCheckpointIndex: state.currentCheckpointIndex,
                    checkpointQueue: state.checkpointQueue?.length,
                    checkpoints: state.checkpoints?.length
                });
                
                const currentIndex = state.currentCheckpointIndex || 0;
                const queue = state.checkpointQueue || state.checkpoints;
                
                addLog(`Checking execution: index=${currentIndex}, queue length=${queue?.length || 0}`, 'info');
                
                if (!queue || queue.length === 0) {
                    addLog('ERROR: No checkpoints found in queue!', 'error');
                    setExecuting(false);
                    return;
                }
                
                if (currentIndex >= queue.length) {
                    addLog('All checkpoints completed, running final validation...', 'info');
                    await validateTaskCompletion();
                    setExecuting(false);
                    return;
                }
                
                const checkpoint = queue[currentIndex];
                const checkpointNumber = currentIndex + 1;
                addLog(`=== Starting Checkpoint ${checkpointNumber}/${queue.length}: ${checkpoint.name} ===`, 'info');
                
                // Validate dependencies before execution
                const dependenciesValid = await validateDependencies(checkpoint);
                if (!dependenciesValid) {
                    addLog(`Dependencies not met for ${checkpoint.name}, waiting...`, 'error');
                    setTimeout(() => executeNextCheckpoint(), 2000);
                    return;
                }
                
                // Get current retry count
                const currentStatus = state.executionStatus[checkpoint.id];
                const retryCount = currentStatus?.retryCount || 0;
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { 
                            status: 'in_progress', 
                            logs: [], 
                            retryCount: retryCount,
                            startTime: new Date().toISOString()
                        }
                    }
                }));
                
                try {
                    // Send checkpoint execution message to existing Terragon thread
                    const checkpointMessage = `# CHECKPOINT ${checkpointNumber}: ${checkpoint.name}

## Objective
${checkpoint.objective}

## Blocking Status
${checkpoint.blocking ? '🚫 BLOCKING - Must pass before continuing' : '⚡ NON-BLOCKING - Can fail without halting'}

## Instructions
${checkpoint.instructions.map((inst, j) => `${j + 1}. ${inst}`).join('\n')}

## Pass Criteria (Must verify ALL):
${checkpoint.passCriteria.map((pc, i) => `✓ ${i + 1}. ${pc.description}`).join('\n')}

Please execute this checkpoint and report when complete. I will then run tests to verify all pass criteria.`;

                    // Send checkpoint to Terragon via API proxy
                    const execResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: state.taskThreadId
                        })
                    });
                    
                    if (!execResponse.ok) {
                        const errorData = await execResponse.json();
                        throw new Error(errorData.error || 'Failed to execute checkpoint');
                    }
                    
                    const execData = await execResponse.json();
                    addLog(`Checkpoint sent to thread: ${execData.threadId}`, 'info');
                    
                    // Update status to executing
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                ...prev.executionStatus[checkpoint.id],
                                status: 'executing',
                                threadId: state.taskThreadId,
                                logs: [{ 
                                    message: `Executing in thread: ${state.taskThreadId}`,
                                    url: `https://www.terragonlabs.com/task/${state.taskThreadId}`
                                }]
                            }
                        }
                    }));
                    
                    addLog(`Checkpoint sent to Terragon, waiting for execution...`, 'info');
                    
                    // Wait for Terragon to execute (in real implementation, would poll for completion)
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
                    // Run pass/fail tests
                    addLog(`Running Pass/Fail tests for ${checkpoint.name}...`, 'info');
                    const testResult = await testCheckpoint(checkpoint);
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            currentCheckpointIndex: currentIndex + 1,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        setTimeout(() => executeNextCheckpoint(), 2000);
                        
                    } else {
                        // Handle failure with retry logic
                        const newRetryCount = retryCount + 1;
                        
                        if (newRetryCount < 3) {
                            addLog(`❌ Checkpoint ${checkpointNumber} FAILED - Retry ${newRetryCount}/3`, 'error');
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'retrying',
                                        retryCount: newRetryCount,
                                        testResults: testResult
                                    }
                                }
                            }));
                            
                            // Retry same checkpoint
                            setTimeout(() => executeNextCheckpoint(), 3000);
                        } else {
                            addLog(`🛑 Checkpoint ${checkpointNumber} FAILED after 3 attempts!`, 'error');
                            if (checkpoint.blocking) {
                                addLog(`🚫 This is a BLOCKING checkpoint - execution halted`, 'error');
                            }
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'fail',
                                        testResults: testResult,
                                        failedTime: new Date().toISOString()
                                    }
                                }
                            }));
                            
                            // If blocking checkpoint failed, stop execution
                            if (checkpoint.blocking) {
                                setExecuting(false);
                                addLog('Execution stopped due to blocking checkpoint failure', 'error');
                            } else {
                                // Non-blocking can continue
                                addLog('Non-blocking checkpoint failed, continuing...', 'info');
                                setState(prev => ({
                                    ...prev,
                                    currentCheckpointIndex: currentIndex + 1
                                }));
                                setTimeout(() => executeNextCheckpoint(), 2000);
                            }
                        }
                    }
                    
                } catch (error) {
                    addLog(`Checkpoint execution error: ${error.message}`, 'error');
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }],
                                error: error.message
                            }
                        }
                    }));
                    
                    if (checkpoint.blocking) {
                        setExecuting(false);
                        addLog('Execution stopped due to error in blocking checkpoint', 'error');
                    } else {
                        // Try next checkpoint for non-blocking
                        setState(prev => ({
                            ...prev,
                            currentCheckpointIndex: currentIndex + 1
                        }));
                        setTimeout(() => executeNextCheckpoint(), 2000);
                    }
                }
            };

            // Test checkpoint pass/fail criteria
            const testCheckpoint = async (checkpoint, executionThreadId) => {
                addLog(`Running tests for ${checkpoint.name}...`, 'info');
                
                try {
                    const testResults = {
                        checkpointId: checkpoint.id,
                        checkpointName: checkpoint.name,
                        totalTests: checkpoint.passCriteria.length,
                        passedTests: [],
                        failedTests: [],
                        passed: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    // Test each pass criteria
                    for (let i = 0; i < checkpoint.passCriteria.length; i++) {
                        const criteria = checkpoint.passCriteria[i];
                        addLog(`Testing: ${criteria.description}`, 'info');
                        
                        try {
                            // FRANK'S CONTEXTLESS TEST - NEW TERRAGON INSTANCE
                            // Use execution thread ID, not task thread ID!
                            const testPassed = await executeContextlessTest(criteria, checkpoint, executionThreadId || state.taskThreadId);
                            
                            if (testPassed) {
                                testResults.passedTests.push({
                                    description: criteria.description,
                                    status: 'pass',
                                    details: `✓ ${criteria.description} verified successfully`
                                });
                                addLog(`✓ Test passed: ${criteria.description}`, 'success');
                            } else {
                                testResults.failedTests.push({
                                    description: criteria.description,
                                    status: 'fail',
                                    details: `✗ ${criteria.description} did not meet requirements`
                                });
                                addLog(`✗ Test failed: ${criteria.description}`, 'error');
                            }
                            
                        } catch (testError) {
                            testResults.failedTests.push({
                                description: criteria.description,
                                status: 'error',
                                details: `Error testing ${criteria.description}: ${testError.message}`
                            });
                            addLog(`Error testing ${criteria.description}: ${testError.message}`, 'error');
                        }
                    }
                    
                    // Determine overall pass/fail
                    testResults.passed = testResults.failedTests.length === 0;
                    
                    addLog(`Test summary: ${testResults.passedTests.length}/${testResults.totalTests} passed`, 
                           testResults.passed ? 'success' : 'error');
                    
                    return testResults;
                    
                } catch (error) {
                    addLog(`Test runner error: ${error.message}`, 'error');
                    return {
                        checkpointId: checkpoint.id,
                        passed: false,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    };
                }
            };

            // FRANK'S CONTEXTLESS TEST EXECUTION - NEW TERRAGON INSTANCE FOR EACH TEST
            const executeContextlessTest = async (criteria, checkpoint, mainThreadId) => {
                addLog(`🆕 CONTEXTLESS TEST: ${criteria.description}`, 'info');
                addLog(`Creating fresh Terragon instance for unbiased testing...`, 'info');
                
                try {
                    // Create NEW Terragon instance for contextless testing
                    // Detect branch for testing using branch tracker
                    let targetBranch = 'master';
                    
                    // FRANK'S SIMPLE FIX: Just check branch tracker - Terragon is explicit
                    try {
                        const branchResponse = await fetch('/api/branch-tracker', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'get',
                                threadId: executionThreadId || mainThreadId
                            })
                        });
                        
                        if (branchResponse.ok) {
                            const branchData = await branchResponse.json();
                            if (branchData.branch) {
                                targetBranch = branchData.branch;
                                console.log(`Testing on tracked branch: ${targetBranch}`);
                                addLog(`📌 Testing on branch: ${targetBranch}`, 'info');
                            } else {
                                addLog(`⚠️ No branch tracked for thread ${executionThreadId || mainThreadId} - using master`, 'warning');
                            }
                        }
                    } catch (e) {
                        console.error('Branch detection failed:', e);
                        addLog(`❌ Branch detection error: ${e.message}`, 'error');
                    }
                    
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'test-real',
                            criteria,
                            testDescription: criteria.description,
                            mainThreadId: mainThreadId,
                            targetBranch: targetBranch
                        })
                    });
                    
                    if (!testResponse.ok) {
                        addLog(`Test instance creation failed: ${testResponse.status}`, 'error');
                        return false;
                    }
                    
                    const testResult = await testResponse.json();
                    
                    if (testResult.testInstanceCreated) {
                        addLog(`✅ Test instance created: ${testResult.testThreadId}`, 'success');
                        if (testResult.targetBranch && testResult.targetBranch !== 'master') {
                            addLog(`🔍 Testing on branch: ${testResult.targetBranch}`, 'warning');
                        }
                        addLog(`🔗 Test URL: ${testResult.testUrl}`, 'info');
                        addLog(`⏳ Polling test instance for REAL results...`, 'info');
                        
                        // FRANK'S REAL TEST RESULT POLLING - NO BULLSHIT
                        const testInstanceResult = await pollTestInstanceForResults(testResult.testThreadId, 60); // 5 minute max
                        
                        if (testInstanceResult.completed && testInstanceResult.result) {
                            const passed = testInstanceResult.result.toLowerCase().includes('pass');
                            addLog(`🧪 Test instance completed: ${passed ? 'PASS' : 'FAIL'}`, passed ? 'success' : 'error');
                            addLog(`📝 Test evidence: ${testInstanceResult.evidence}`, 'info');
                            return passed;
                        } else {
                            addLog(`❌ Test instance failed to complete or provide results`, 'error');
                            return false;
                        }
                        
                    } else {
                        addLog(`Test instance creation failed`, 'error');
                        return false;
                    }
                    
                } catch (error) {
                    addLog(`Contextless test error: ${error.message}`, 'error');
                    return false;
                }
            };

            // FRANK'S REAL TEST INSTANCE POLLING - NO FAKE RESULTS
            const pollTestInstanceForResults = async (testThreadId, maxPolls = 60) => {
                addLog(`🔄 Polling test instance ${testThreadId} for real results...`, 'info');
                
                for (let pollCount = 0; pollCount < maxPolls; pollCount++) {
                    try {
                        // Check test instance status
                        const statusResponse = await fetch('/api/execute', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                action: 'check-terragon-status',
                                threadId: testThreadId
                            })
                        });
                        
                        if (statusResponse.ok) {
                            const statusResult = await statusResponse.json();
                            
                            if (statusResult.completed) {
                                addLog(`✅ Test instance ${testThreadId} completed!`, 'success');
                                
                                // Parse the actual test result from Terragon response
                                // Look for RESULT: PASS/FAIL pattern in the response
                                const testContent = statusResult.lastResponse || statusResult.message || '';
                                
                                let result = 'UNKNOWN';
                                let evidence = 'No evidence found';
                                
                                // Extract RESULT: and EVIDENCE: from Terragon response
                                const resultMatch = testContent.match(/RESULT:\s*(PASS|FAIL)/i);
                                const evidenceMatch = testContent.match(/EVIDENCE:\s*([^\n]+)/i);
                                
                                if (resultMatch) {
                                    result = resultMatch[1].toUpperCase();
                                }
                                if (evidenceMatch) {
                                    evidence = evidenceMatch[1].trim();
                                }
                                
                                return {
                                    completed: true,
                                    result: result,
                                    evidence: evidence,
                                    fullResponse: testContent
                                };
                            } else {
                                if (pollCount % 6 === 0) { // Log every 30 seconds
                                    addLog(`⏳ Test instance still running... (${pollCount * 5}s elapsed)`, 'info');
                                }
                            }
                        }
                        
                        // Wait 5 seconds before next poll
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        
                    } catch (error) {
                        addLog(`Test polling error: ${error.message}`, 'error');
                    }
                }
                
                // Max polls reached
                addLog(`🕐 Test instance polling timeout after ${maxPolls * 5} seconds`, 'error');
                return {
                    completed: false,
                    result: 'TIMEOUT',
                    evidence: 'Test instance did not complete within timeout period'
                };
            };

            // Validate checkpoint dependencies
            const validateDependencies = async (checkpoint) => {
                const currentIndex = state.currentCheckpointIndex || 0;
                const queue = state.checkpointQueue || state.checkpoints;
                
                // For the first checkpoint, no dependencies to check
                if (currentIndex === 0) {
                    return true;
                }
                
                // Check all previous checkpoints
                for (let i = 0; i < currentIndex; i++) {
                    const previousCheckpoint = queue[i];
                    const previousStatus = state.executionStatus[previousCheckpoint.id];
                    
                    // If previous checkpoint is blocking and hasn't passed, we can't proceed
                    if (previousCheckpoint.blocking && previousStatus?.status !== 'pass') {
                        addLog(`Blocked by ${previousCheckpoint.name} (status: ${previousStatus?.status || 'unknown'})`, 'error');
                        return false;
                    }
                    
                    // If previous checkpoint is still executing, wait for non-blocking
                    if (previousStatus?.status === 'in_progress' || previousStatus?.status === 'executing') {
                        if (previousCheckpoint.blocking) {
                            addLog(`Waiting for blocking checkpoint: ${previousCheckpoint.name}`, 'info');
                            return false;
                        } else {
                            // Non-blocking can run in parallel - this is allowed
                            addLog(`Running in parallel with non-blocking: ${previousCheckpoint.name}`, 'info');
                        }
                    }
                    
                    // If a blocking checkpoint failed, halt execution
                    if (previousCheckpoint.blocking && previousStatus?.status === 'fail') {
                        addLog(`Cannot proceed: blocking checkpoint ${previousCheckpoint.name} failed`, 'error');
                        return false;
                    }
                }
                
                // All dependency checks passed
                return true;
            };

            // Get dependency status for UI display
            const getDependencyStatus = (checkpoint) => {
                const currentIndex = state.checkpoints.findIndex(cp => cp.id === checkpoint.id);
                if (currentIndex === 0) return 'ready';
                
                // Check blocking dependencies
                for (let i = 0; i < currentIndex; i++) {
                    const previousCheckpoint = state.checkpoints[i];
                    const previousStatus = state.executionStatus[previousCheckpoint.id];
                    
                    if (previousCheckpoint.blocking && previousStatus?.status !== 'pass') {
                        return 'blocked';
                    }
                }
                
                return 'ready';
            };

            // Validate task completion - end-to-end validation
            const validateTaskCompletion = async () => {
                addLog('Running end-to-end task validation...', 'info');
                
                try {
                    if (!state.task || !state.task.acceptanceCriteria) {
                        addLog('No acceptance criteria defined for task', 'error');
                        return false;
                    }
                    
                    const taskValidation = {
                        taskId: state.task.id || 'current-task',
                        taskName: state.task.name,
                        totalCriteria: state.task.acceptanceCriteria.length,
                        passedCriteria: [],
                        failedCriteria: [],
                        checkpointSummary: {},
                        passed: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    // First, verify all checkpoints have passed
                    let allCheckpointsPassed = true;
                    state.checkpoints.forEach(checkpoint => {
                        const status = state.executionStatus[checkpoint.id];
                        taskValidation.checkpointSummary[checkpoint.id] = {
                            name: checkpoint.name,
                            status: status?.status || 'unknown',
                            blocking: checkpoint.blocking
                        };
                        
                        if (checkpoint.blocking && status?.status !== 'pass') {
                            allCheckpointsPassed = false;
                            addLog(`Critical checkpoint failed: ${checkpoint.name}`, 'error');
                        }
                    });
                    
                    if (!allCheckpointsPassed) {
                        addLog('Task validation failed: critical checkpoints not passed', 'error');
                        return false;
                    }
                    
                    // Test each acceptance criteria
                    for (let i = 0; i < state.task.acceptanceCriteria.length; i++) {
                        const criteria = state.task.acceptanceCriteria[i];
                        addLog(`Validating acceptance criteria: ${criteria}`, 'info');
                        
                        try {
                            // Call API for end-to-end testing
                            const validationResponse = await fetch(EXECUTE_URL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    action: 'validate-task',
                                    task: state.task,
                                    criteria,
                                    checkpointResults: state.executionStatus,
                                    sessionId: state.taskThreadId
                                })
                            });
                            
                            // REAL VALIDATION - NO FAKE SHIT
                            const criteriaPassed = await executeRealTaskValidation(criteria);
                            
                            if (criteriaPassed) {
                                taskValidation.passedCriteria.push({
                                    description: criteria,
                                    status: 'pass',
                                    details: `✓ ${criteria} validated successfully`
                                });
                                addLog(`✓ Acceptance criteria passed: ${criteria}`, 'success');
                            } else {
                                taskValidation.failedCriteria.push({
                                    description: criteria,
                                    status: 'fail',
                                    details: `✗ ${criteria} does not meet requirements`
                                });
                                addLog(`✗ Acceptance criteria failed: ${criteria}`, 'error');
                            }
                            
                        } catch (validationError) {
                            taskValidation.failedCriteria.push({
                                description: criteria,
                                status: 'error',
                                details: `Error validating ${criteria}: ${validationError.message}`
                            });
                            addLog(`Error validating ${criteria}: ${validationError.message}`, 'error');
                        }
                    }
                    
                    // Determine overall task completion
                    taskValidation.passed = taskValidation.failedCriteria.length === 0;
                    
                    if (taskValidation.passed) {
                        addLog(`🎉 Task validation successful! All ${taskValidation.totalCriteria} criteria passed`, 'success');
                        addLog('Task is ready for human review', 'success');
                        
                        // Update task status to awaiting review
                        setState(prev => ({
                            ...prev,
                            taskStatus: 'Awaiting Review',
                            taskValidationResults: taskValidation
                        }));
                        
                        // Add to review queue
                        const reviewTask = {
                            id: `task-${Date.now()}`,
                            name: state.task.name,
                            objective: state.task.objective,
                            status: 'Awaiting Review',
                            branch: `terragon/${state.task.name.toLowerCase().replace(/\s+/g, '-')}`,
                            threadId: state.taskThreadId,
                            acceptanceCriteria: state.task.acceptanceCriteria,
                            completedAt: new Date().toISOString(),
                            validationResults: taskValidation
                        };
                        
                        setState(prev => ({
                            ...prev,
                            reviewTasks: [...prev.reviewTasks, reviewTask]
                        }));
                        
                    } else {
                        addLog(`Task validation failed: ${taskValidation.failedCriteria.length}/${taskValidation.totalCriteria} criteria failed`, 'error');
                        addLog('Task requires additional work before review', 'error');
                    }
                    
                    return taskValidation.passed;
                    
                } catch (error) {
                    addLog(`Task validation error: ${error.message}`, 'error');
                    return false;
                }
            };

            // REAL TASK VALIDATION - NO FAKE BULLSHIT
            const executeRealTaskValidation = async (criteria) => {
                addLog(`REAL TASK VALIDATION: ${criteria}`, 'info');
                
                try {
                    // Call API to run actual task-level validation
                    const validationResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            criteria,
                            task: state.task,
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (!validationResponse.ok) {
                        addLog(`Task validation API failed: ${validationResponse.status}`, 'error');
                        return false;
                    }
                    
                    const validationResult = await validationResponse.json();
                    addLog(`Task validation: ${validationResult.passed ? 'PASSED' : 'FAILED'} - ${validationResult.details}`, 
                           validationResult.passed ? 'success' : 'error');
                    
                    return validationResult.passed;
                    
                } catch (error) {
                    addLog(`Task validation error: ${error.message}`, 'error');
                    return false;
                }
            };

            // No longer executing checkpoints individually
            const executeCheckpoint = async (checkpoint) => {
                // DEPRECATED - we now send all checkpoints to one thread
                addLog(`Executing: ${checkpoint.name}`, 'info');
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { status: 'in_progress', logs: [] }
                    }
                }));
                
                try {
                    // Execute via Terragon
                    const execResponse = await fetch(EXECUTE_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: state.sessionId
                        })
                    });
                    
                    const execData = await execResponse.json();
                    if (!execResponse.ok) throw new Error(execData.error);
                    
                    const threadUrl = `https://www.terragonlabs.com/task/${execData.threadId}`;
                    addLog(`${checkpoint.name}: Created in thread ${execData.threadId}`, 'success');
                    
                    // Update status to show execution was sent to Terragon
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'sent',
                                threadId: execData.threadId,
                                logs: [{ 
                                    message: `Executing in Terragon thread: ${execData.threadId}`,
                                    url: threadUrl
                                }]
                            }
                        },
                        activeThreads: {
                            ...prev.activeThreads,
                            [checkpoint.id]: execData.threadId
                        }
                    }));
                    
                } catch (error) {
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }]
                            }
                        }
                    }));
                    addLog(`${checkpoint.name} failed: ${error.message}`, 'error');
                }
            };

            // Checkpoint status badge
            const StatusBadge = ({ status }) => {
                const colors = {
                    pending: 'bg-gray-600',
                    in_progress: 'bg-blue-600',
                    sent: 'bg-purple-600',
                    pass: 'bg-green-600',
                    fail: 'bg-red-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status}
                    </span>
                );
            };

            // Chat functions
            const sendChatMessage = async () => {
                if (!state.chatInput.trim() || !state.chatThreadId) return;
                
                const message = state.chatInput;
                setState(prev => ({
                    ...prev,
                    chatMessages: [...prev.chatMessages, { 
                        type: 'user', 
                        text: message, 
                        timestamp: new Date().toLocaleTimeString() 
                    }],
                    chatInput: ''
                }));
                
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            threadId: state.chatThreadId, 
                            message 
                        })
                    });
                    
                    const data = await response.json();
                    if (data.responses) {
                        data.responses.forEach(resp => {
                            setState(prev => ({
                                ...prev,
                                chatMessages: [...prev.chatMessages, { 
                                    type: 'assistant', 
                                    text: resp.text, 
                                    timestamp: resp.timestamp 
                                }]
                            }));
                        });
                    }
                } catch (error) {
                    addLog(`Chat error: ${error.message}`, 'error');
                }
            };

            const startChatSession = async () => {
                const threadId = `chat-${Date.now()}-${Math.random().toString(36).substring(7)}`;
                setState(prev => ({
                    ...prev,
                    chatThreadId: threadId,
                    chatVisible: true,
                    chatMessages: [{
                        type: 'system',
                        text: 'Chat connected to UncleFrank system. You can create tasks by describing what you want.',
                        timestamp: new Date().toLocaleTimeString()
                    }]
                }));
                addLog(`Chat session started: ${threadId}`, 'success');
            };

            const createTaskFromChat = (message) => {
                setState(prev => ({ ...prev, request: message }));
                addLog('Task request populated from chat', 'info');
            };

            // Task Review handlers
            const handleUpdateTaskStatus = (taskId, newStatus) => {
                setState(prev => ({
                    ...prev,
                    reviewTasks: prev.reviewTasks.map(task =>
                        task.id === taskId ? { ...task, status: newStatus } : task
                    )
                }));
                addLog(`Task ${taskId} status updated to ${newStatus}`, 'info');
            };

            const handleViewChanges = (task) => {
                addLog(`Opening diff viewer for ${task.name}`, 'info');
                setSelectedTask(task);
                setDiffViewerOpen(true);
            };

            const handleRunTests = async (task) => {
                addLog(`Running comprehensive tests for ${task.name}`, 'info');
                
                try {
                    // FRANK'S REAL TEST RUNNER - NO TODOS
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            task: task,
                            criteria: task.acceptanceCriteria || task.description,
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (testResponse.ok) {
                        const testData = await testResponse.json();
                        addLog(`Task validation: ${testData.passed ? 'PASSED' : 'FAILED'}`, 
                               testData.passed ? 'success' : 'error');
                        addLog(`Details: ${testData.details}`, 'info');
                        return testData.passed;
                    } else {
                        addLog('Task validation API failed', 'error');
                        return false;
                    }
                } catch (error) {
                    addLog(`Test runner error: ${error.message}`, 'error');
                    return false;
                }
            };

            const handleApprove = async (task) => {
                try {
                    if (task.prUrl) {
                        // PR already exists, just open it
                        addLog(`Opening existing PR for ${task.name}...`, 'info');
                        window.open(task.prUrl, '_blank');
                        return;
                    }
                    
                    addLog(`Creating PR for ${task.name}...`, 'info');
                    
                    // Create PR body with task details
                    const prBody = `## Task: ${task.name}

### Objective
${task.objective}

### Acceptance Criteria
${task.acceptanceCriteria ? task.acceptanceCriteria.map(criteria => `- ${criteria}`).join('\n') : 'No criteria specified'}

### Branch
\`${task.branch}\`

### Terragon Thread
https://www.terragonlabs.com/task/${task.threadId}

---
🤖 This PR was automatically created by Uncle Frank's Task Review System`;

                    // Create the actual PR via GitHub API
                    const pr = await GitHubService.createPullRequest(
                        `Task: ${task.name}`,
                        prBody,
                        task.branch,
                        'master'
                    );
                    
                    if (pr) {
                        addLog(`PR created: ${pr.html_url}`, 'success');
                        
                        // Update task with PR info and status
                        setState(prev => ({
                            ...prev,
                            reviewTasks: prev.reviewTasks.map(t =>
                                t.id === task.id ? { 
                                    ...t, 
                                    status: 'In Review',
                                    prUrl: pr.html_url,
                                    prNumber: pr.number
                                } : t
                            )
                        }));
                        
                        // Open the PR in a new tab
                        window.open(pr.html_url, '_blank');
                    } else {
                        // Fallback: try to open compare view
                        const compareUrl = GitHubService.getCompareUrl('master', task.branch);
                        addLog(`PR creation failed, opening compare view: ${compareUrl}`, 'error');
                        window.open(compareUrl, '_blank');
                        
                        // Update status to In Review anyway
                        handleUpdateTaskStatus(task.id, 'In Review');
                    }
                    
                } catch (error) {
                    addLog(`Failed to create PR: ${error.message}`, 'error');
                    
                    // Fallback: open compare view
                    const compareUrl = GitHubService.getCompareUrl('master', task.branch);
                    addLog(`Opening compare view instead: ${compareUrl}`, 'info');
                    window.open(compareUrl, '_blank');
                }
            };

            const handleRequestChanges = (task) => {
                handleUpdateTaskStatus(task.id, 'Changes Requested');
                addLog(`Changes requested for ${task.name}`, 'info');
            };

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl">
                    <h1 className="text-4xl font-bold mb-2">🔨 Uncle Frank's Bootstrap Core</h1>
                    <p className="text-gray-400 mb-8">No BS Autonomous LLM Development Platform</p>

                    {/* Task Review Queue */}
                    <div className="mb-6">
                        {loadingTasks ? (
                            <div className="bg-gray-800 rounded-lg p-6">
                                <div className="text-center py-8">
                                    <div className="text-blue-400">Loading tasks from GitHub...</div>
                                </div>
                            </div>
                        ) : (
                            <TaskQueue 
                                tasks={state.reviewTasks}
                                onUpdateTaskStatus={handleUpdateTaskStatus}
                                onViewChanges={handleViewChanges}
                                onRunTests={handleRunTests}
                                onApprove={handleApprove}
                                onRequestChanges={handleRequestChanges}
                            />
                        )}
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/* Left Panel - Input */}
                        <div>
                            <div className="bg-gray-800 rounded-lg p-6 mb-6">
                                <h2 className="text-2xl font-semibold mb-4">Create New Task</h2>
                                
                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Request</label>
                                    <textarea 
                                        value={state.request}
                                        onChange={(e) => setState(prev => ({ ...prev, request: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="e.g., Add Discord bot integration"
                                    />
                                </div>

                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Project Context (optional)</label>
                                    <textarea 
                                        value={state.projectContext}
                                        onChange={(e) => setState(prev => ({ ...prev, projectContext: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="Paste your Project.md content here..."
                                    />
                                </div>

                                <div className="flex gap-2">
                                    <button 
                                        onClick={classifyRequest}
                                        disabled={loading}
                                        className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded transition disabled:opacity-50"
                                    >
                                        Classify
                                    </button>
                                    <button 
                                        onClick={decomposeTask}
                                        disabled={loading}
                                        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded transition disabled:opacity-50"
                                    >
                                        Decompose Task
                                    </button>
                                    {state.checkpoints.length > 0 && (
                                        <button 
                                            onClick={executeCheckpointsSequentially}
                                            disabled={executing}
                                            className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition disabled:opacity-50"
                                        >
                                            {executing ? 'Executing...' : 'Execute Sequential'}
                                        </button>
                                    )}
                                </div>
                            </div>

                            {/* Task Summary */}
                            {state.task && (
                                <div className="bg-gray-800 rounded-lg p-6">
                                    <h3 className="text-lg font-semibold mb-2">{state.task.name}</h3>
                                    <p className="text-gray-400 mb-2">{state.task.objective}</p>
                                    <p className="text-sm">{state.task.acceptanceCriteria.length} acceptance criteria</p>
                                    
                                    {/* Task-level Terragon Chat */}
                                    {state.taskThreadId && (
                                        <div className="mt-4 pt-4 border-t border-gray-700">
                                            <div className="flex items-center justify-between mb-2">
                                                <span className="text-sm font-semibold">Terragon Thread</span>
                                                <span className="text-xs text-gray-500">{state.taskThreadId}</span>
                                            </div>
                                            <button 
                                                onClick={() => window.open(`https://www.terragonlabs.com/task/${state.taskThreadId}`, '_blank')}
                                                className="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                                            >
                                                Open in Terragon →
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Right Panel - Checkpoints & Logs */}
                        <div>
                            {/* Checkpoints */}
                            {state.checkpoints.length > 0 && (
                                <div className="bg-gray-800 rounded-lg p-6 mb-6">
                                    <h3 className="text-lg font-semibold mb-4">Checkpoints</h3>
                                    <div className="space-y-3">
                                        {state.checkpoints.map((cp, i) => (
                                            <div key={cp.id} className="p-3 bg-gray-700 rounded">
                                                <div className="flex justify-between items-start mb-2">
                                                    <div>
                                                        <p className="font-semibold">{i + 1}. {cp.name}</p>
                                                        <p className="text-sm text-gray-400">{cp.objective}</p>
                                                    </div>
                                                    <StatusBadge status={state.executionStatus[cp.id]?.status || 'pending'} />
                                                </div>
                                                <div className="text-xs mt-2">
                                                    <span className={`text-${cp.blocking ? 'red' : 'green'}-400`}>
                                                        {cp.blocking ? 'Blocking' : 'Non-blocking'}
                                                    </span>
                                                    <span className="text-gray-500 ml-2">• {cp.passCriteria.length} tests</span>
                                                </div>
                                                {state.executionStatus[cp.id]?.logs?.length > 0 && (
                                                    <div className="mt-2 text-xs">
                                                        {state.executionStatus[cp.id].logs.map((log, idx) => (
                                                            <div key={idx} className="text-gray-300">
                                                                {log.message}
                                                                {log.url && (
                                                                    <a 
                                                                        href={log.url} 
                                                                        target="_blank" 
                                                                        className="text-blue-400 hover:underline ml-2"
                                                                    >
                                                                        Open in Terragon →
                                                                    </a>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Execution Logs */}
                            <div className="bg-gray-800 rounded-lg p-6">
                                <h3 className="text-lg font-semibold mb-4">Execution Logs</h3>
                                <div className="h-64 overflow-y-auto bg-gray-900 rounded p-3 font-mono text-xs">
                                    {state.logs.map((log, i) => (
                                        <div key={i} className={`mb-1 ${
                                            log.level === 'error' ? 'text-red-400' : 
                                            log.level === 'success' ? 'text-green-400' : 
                                            'text-gray-300'
                                        }`}>
                                            <span className="text-gray-500">[{log.timestamp}]</span> {log.message}
                                        </div>
                                    ))}
                                    {state.logs.length === 0 && (
                                        <div className="text-gray-500">No logs yet...</div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Diff Viewer Modal */}
                    <DiffViewer 
                        isOpen={diffViewerOpen}
                        onClose={() => setDiffViewerOpen(false)}
                        task={selectedTask}
                    />
                </div>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>