<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncle Frank's Bootstrap Core</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/diff-match-patch@1.0.5/index.js"></script>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // FRANK'S ORCHESTRATOR INTEGRATION
        let orchestratorEnabled = false;
        
        // Fetch configuration on load
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (response.ok) {
                    const config = await response.json();
                    orchestratorEnabled = config.orchestratorEnabled;
                    if (orchestratorEnabled) {
                        console.log('[Config] 🧠 Task Orchestrator ENABLED');
                        // Can't use addLog here - it's not defined yet
                    } else {
                        console.log('[Config] Task Orchestrator disabled');
                    }
                }
            } catch (error) {
                console.error('[Config] Failed to load configuration:', error);
            }
        }
        
        // Load config immediately
        loadConfig();
        
        async function registerWithOrchestrator(instanceId, metadata) {
            if (!orchestratorEnabled) {
                console.log('[Orchestrator] Not enabled, skipping registration');
                return;
            }
            
            console.log(`[Orchestrator] 🚀 Registering ${metadata.type} instance: ${instanceId}`);
            
            try {
                const response = await fetch('/api/task-orchestrator', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'register',
                        instanceId,
                        metadata
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`[Orchestrator] Registered ${metadata.type} instance: ${instanceId}`);
                    
                    // Check if we're near instance limit
                    if (result.limits && result.limits.currentInstances > result.limits.maxInstances * 0.8) {
                        console.warn(`[Orchestrator] WARNING: Near instance limit (${result.limits.currentInstances}/${result.limits.maxInstances})`);
                        console.warn('⚠️ Orchestrator near instance limit');
                    }
                } else if (response.status === 429) {
                    console.error('[Orchestrator] Rate limited');
                    console.warn('⚠️ Orchestrator rate limit hit - slow down');
                } else if (response.status === 401) {
                    console.error('[Orchestrator] Unauthorized');
                    console.error('❌ Orchestrator authentication failed');
                }
            } catch (error) {
                console.error('[Orchestrator] Registration failed:', error);
            }
        }
        
        // Orchestrator Status Component
        function OrchestratorStatus() {
            const [orchestratorData, setOrchestratorData] = useState(null);
            
            useEffect(() => {
                const pollOrchestrator = async () => {
                    try {
                        const response = await fetch('/api/task-orchestrator', {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ action: 'poll' })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            setOrchestratorData(result);
                            
                            // Log if orchestrator is actively thinking
                            const activeInstances = result.instances?.filter(i => i.status === 'active') || [];
                            if (activeInstances.length > 0) {
                                console.log(`[Orchestrator] 🧠 Monitoring ${activeInstances.length} active instances`);
                            }
                        }
                    } catch (error) {
                        console.error('[Orchestrator] Polling failed:', error);
                    }
                };
                
                // Poll immediately and then every 5 seconds
                pollOrchestrator();
                const interval = setInterval(pollOrchestrator, 5000);
                
                return () => clearInterval(interval);
            }, []);
            
            if (!orchestratorData) return null;
            
            const activeCount = orchestratorData.instances?.filter(i => i.status === 'active').length || 0;
            
            const isThinking = orchestratorData.instances?.some(i => 
                i.status === 'active' && (Date.now() - new Date(i.lastActivity).getTime() < 10000)
            );
            
            return (
                <div className="fixed top-4 right-4 bg-gray-800 border border-gray-700 rounded-lg p-4 w-64 shadow-lg z-50">
                    <h3 className="text-purple-400 font-semibold mb-3 flex items-center">
                        <span className={`text-xl mr-2 ${isThinking ? 'animate-pulse' : ''}`}>🧠</span> 
                        Task Orchestrator
                        {isThinking && <span className="text-xs text-gray-400 ml-2">(thinking...)</span>}
                    </h3>
                    <div className="space-y-2 text-sm">
                        <p className="text-gray-400">
                            Active: <span className="text-white">{activeCount}</span>
                        </p>
                        <p className="text-gray-400">
                            Total: <span className="text-white">{orchestratorData.instanceCount || orchestratorData.instances?.length || 0}</span>
                        </p>
                        
                        {orchestratorData.instances?.length > 0 && (
                            <div className="mt-3 pt-3 border-t border-gray-700">
                                <p className="text-gray-500 text-xs mb-2">Instances:</p>
                                {orchestratorData.limits && (
                                    <div className="mb-2 text-xs">
                                        <div className="w-full bg-gray-700 rounded-full h-2">
                                            <div 
                                                className={`h-2 rounded-full transition-all ${
                                                    orchestratorData.limits.currentInstances / orchestratorData.limits.maxInstances > 0.8 
                                                        ? 'bg-red-500' 
                                                        : orchestratorData.limits.currentInstances / orchestratorData.limits.maxInstances > 0.6 
                                                        ? 'bg-yellow-500' 
                                                        : 'bg-green-500'
                                                }`}
                                                style={{ width: `${(orchestratorData.limits.currentInstances / orchestratorData.limits.maxInstances) * 100}%` }}
                                            />
                                        </div>
                                        <p className="text-gray-500 mt-1">
                                            {orchestratorData.limits.currentInstances}/{orchestratorData.limits.maxInstances} instances
                                        </p>
                                    </div>
                                )}
                                {orchestratorData.instances?.slice(0, 5).map((inst, idx) => {
                                    const emoji = inst.type === 'main-task' ? '📋' : 
                                                 inst.type === 'test' ? '🧪' : 
                                                 inst.type === 'resolver' ? '🔧' : '📦';
                                    const statusColor = inst.status === 'active' ? 'text-green-400' : 
                                                       inst.status === 'completed' ? 'text-blue-400' : 
                                                       inst.status === 'failed' ? 'text-red-400' : 'text-gray-400';
                                    
                                    return (
                                        <div key={idx} className="text-xs ml-2 flex items-center space-x-2">
                                            <span>{emoji}</span>
                                            <span className="text-gray-300">{inst.type}:</span>
                                            <span className={statusColor}>{inst.status}</span>
                                        </div>
                                    );
                                })}
                                {orchestratorData.instances?.length > 5 && (
                                    <p className="text-gray-500 text-xs mt-1 ml-2">+{orchestratorData.instances?.length - 5} more</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }
        
        // FRANK'S DRAFT MANAGER COMPONENT - Enforces the sacred flow
        function DraftManager() {
            const [drafts, setDrafts] = useState([]);
            const [loading, setLoading] = useState(false);
            const [selectedDraft, setSelectedDraft] = useState(null);
            const [draftContent, setDraftContent] = useState('');
            const [validationResults, setValidationResults] = useState(null);
            const [showDraftEditor, setShowDraftEditor] = useState(false);
            
            // Load drafts on mount
            useEffect(() => {
                loadDrafts();
            }, []);
            
            const loadDrafts = async () => {
                try {
                    const response = await fetch('/api/draft-manager', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'list' })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        setDrafts(data.drafts || []);
                    }
                } catch (error) {
                    console.error('Failed to load drafts:', error);
                    console.error('Failed to load drafts');
                }
            };
            
            const createDraft = async () => {
                if (!draftContent.trim()) {
                    addLog('Draft content cannot be empty', 'error');
                    return;
                }
                
                setLoading(true);
                try {
                    const response = await fetch('/api/draft-manager', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'create',
                            content: draftContent,
                            metadata: {
                                author: 'user',
                                source: 'ui'
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        addLog(`Created draft ${data.draft.id}`, 'success');
                        setDraftContent('');
                        setShowDraftEditor(false);
                        await loadDrafts();
                    } else {
                        throw new Error('Failed to create draft');
                    }
                } catch (error) {
                    console.error('Failed to create draft:', error);
                    addLog('Failed to create draft', 'error');
                } finally {
                    setLoading(false);
                }
            };
            
            const validateDraft = async (draft) => {
                setLoading(true);
                addLog(`Starting validation for draft ${draft.id}`, 'info');
                
                try {
                    // Start real validation through Claude
                    const response = await fetch('/api/validation-runner', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'validate',
                            draftId: draft.id,
                            draftContent: draft.content
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        addLog(`Validation task created: ${data.validationThreadId}`, 'success');
                        addLog(`Monitor at: ${data.monitorUrl}`, 'info');
                        
                        // Update draft state
                        await fetch('/api/draft-manager', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'validate',
                                draftId: draft.id
                            })
                        });
                        
                        await loadDrafts();
                        
                        // Poll for validation results
                        setTimeout(() => pollValidationStatus(draft.id, data.validationThreadId), 5000);
                    } else {
                        throw new Error('Failed to start validation');
                    }
                } catch (error) {
                    console.error('Failed to validate draft:', error);
                    addLog('Failed to validate draft', 'error');
                } finally {
                    setLoading(false);
                }
            };
            
            const pollValidationStatus = async (draftId, threadId, attempts = 0) => {
                if (attempts > 60) { // Max 5 minutes
                    addLog('Validation timeout', 'error');
                    return;
                }
                
                try {
                    const response = await fetch('/api/validation-runner', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'check-status',
                            validationThreadId: threadId
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data.completed) {
                            addLog(`Validation completed for draft ${draftId}`, 'success');
                            setValidationResults(data.validationResults);
                            await loadDrafts();
                        } else {
                            // Continue polling
                            setTimeout(() => pollValidationStatus(draftId, threadId, attempts + 1), 5000);
                        }
                    }
                } catch (error) {
                    console.error('Failed to check validation status:', error);
                }
            };
            
            const createTasks = async (draft) => {
                setLoading(true);
                addLog(`Creating tasks from draft ${draft.id}`, 'info');
                
                try {
                    const response = await fetch('/api/draft-manager', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'create-tasks',
                            draftId: draft.id
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        addLog(`Created ${data.taskIds.length} tasks`, 'success');
                        await loadDrafts();
                    } else {
                        throw new Error('Failed to create tasks');
                    }
                } catch (error) {
                    console.error('Failed to create tasks:', error);
                    addLog('Failed to create tasks', 'error');
                } finally {
                    setLoading(false);
                }
            };
            
            const mergeDraft = async (draft) => {
                const approver = prompt('Enter your name for approval:');
                if (!approver) return;
                
                setLoading(true);
                addLog(`Merging draft ${draft.id}`, 'info');
                
                try {
                    const response = await fetch('/api/draft-manager', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'merge',
                            draftId: draft.id,
                            approver: approver
                        })
                    });
                    
                    if (response.ok) {
                        addLog(`Draft merged to Project.md by ${approver}`, 'success');
                        await loadDrafts();
                    } else {
                        throw new Error('Failed to merge draft');
                    }
                } catch (error) {
                    console.error('Failed to merge draft:', error);
                    addLog('Failed to merge draft', 'error');
                } finally {
                    setLoading(false);
                }
            };
            
            const getStateColor = (state) => {
                switch (state) {
                    case 'draft': return 'text-gray-400';
                    case 'validating': return 'text-yellow-400';
                    case 'validated': return 'text-green-400';
                    case 'failed': return 'text-red-400';
                    case 'creating_tasks': return 'text-blue-400';
                    case 'ready_for_merge': return 'text-purple-400';
                    case 'merged': return 'text-green-600';
                    default: return 'text-gray-400';
                }
            };
            
            const getStateEmoji = (state) => {
                switch (state) {
                    case 'draft': return '📝';
                    case 'validating': return '🔍';
                    case 'validated': return '✅';
                    case 'failed': return '❌';
                    case 'creating_tasks': return '🔨';
                    case 'ready_for_merge': return '🎯';
                    case 'merged': return '🏁';
                    default: return '❓';
                }
            };
            
            return (
                <div className="mb-6">
                    <div className="bg-gray-800 rounded-lg p-6">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-2xl font-semibold">📋 Project.md Draft Management</h2>
                            <button 
                                onClick={() => setShowDraftEditor(!showDraftEditor)}
                                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                            >
                                {showDraftEditor ? 'Cancel' : 'New Draft'}
                            </button>
                        </div>
                        
                        {showDraftEditor && (
                            <div className="mb-4 p-4 bg-gray-700 rounded">
                                <h3 className="text-lg font-semibold mb-2">Create New Draft</h3>
                                <textarea 
                                    value={draftContent}
                                    onChange={(e) => setDraftContent(e.target.value)}
                                    className="w-full px-3 py-2 bg-gray-600 rounded border border-gray-500 focus:border-blue-500 focus:outline-none"
                                    rows="10"
                                    placeholder="## Task: [Task Name]&#10;&#10;## Acceptance Criteria:&#10;- [ ] Criterion 1&#10;- [ ] Criterion 2&#10;&#10;## Technical Details:&#10;..."
                                />
                                <div className="mt-2 flex gap-2">
                                    <button 
                                        onClick={createDraft}
                                        disabled={loading || !draftContent.trim()}
                                        className="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded text-sm transition"
                                    >
                                        {loading ? 'Creating...' : 'Create Draft'}
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setShowDraftEditor(false);
                                            setDraftContent('');
                                        }}
                                        className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-sm transition"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Draft List */}
                        <div className="space-y-3">
                            {drafts.length === 0 ? (
                                <p className="text-gray-400 text-center py-8">No drafts yet. Create one to start the sacred flow.</p>
                            ) : (
                                drafts.map(draft => (
                                    <div key={draft.id} className="bg-gray-700 rounded p-4">
                                        <div className="flex justify-between items-start">
                                            <div className="flex-1">
                                                <div className="flex items-center gap-2 mb-2">
                                                    <span className="text-lg">{getStateEmoji(draft.state)}</span>
                                                    <span className={`font-semibold ${getStateColor(draft.state)}`}>
                                                        {draft.state.replace(/_/g, ' ').toUpperCase()}
                                                    </span>
                                                    <span className="text-gray-400 text-sm">
                                                        {draft.id}
                                                    </span>
                                                </div>
                                                
                                                <div className="text-sm text-gray-400 mb-2">
                                                    Created: {new Date(draft.metadata.createdAt).toLocaleString()}
                                                </div>
                                                
                                                {draft.validationResults && (
                                                    <div className="text-sm mb-2">
                                                        <span className={draft.validationResults.passed ? 'text-green-400' : 'text-red-400'}>
                                                            Validation: {draft.validationResults.summary}
                                                        </span>
                                                    </div>
                                                )}
                                                
                                                <details className="cursor-pointer">
                                                    <summary className="text-sm text-blue-400 hover:underline">View Content</summary>
                                                    <pre className="mt-2 p-2 bg-gray-800 rounded text-xs overflow-auto max-h-40">
                                                        {draft.content}
                                                    </pre>
                                                </details>
                                            </div>
                                            
                                            <div className="flex gap-2 ml-4">
                                                {draft.state === 'draft' && (
                                                    <button 
                                                        onClick={() => validateDraft(draft)}
                                                        disabled={loading}
                                                        className="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 rounded text-sm transition"
                                                    >
                                                        Validate
                                                    </button>
                                                )}
                                                
                                                {draft.state === 'validated' && (
                                                    <button 
                                                        onClick={() => createTasks(draft)}
                                                        disabled={loading}
                                                        className="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded text-sm transition"
                                                    >
                                                        Create Tasks
                                                    </button>
                                                )}
                                                
                                                {draft.state === 'ready_for_merge' && (
                                                    <button 
                                                        onClick={() => mergeDraft(draft)}
                                                        disabled={loading}
                                                        className="px-3 py-1 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded text-sm transition"
                                                    >
                                                        Merge to Project.md
                                                    </button>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>
                        
                        {/* Sacred Flow Reference */}
                        <div className="mt-4 p-3 bg-gray-700 rounded text-xs">
                            <p className="text-gray-400">
                                Sacred Flow: Draft → Validation → Task → Checkpoint → Review → Merge
                            </p>
                        </div>
                    </div>
                </div>
            );
        }
        
        // GitHub API Service
        const GitHubService = {
            baseUrl: '/api/github',
            owner: 'bhuman-ai',
            repo: 'unclefrank-bootstrap',

            async makeRequest(endpoint, method = 'GET', body = null) {
                try {
                    console.log('Making GitHub API request:', { endpoint, method });
                    const response = await fetch(this.baseUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method, endpoint, body })
                    });
                    
                    let data;
                    try {
                        data = await response.json();
                    } catch (e) {
                        console.error('Failed to parse response:', e);
                        throw new Error(`Invalid response from GitHub API: ${response.status}`);
                    }
                    
                    if (!response.ok) {
                        console.error('GitHub API error:', response.status, data);
                        throw new Error(data.error || data.message || `GitHub API error: ${response.status}`);
                    }
                    
                    return data;
                } catch (error) {
                    console.error('GitHub API request failed:', error);
                    throw error;
                }
            },

            async getBranches() {
                try {
                    return await this.makeRequest(`/repos/${this.owner}/${this.repo}/branches`);
                } catch (error) {
                    console.error('Failed to fetch branches:', error);
                    return [];
                }
            },

            async getBranchDetails(branchName) {
                try {
                    return await this.makeRequest(`/repos/${this.owner}/${this.repo}/branches/${branchName}`);
                } catch (error) {
                    console.error('Failed to fetch branch details:', error);
                    return null;
                }
            },

            async getCommitDiff(baseBranch = 'master', headBranch) {
                try {
                    return await this.makeRequest(`/repos/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`);
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                    return null;
                }
            },

            async createPullRequest(title, body, headBranch, baseBranch = 'master') {
                try {
                    return await this.makeRequest(
                        `/repos/${this.owner}/${this.repo}/pulls`,
                        'POST',
                        { title, body, head: headBranch, base: baseBranch }
                    );
                } catch (error) {
                    console.error('Failed to create pull request:', error);
                    return null;
                }
            },

            getCompareUrl(baseBranch = 'master', headBranch) {
                return `https://github.com/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`;
            },

            getBranchUrl(branchName) {
                return `https://github.com/${this.owner}/${this.repo}/tree/${branchName}`;
            },

            async createIssue(title, body, labels = ['task', 'claude']) {
                try {
                    return await this.makeRequest(
                        `/repos/${this.owner}/${this.repo}/issues`,
                        'POST',
                        { title, body, labels }
                    );
                } catch (error) {
                    console.error('Failed to create issue:', error);
                    return null;
                }
            },

            async getIssue(issueNumber) {
                try {
                    return await this.makeRequest(`/repos/${this.owner}/${this.repo}/issues/${issueNumber}`);
                } catch (error) {
                    console.error('Failed to fetch issue:', error);
                    return null;
                }
            },

            async updateIssue(issueNumber, updates) {
                try {
                    return await this.makeRequest(
                        `/repos/${this.owner}/${this.repo}/issues/${issueNumber}`,
                        'PATCH',
                        updates
                    );
                } catch (error) {
                    console.error('Failed to update issue:', error);
                    return null;
                }
            },

            getIssueUrl(issueNumber) {
                return `https://github.com/${this.owner}/${this.repo}/issues/${issueNumber}`;
            }
        };

        // Review Actions Component
        const ReviewActions = ({ task, onViewChanges, onRunTests, onApprove, onRequestChanges }) => {
            const [testStatus, setTestStatus] = useState(null);
            const [loading, setLoading] = useState(false);

            const handleRunTests = async () => {
                setLoading(true);
                setTestStatus('running');
                
                try {
                    // FRANK'S REAL TEST EXECUTION - NO SIMULATIONS
                    setTestStatus('running');
                    addLog(`Running real tests for ${task.name}...`, 'info');
                    
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            task: task,
                            criteria: task.acceptanceCriteria || 'Task completion validation',
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (testResponse.ok) {
                        const testData = await testResponse.json();
                        const status = testData.passed ? 'passed' : 'failed';
                        setTestStatus(status);
                        addLog(`Test result: ${status.toUpperCase()} - ${testData.details}`, 
                               status === 'passed' ? 'success' : 'error');
                        if (status === 'passed') onRunTests(task);
                    } else {
                        setTestStatus('failed');
                        addLog('Test execution failed', 'error');
                    }
                } catch (error) {
                    setTestStatus('failed');
                    addLog(`Test error: ${error.message}`, 'error');
                } finally {
                    setLoading(false);
                }
            };

            const getTestStatusColor = () => {
                switch (testStatus) {
                    case 'running': return 'bg-blue-600';
                    case 'passed': return 'bg-green-600';
                    case 'failed': return 'bg-red-600';
                    default: return 'bg-gray-600';
                }
            };

            return (
                <div className="flex gap-1">
                    <button 
                        onClick={() => onViewChanges(task)}
                        className="px-2 py-1 bg-gray-600 hover:bg-gray-700 rounded text-xs transition"
                    >
                        View Changes
                    </button>
                    <button 
                        onClick={handleRunTests}
                        disabled={loading}
                        className={`px-2 py-1 rounded text-xs transition ${getTestStatusColor()} hover:opacity-80 disabled:opacity-50`}
                    >
                        {loading ? 'Running...' : testStatus === 'passed' ? '✓ Tests' : testStatus === 'failed' ? '✗ Tests' : 'Run Tests'}
                    </button>
                    <button 
                        onClick={() => onApprove(task)}
                        className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-xs transition"
                    >
                        {task.prUrl ? 'Open PR' : 'Create PR'}
                    </button>
                    <button 
                        onClick={() => onRequestChanges(task)}
                        className="px-2 py-1 bg-orange-600 hover:bg-orange-700 rounded text-xs transition"
                    >
                        Request Changes
                    </button>
                </div>
            );
        };

        // Diff Viewer Component
        const DiffViewer = ({ isOpen, onClose, task, diffData }) => {
            const [loading, setLoading] = useState(false);
            const [files, setFiles] = useState([]);

            useEffect(() => {
                if (isOpen && task && task.branch) {
                    fetchDiffData();
                }
            }, [isOpen, task]);

            const fetchDiffData = async () => {
                setLoading(true);
                try {
                    const diff = await GitHubService.getCommitDiff('master', task.branch);
                    if (diff && diff.files) {
                        setFiles(diff.files);
                    }
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                } finally {
                    setLoading(false);
                }
            };

            const renderDiffLines = (patch) => {
                if (!patch) return null;
                
                const lines = patch.split('\n');
                return lines.map((line, index) => {
                    let className = 'font-mono text-sm px-4 py-1 ';
                    if (line.startsWith('+')) {
                        className += 'bg-green-900 text-green-200';
                    } else if (line.startsWith('-')) {
                        className += 'bg-red-900 text-red-200';
                    } else if (line.startsWith('@@')) {
                        className += 'bg-blue-900 text-blue-200 font-semibold';
                    } else {
                        className += 'bg-gray-800 text-gray-300';
                    }
                    
                    return (
                        <div key={index} className={className}>
                            {line || ' '}
                        </div>
                    );
                });
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-gray-800 rounded-lg max-w-6xl max-h-[90vh] w-full mx-4 flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h2 className="text-xl font-semibold">
                                Changes for: {task?.name}
                            </h2>
                            <button 
                                onClick={onClose}
                                className="text-gray-400 hover:text-white text-2xl"
                            >
                                ×
                            </button>
                        </div>
                        
                        <div className="flex-1 overflow-auto p-4">
                            {loading ? (
                                <div className="text-center py-8">
                                    <div className="text-blue-400">Loading diff...</div>
                                </div>
                            ) : files.length > 0 ? (
                                <div className="space-y-6">
                                    {files.map((file, index) => (
                                        <div key={index} className="border border-gray-700 rounded">
                                            <div className="bg-gray-700 px-4 py-2 font-mono text-sm">
                                                <span className="text-gray-300">{file.filename}</span>
                                                <span className="ml-4 text-green-400">+{file.additions}</span>
                                                <span className="ml-2 text-red-400">-{file.deletions}</span>
                                            </div>
                                            <div className="max-h-96 overflow-auto">
                                                {renderDiffLines(file.patch)}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="text-center py-8">
                                    <div className="text-gray-500">No changes found</div>
                                    <a 
                                        href={GitHubService.getCompareUrl('master', task?.branch)}
                                        target="_blank"
                                        className="text-blue-400 hover:underline mt-2 inline-block"
                                    >
                                        View on GitHub →
                                    </a>
                                </div>
                            )}
                        </div>
                        
                        <div className="p-4 border-t border-gray-700 flex justify-end gap-2">
                            <button 
                                onClick={onClose}
                                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
                            >
                                Close
                            </button>
                            <a 
                                href={GitHubService.getCompareUrl('master', task?.branch)}
                                target="_blank"
                                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
                            >
                                View on GitHub
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // Kanban Board Component
        const KanbanBoard = ({ tasks, onUpdateTaskStatus, onViewChanges, onRunTests, onApprove, onRequestChanges, onTaskClick }) => {
            const [viewMode, setViewMode] = useState('kanban'); // 'kanban' or 'table'
            
            // Define kanban columns - FRANK'S SACRED FLOW
            const columns = [
                { id: 'pending', title: '🔄 Pending', statuses: ['Created', 'Draft'] },
                { id: 'inprogress', title: '🚀 In Progress', statuses: ['In Progress', 'Executing', 'Processing'] },
                { id: 'review', title: '👀 Awaiting Review', statuses: ['Awaiting Review', 'Ready for Review', 'AI Complete'] },
                { id: 'complete', title: '✅ Human Approved', statuses: ['Approved', 'Merged', 'Human Approved'] }
            ];

            // Group tasks by column
            const tasksByColumn = columns.reduce((acc, column) => {
                acc[column.id] = tasks.filter(task => 
                    column.statuses.includes(task.status) || 
                    (column.id === 'pending' && !task.status)
                );
                return acc;
            }, {});

            const StatusBadge = ({ status }) => {
                const colors = {
                    'Created': 'bg-gray-600',
                    'Processing': 'bg-blue-600',
                    'In Progress': 'bg-blue-600',
                    'Awaiting Review': 'bg-yellow-600',
                    'In Review': 'bg-yellow-600',
                    'Approved': 'bg-green-600',
                    'Changes Requested': 'bg-red-600',
                    'Merged': 'bg-purple-600',
                    'Completed': 'bg-green-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status || 'Pending'}
                    </span>
                );
            };

            const TaskCard = ({ task }) => (
                <div 
                    className="bg-gray-700 rounded p-3 mb-3 hover:bg-gray-650 transition cursor-pointer"
                    onClick={() => onTaskClick && onTaskClick(task)}
                >
                    <div className="flex justify-between items-start mb-2">
                        <h4 className="font-semibold text-sm">{task.name}</h4>
                        <StatusBadge status={task.status} />
                    </div>
                    
                    {task.issueNumber && (
                        <a 
                            href={task.issueUrl}
                            target="_blank"
                            className="text-blue-400 hover:underline text-xs"
                        >
                            Issue #{task.issueNumber}
                        </a>
                    )}
                    
                    {task.branch && (
                        <div className="text-xs text-gray-400 mt-1">
                            Branch: {task.branch}
                        </div>
                    )}
                    
                    {task.threadId && (
                        <div className="text-xs text-gray-400 mt-1">
                            Session: {task.threadId.substring(0, 8)}...
                        </div>
                    )}
                    
                    <div className="mt-3 flex gap-2">
                        {task.status === 'Awaiting Review' && (
                            <button
                                onClick={() => onViewChanges(task)}
                                className="text-xs px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded"
                            >
                                View Changes
                            </button>
                        )}
                        {task.status === 'In Review' && (
                            <>
                                <button
                                    onClick={() => onApprove(task)}
                                    className="text-xs px-2 py-1 bg-green-600 hover:bg-green-700 rounded"
                                >
                                    Approve
                                </button>
                                <button
                                    onClick={() => onRequestChanges(task)}
                                    className="text-xs px-2 py-1 bg-red-600 hover:bg-red-700 rounded"
                                >
                                    Request Changes
                                </button>
                            </>
                        )}
                    </div>
                </div>
            );

            return (
                <div className="bg-gray-800 rounded-lg p-6">
                    <div className="flex justify-between items-center mb-6">
                        <h2 className="text-xl font-semibold">📊 Task Board</h2>
                        <div className="flex gap-2">
                            <button 
                                onClick={() => window.location.reload()}
                                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                            >
                                Refresh from GitHub
                            </button>
                            <button
                                onClick={() => setViewMode(viewMode === 'kanban' ? 'table' : 'kanban')}
                                className="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition"
                            >
                                {viewMode === 'kanban' ? 'Table View' : 'Kanban View'}
                            </button>
                        </div>
                    </div>
                    
                    {viewMode === 'kanban' ? (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                            {columns.map(column => (
                                <div key={column.id} className="bg-gray-900 rounded-lg p-4">
                                    <h3 className="font-semibold mb-3 text-center">
                                        {column.title}
                                        <span className="ml-2 text-sm text-gray-400">
                                            ({tasksByColumn[column.id].length})
                                        </span>
                                    </h3>
                                    <div className="space-y-2">
                                        {tasksByColumn[column.id].length === 0 ? (
                                            <div className="text-center py-8 text-gray-500 text-sm">
                                                No tasks
                                            </div>
                                        ) : (
                                            tasksByColumn[column.id].map(task => (
                                                <TaskCard key={task.id} task={task} />
                                            ))
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    ) : (
                        <div className="overflow-x-auto">
                            <table className="w-full text-sm">
                                <thead>
                                    <tr className="border-b border-gray-700">
                                        <th className="text-left py-2 px-3">Task Name</th>
                                        <th className="text-left py-2 px-3">Status</th>
                                        <th className="text-left py-2 px-3">Links</th>
                                        <th className="text-left py-2 px-3">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {tasks.map(task => (
                                        <tr key={task.id} className="border-b border-gray-700 hover:bg-gray-750">
                                            <td className="py-3 px-3">
                                                <div>
                                                    <div className="font-medium">{task.name}</div>
                                                    <div className="text-xs text-gray-400">{task.objective}</div>
                                                </div>
                                            </td>
                                            <td className="py-3 px-3">
                                                <StatusBadge status={task.status} />
                                            </td>
                                            <td className="py-3 px-3">
                                                <div className="space-y-1">
                                                    {task.branch && (
                                                        <a 
                                                            href={GitHubService.getBranchUrl(task.branch)}
                                                            target="_blank"
                                                            className="text-blue-400 hover:underline text-xs block"
                                                        >
                                                            {task.branch}
                                                        </a>
                                                    )}
                                                    {task.issueUrl && (
                                                        <a 
                                                            href={task.issueUrl}
                                                            target="_blank"
                                                            className="text-blue-400 hover:underline text-xs block"
                                                        >
                                                            Issue #{task.issueNumber} →
                                                        </a>
                                                    )}
                                                    {task.prUrl && (
                                                        <a 
                                                            href={task.prUrl}
                                                            target="_blank"
                                                            className="text-green-400 hover:underline text-xs block"
                                                        >
                                                            View PR →
                                                        </a>
                                                    )}
                                                </div>
                                            </td>
                                            <td className="py-3 px-3">
                                                <ReviewActions 
                                                    task={task}
                                                    onViewChanges={onViewChanges}
                                                    onRunTests={onRunTests}
                                                    onApprove={onApprove}
                                                    onRequestChanges={onRequestChanges}
                                                />
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                            {tasks.length === 0 && (
                                <div className="text-center py-8 text-gray-500">
                                    No tasks found. Create a new task to get started.
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // State management
        const initialState = {
            request: 'Implement Task Review UI that shows completed tasks awaiting human review with GitHub integration. This must include: 1) Task Queue view showing tasks with "Awaiting Review" status after Claude completes them, 2) Display the GitHub branch created by Claude, 3) Show acceptance criteria as a review checklist, 4) Provide View Changes, Run Tests, Approve, and Request Changes buttons, 5) Integration with GitHub API to detect branches and create PRs, 6) Merge Review Screen showing diffs, 7) Update task status from "sent" through "completed", "awaiting review", to "merged"',
            projectContext: `# Current State
The system can execute tasks in Claude, which creates GitHub branches, but there's no UI to review and approve these completed tasks. According to Interface.md, we need screens #3 (Task Queue), #7 (Merge Review), #9 (GitHub Integration), and #15 (Escalation Notifications).

# Requirements from Interface.md
- Task Queue must show task status management
- Merge Review Screen must show Draft vs Production diff viewer  
- GitHub Integration Panel must show repo browser and PR statuses
- System must enforce the immutable flow - no bypassing allowed
- Every action must have immediate feedback

# Technical Context
- Tasks are executed in Claude and push to branches like "claude-session-md-validation-system"
- System uses GitHub API for integration
- React-based UI in public/index.html
- Task state is managed in React component state`,
            task: null,
            checkpoints: [],
            executionStatus: {},
            sessionId: null,
            logs: [],
            activeThreads: {}, // Track thread IDs for each checkpoint
            taskThreadId: null, // One thread per task
            checkpointQueue: [], // Queue of checkpoints to execute
            currentCheckpointIndex: 0, // Current position in queue
            githubConnected: false, // GitHub connection status
            claudeExecutorOnline: false, // Claude executor status
            reviewTasks: [
                {
                    id: 'task-1',
                    name: 'Task Review UI Implementation',
                    objective: 'Build review interface for completed Claude tasks with GitHub integration',
                    status: 'Awaiting Review',
                    branch: 'claude/task-review-ui-github-integration',
                    threadId: 'thread-123',
                    acceptanceCriteria: [
                        'Task Queue component renders without errors',
                        'GitHub API integration works correctly',
                        'Review actions update task status',
                        'PR creation flow functions properly'
                    ]
                },
                {
                    id: 'task-2',
                    name: 'Discord Bot Integration',
                    objective: 'Add Discord bot for task notifications',
                    status: 'In Review',
                    branch: 'claude/discord-bot-integration',
                    threadId: 'thread-456',
                    acceptanceCriteria: [
                        'Bot connects to Discord successfully',
                        'Notifications sent on task completion'
                    ]
                }
            ]
        };

        function App() {
            const [state, setState] = useState(initialState);
            const [loading, setLoading] = useState(false);
            const [loadingTasks, setLoadingTasks] = useState(true);
            const [executing, setExecuting] = useState(false);
            const [diffViewerOpen, setDiffViewerOpen] = useState(false);
            const [selectedTask, setSelectedTask] = useState(null);
            const [sessionViewerOpen, setSessionViewerOpen] = useState(false);
            const [selectedSessionId, setSelectedSessionId] = useState(null);
            const [sessionMessages, setSessionMessages] = useState([]);
            const [loadingSession, setLoadingSession] = useState(false);
            const [taskWorkspaceOpen, setTaskWorkspaceOpen] = useState(false);
            const [workspaceTask, setWorkspaceTask] = useState(null);
            const [taskExecutionLogs, setTaskExecutionLogs] = useState([]);
            const executionInterval = useRef(null);

            const API_URL = '/api/task';
            const EXECUTE_URL = '/api/execute';
            
            // Open Task Workspace View
            const openTaskWorkspace = async (task) => {
                // Just use the task directly - no localStorage!
                const taskWithLatestSession = { ...task };
                
                // Check if the session exists
                if (task.sessionId || task.threadId) {
                    const sessionId = task.sessionId || task.threadId;
                    // Quick check if session exists
                    try {
                        const checkResponse = await fetch(`https://uncle-frank-claude.fly.dev/api/sessions/${sessionId}`);
                        if (!checkResponse.ok) {
                            addLog(`⚠️ Session ${sessionId} no longer exists - task may have been restarted`, 'warning');
                            taskWithLatestSession.sessionExpired = true;
                        } else {
                            addLog(`✅ Session ${sessionId} is active`, 'success');
                            taskWithLatestSession.sessionExpired = false;
                        }
                    } catch (e) {
                        console.log('Could not verify session status');
                    }
                }
                
                setWorkspaceTask(taskWithLatestSession);
                setTaskWorkspaceOpen(true);
                setTaskExecutionLogs([]);
                
                // Load Claude session logs if available
                if (taskWithLatestSession.sessionId || taskWithLatestSession.threadId) {
                    const sessionId = taskWithLatestSession.sessionId || taskWithLatestSession.threadId;
                    setLoadingSession(true);
                    try {
                        const response = await fetch('/api/claude-executor-integration', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'check-status',
                                payload: { threadId: sessionId }
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            setTaskExecutionLogs(data.allMessages || []);
                        }
                    } catch (error) {
                        console.error('Failed to load session logs:', error);
                    } finally {
                        setLoadingSession(false);
                    }
                }
            };

            // Load tasks from GitHub PRs on component mount
            useEffect(() => {
                loadTasksFromGitHub();
                checkGitHubConnection();
                checkClaudeExecutor();
                
                // Set up periodic health check for Claude executor
                const healthCheckInterval = setInterval(() => {
                    checkClaudeExecutor();
                }, 15000); // Check every 15 seconds for faster updates
                
                return () => clearInterval(healthCheckInterval);
            }, []);
            
            // Check GitHub connection status
            const checkGitHubConnection = async () => {
                try {
                    const response = await fetch('/api/github-diagnostics');
                    const data = await response.json();
                    setState(prev => ({
                        ...prev,
                        githubConnected: data.environment.hasToken && data.environment.hasToken === true
                    }));
                } catch (error) {
                    console.error('Failed to check GitHub connection:', error);
                    setState(prev => ({
                        ...prev,
                        githubConnected: false
                    }));
                }
            };
            
            // Check Claude executor status
            const checkClaudeExecutor = async () => {
                try {
                    const response = await fetch('/api/claude-executor-integration', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'health-check' })
                    });
                    const data = await response.json();
                    setState(prev => ({
                        ...prev,
                        claudeExecutorOnline: data.success && (data.status === 'online' || data.status === 'healthy')
                    }));
                    // Don't log warnings on every check - just update the status indicator
                    // if (!data.success) {
                    //     addLog(`⚠️ Claude executor is offline: ${data.error}`, 'warning');
                    // }
                } catch (error) {
                    console.error('Failed to check Claude executor:', error);
                    setState(prev => ({
                        ...prev,
                        claudeExecutorOnline: false
                    }));
                }
            };

            // Load tasks by checking GitHub PR status
            const loadTasksFromGitHub = async () => {
                setLoadingTasks(true);
                addLog('Loading tasks from GitHub...', 'info');
                
                try {
                    // First, load all open issues with 'task' label
                    let issues = [];
                    try {
                        issues = await GitHubService.makeRequest('/repos/bhuman-ai/unclefrank-bootstrap/issues?labels=task&state=all');
                    } catch (error) {
                        console.warn('Failed to load GitHub issues:', error);
                        addLog('Failed to load GitHub issues', 'warning');
                    }
                    
                    const tasksByIssue = new Map();
                    
                    // Process issues first
                    for (const issue of issues || []) {
                        const claudeSessionMatch = issue.body?.match(/Claude Session: ([a-f0-9-]+)/);
                        const claudeSession = claudeSessionMatch ? claudeSessionMatch[1] : null;
                        
                        const task = {
                            id: `issue-${issue.number}`,
                            name: issue.title.replace('Task: ', ''),
                            objective: issue.body?.split('\n')[2] || '', // Extract from body
                            status: issue.state === 'closed' ? 'Completed' : 'In Progress',
                            issueNumber: issue.number,
                            issueUrl: issue.html_url,
                            threadId: claudeSession,
                            created: issue.created_at
                        };
                        
                        tasksByIssue.set(issue.number, task);
                    }
                    
                    // Get list of branches that match claude pattern
                    const branches = await GitHubService.getBranches();
                    const claudeBranches = branches.filter(branch => 
                        branch.name.startsWith('claude/')
                    );
                    
                    const updatedTasks = [];
                    
                    for (const branch of claudeBranches) {
                        try {
                            // Check if PR exists for this branch
                            let prs = [];
                            try {
                                prs = await GitHubService.makeRequest(`/repos/bhuman-ai/unclefrank-bootstrap/pulls?head=bhuman-ai:${branch.name}&state=all`);
                            } catch (error) {
                                console.warn('Failed to fetch PRs for branch:', branch.name);
                            }
                            
                            let status = 'Awaiting Review'; // Default if no PR
                            let prUrl = null;
                            
                            if (prs && prs.length > 0) {
                                const pr = prs[0]; // Get most recent PR for this branch
                                prUrl = pr.html_url;
                                
                                if (pr.state === 'open') {
                                    // Check if changes are requested
                                    let reviews = [];
                                    try {
                                        reviews = await GitHubService.makeRequest(`/repos/bhuman-ai/unclefrank-bootstrap/pulls/${pr.number}/reviews`);
                                    } catch (error) {
                                        console.warn('Failed to fetch PR reviews:', error);
                                    }
                                    const hasRequestedChanges = reviews && reviews.some(review => review.state === 'CHANGES_REQUESTED');
                                    
                                    status = hasRequestedChanges ? 'Changes Requested' : 'In Review';
                                } else if (pr.merged) {
                                    status = 'Merged';
                                } else if (pr.state === 'closed') {
                                    status = 'Approved';
                                }
                            }
                            
                            // Create task object from branch info
                            const taskName = branch.name.replace('claude/', '').replace(/-/g, ' ')
                                .replace(/\b\w/g, l => l.toUpperCase());
                            
                            updatedTasks.push({
                                id: `task-${branch.name}`,
                                name: taskName,
                                objective: `Implementation of ${taskName}`,
                                status: status,
                                branch: branch.name,
                                threadId: `thread-${branch.name}`,
                                prUrl: prUrl,
                                acceptanceCriteria: [
                                    'Implementation completed successfully',
                                    'Tests pass',
                                    'Code review approved'
                                ]
                            });
                            
                        } catch (error) {
                            console.error(`Error checking PR for branch ${branch.name}:`, error);
                        }
                    }
                    
                    // Merge issue tasks with branch tasks
                    const allTasks = Array.from(tasksByIssue.values());
                    
                    // Add branch tasks that don't have corresponding issues
                    for (const branchTask of updatedTasks) {
                        const existingTask = allTasks.find(t => t.threadId === branchTask.threadId);
                        if (!existingTask) {
                            allTasks.push(branchTask);
                        } else {
                            // Update existing task with branch info
                            Object.assign(existingTask, {
                                branch: branchTask.branch,
                                prUrl: branchTask.prUrl,
                                status: branchTask.status // PR status takes precedence
                            });
                        }
                    }
                    
                    // Sort by creation date (newest first)
                    allTasks.sort((a, b) => {
                        const dateA = new Date(a.created || 0);
                        const dateB = new Date(b.created || 0);
                        return dateB - dateA;
                    });
                    
                    // Also load tasks from localStorage
                    const localTasks = JSON.parse(localStorage.getItem('unclefrank-tasks') || '[]');
                    for (const localTask of localTasks) {
                        // Don't add if we already have this task from GitHub
                        if (!allTasks.find(t => t.id === localTask.id)) {
                            allTasks.push({
                                ...localTask,
                                status: localTask.status || 'Created'
                            });
                        }
                    }
                    
                    // Update state with all tasks
                    setState(prev => ({
                        ...prev,
                        reviewTasks: allTasks
                    }));
                    
                    addLog(`Loaded ${allTasks.length} tasks (${tasksByIssue.size} issues, ${updatedTasks.length} branches, ${localTasks.length} local)`, 'success');
                    
                } catch (error) {
                    addLog(`Failed to load tasks from GitHub: ${error.message}`, 'error');
                    // FRANK'S RULE: NO FALLBACKS - FAIL FAST AND HONEST
                    addLog('System requires GitHub integration to function. Fix the connection.', 'error');
                    setTasks([]);
                }
                
                setLoadingTasks(false);
            };

            // Add log entry
            const addLog = (message, level = 'info', sessionId = null) => {
                setState(prev => ({
                    ...prev,
                    logs: [...prev.logs, {
                        timestamp: new Date().toLocaleTimeString(),
                        message,
                        level,
                        sessionId
                    }]
                }));
            };

            // Fetch Claude session messages
            const fetchSessionMessages = async (sessionId, forceRefresh = false) => {
                setLoadingSession(true);
                setSessionMessages([]);
                
                // Add timestamp to force cache bypass
                const timestamp = Date.now();
                
                try {
                    // Try to fetch session details from Fly.io Claude instance with cache-busting
                    const response = await fetch(`https://uncle-frank-claude.fly.dev/api/sessions/${sessionId}?t=${timestamp}`, {
                        method: 'GET',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        // CRITICAL FIX: Fetch messages from the separate /messages endpoint with cache-busting
                        const messagesResponse = await fetch(`https://uncle-frank-claude.fly.dev/api/sessions/${sessionId}/messages?t=${timestamp}`, {
                            method: 'GET',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache'
                            }
                        });
                        
                        if (messagesResponse.ok) {
                            const messagesData = await messagesResponse.json();
                            if (messagesData.messages && messagesData.messages.length > 0) {
                                // Check if the last message shows Claude is still processing
                                const messages = messagesData.messages;
                                const lastMessage = messages[messages.length - 1];
                                
                                // If Claude is still "Germinating" or processing, auto-refresh in a few seconds
                                if (lastMessage.content && 
                                    (lastMessage.content.includes('Germinating...') || 
                                     lastMessage.content.includes('Envisioning...') ||
                                     lastMessage.content.includes('Moseying...') ||
                                     lastMessage.content.includes('Pondering...') ||
                                     lastMessage.content.includes('esc to interrupt'))) {
                                    
                                    addLog('⏳ Claude is still processing...', 'info');
                                    
                                    // Add a note to the message that it's still processing
                                    messages.push({
                                        role: 'system',
                                        content: '🔄 Claude is still thinking. Click Refresh again in a few seconds to check for updates.',
                                        timestamp: new Date().toISOString(),
                                        isProcessing: true
                                    });
                                    
                                    // Auto-refresh after 3 seconds if modal is still open
                                    if (forceRefresh && sessionViewerOpen) {
                                        setTimeout(() => {
                                            if (sessionViewerOpen && selectedSessionId === sessionId) {
                                                addLog('🔄 Auto-refreshing session...', 'info');
                                                fetchSessionMessages(sessionId, true);
                                            }
                                        }, 3000);
                                    }
                                }
                                
                                setSessionMessages(messages);
                                addLog(`Loaded ${messages.length} messages from session ${sessionId}`, 'success');
                            } else {
                                // No messages yet but session exists
                                addLog(`Session ${sessionId} exists but has no messages yet`, 'info');
                                setSessionMessages([{
                                    role: 'system',
                                    content: `Session ID: ${sessionId}\nStatus: ${data.status || 'Active'}\nBranch: ${data.branch || 'Not set'}\nMessage Count: ${data.messageCount || 0}\n\nNo messages loaded. The session may still be initializing.`,
                                    timestamp: new Date().toISOString()
                                }]);
                            }
                        } else {
                            // Couldn't fetch messages, show session info
                            setSessionMessages([{
                                role: 'system',
                                content: `Session ID: ${sessionId}\nStatus: ${data.status || 'Active'}\nBranch: ${data.branch || 'Not set'}\nMessage Count: ${data.messageCount || 0}\n\nCould not load messages from this session.`,
                                timestamp: new Date().toISOString()
                            }]);
                        }
                    } else if (response.status === 404) {
                        addLog(`Session ${sessionId} not found on Claude server`, 'error');
                        setSessionMessages([{
                            role: 'system',
                            content: 'Session not found. It may have expired or been closed.',
                            timestamp: new Date().toISOString()
                        }]);
                    } else {
                        addLog(`Failed to fetch messages for session ${sessionId}`, 'error');
                    }
                } catch (error) {
                    addLog(`Error fetching session messages: ${error.message}`, 'error');
                    // Show error in the message viewer
                    setSessionMessages([{
                        role: 'system',
                        content: `Error loading session: ${error.message}\n\nThe Claude server may be restarting or the session may have expired.`,
                        timestamp: new Date().toISOString()
                    }]);
                } finally {
                    setLoadingSession(false);
                }
            };

            // Fetch terminal output
            const fetchTerminalOutput = async (sessionId) => {
                try {
                    const response = await fetch(`https://uncle-frank-claude.fly.dev/api/sessions/${sessionId}/terminal`);
                    if (response.ok) {
                        const data = await response.json();
                        return data.terminal || 'No output yet...';
                    }
                } catch (error) {
                    console.error('Failed to fetch terminal:', error);
                    return 'Error fetching terminal output';
                }
                return 'No terminal output available';
            };

            // Open session viewer with terminal streaming
            const openSessionViewer = (sessionId) => {
                setSelectedSessionId(sessionId);
                setSessionViewerOpen(true);
                
                // Clear previous messages
                setSessionMessages([]);
                setLoadingSession(true);
                
                // Start fetching terminal output
                const fetchTerminal = async () => {
                    const output = await fetchTerminalOutput(sessionId);
                    setSessionMessages([{
                        role: 'terminal',
                        content: output,
                        timestamp: new Date().toISOString()
                    }]);
                    setLoadingSession(false);
                };
                
                // Initial fetch
                fetchTerminal();
                
                // Poll every 2 seconds while modal is open
                const intervalId = setInterval(() => {
                    if (sessionViewerOpen && selectedSessionId === sessionId) {
                        fetchTerminal();
                    } else {
                        clearInterval(intervalId);
                    }
                }, 2000);
            };

            // Classify request
            const classifyRequest = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('Classifying request...', 'info');
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'classify', request: state.request })
                    });
                    
                    const data = await response.json();
                    if (response.ok) {
                        addLog(`Classification: ${data.classification.type} (${(data.classification.confidence * 100).toFixed(0)}%)`, 'success');
                    } else {
                        addLog(data.error || 'Classification failed', 'error');
                    }
                } catch (error) {
                    addLog(error.message, 'error');
                }
                setLoading(false);
            };

            // FRANK'S SIMPLE TASK CREATION - NO BS, JUST WORKS
            const decomposeTask = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('🚀 Creating task...', 'info');
                
                try {
                    // Step 1: Create GitHub issue to track the task
                    addLog('📝 Creating GitHub issue...', 'info');
                    const issueBody = `## Task
${state.request}

## Status
- Created: ${new Date().toISOString()}
- Claude Session: _pending_

${state.projectContext ? `## Context
${state.projectContext}` : ''}`;

                    let issue = null;
                    let issueNumber = null;
                    try {
                        const response = await fetch('/api/github', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                endpoint: '/repos/bhuman-ai/unclefrank-bootstrap/issues',
                                method: 'POST',
                                body: {
                                    title: `Task: ${state.request.substring(0, 80)}`,
                                    body: issueBody,
                                    labels: ['task']
                                }
                            })
                        });
                        
                        if (response.ok) {
                            issue = await response.json();
                            issueNumber = issue.number;
                            addLog(`✅ Created GitHub issue #${issueNumber}`, 'success');
                        } else {
                            addLog('⚠️ Failed to create GitHub issue', 'warning');
                        }
                    } catch (error) {
                        console.error('GitHub issue creation failed:', error);
                        addLog('⚠️ GitHub issue creation failed', 'warning');
                    }

                    // Step 2: Create Claude session with checkpoint decomposition
                    addLog('🤖 Creating Claude session...', 'info');
                    
                    const taskMessage = `# TASK: ${state.request}

## CRITICAL: Follow Sacred Flow
You MUST decompose this task into checkpoints BEFORE doing ANY work.

### Checkpoint Format Required:
#### Checkpoint 1: [Name]
- Objective: [Clear goal]
- Deliverables: [What to create]
- Pass Criteria: [How to verify]

#### Checkpoint 2: [Name]
- Objective: [Clear goal]
- Deliverables: [What to create]
- Pass Criteria: [How to verify]

[Continue for 3-5 checkpoints total]

### THEN AND ONLY THEN
After decomposing into checkpoints, begin implementing Checkpoint 1.

${state.projectContext ? `## Project Context\n${state.projectContext}` : ''}`;

                    // FRANK'S TWO-PHASE APPROACH
                    // Phase 1: Create session and get checkpoints
                    let sessionId = null;
                    let checkpoints = [];
                    let sessionCreated = false;
                    
                    try {
                        addLog('🤖 Phase 1: Getting checkpoints from Claude...', 'info');
                        const response = await fetch('/api/claude-executor-integration', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'create-task',
                                payload: [{
                                    message: taskMessage,
                                    issueNumber: issueNumber
                                }]
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            sessionId = data.threadId || data.sessionId;
                            checkpoints = data.checkpoints || [];
                            
                            if (sessionId) {
                                sessionCreated = true;
                                addLog(`✅ Claude decomposed task into ${checkpoints.length} checkpoints!`, 'success');
                                addLog(`📍 Session ID: ${sessionId}`, 'info');
                                
                                // Display checkpoints
                                if (checkpoints.length > 0) {
                                    addLog('📋 Checkpoints:', 'info');
                                    checkpoints.forEach(cp => {
                                        addLog(`  ☐ Checkpoint ${cp.id}: ${cp.name}`, 'info');
                                        if (cp.objective) addLog(`     Objective: ${cp.objective}`, 'info');
                                    });
                                }
                            }
                        } else {
                            const errorText = await response.text();
                            console.error('Claude creation failed:', errorText);
                            addLog('⚠️ Claude executor not available', 'warning');
                        }
                    } catch (claudeError) {
                        console.error('Claude error:', claudeError);
                        addLog('⚠️ Could not connect to Claude executor', 'warning');
                        addLog('📝 Task will be tracked in GitHub only', 'info');
                    }
                    
                    // If no Claude session, create a placeholder ID
                    if (!sessionId) {
                        sessionId = `pending-${Date.now()}`;
                        addLog('📝 Task created without Claude session', 'info');
                        addLog('💡 You can restart the task later when Claude is available', 'info');
                    }
                    
                    // Step 3: Update GitHub issue with session ID and checkpoints
                    if (issueNumber) {
                        try {
                            // Update with session ID
                            await fetch('/api/github', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'update-issue-session',
                                    issueNumber: issueNumber,
                                    newSessionId: sessionId
                                })
                            });
                            addLog(`✅ Updated issue #${issueNumber} with session`, 'success');
                            
                            // Update with checkpoints if we have them
                            if (checkpoints.length > 0) {
                                await fetch('/api/github', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        action: 'update-issue-checkpoints',
                                        issueNumber: issueNumber,
                                        checkpoints: checkpoints
                                    })
                                });
                                addLog(`✅ Updated issue #${issueNumber} with ${checkpoints.length} checkpoints`, 'success');
                            }
                        } catch (error) {
                            console.error('Failed to update issue:', error);
                        }
                    }
                    
                    // Step 4: Add task to UI with checkpoints
                    const newTask = {
                        id: issueNumber ? `issue-${issueNumber}` : `session-${sessionId}`,
                        name: state.request.substring(0, 100),
                        objective: state.request,
                        status: checkpoints.length > 0 ? 'Checkpoints Ready' : 'In Progress',
                        threadId: sessionId,
                        sessionId: sessionId,
                        issueNumber: issueNumber,
                        issueUrl: issue?.html_url || null,
                        created: new Date().toISOString(),
                        checkpoints: checkpoints
                    };
                    
                    // Update state
                    setState(prev => ({
                        ...prev,
                        request: '',
                        projectContext: '',
                        reviewTasks: [newTask, ...prev.reviewTasks],
                        checkpoints: checkpoints // Store checkpoints in state for execution
                    }));
                    
                    addLog('✅ Task created successfully!', 'success');
                    
                    // Phase 2: Automatically start execution if we have checkpoints
                    if (sessionCreated && checkpoints.length > 0) {
                        addLog('🚀 Phase 2: Starting checkpoint execution...', 'info');
                        
                        try {
                            const executeResponse = await fetch('/api/claude-executor-integration', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'execute-checkpoints',
                                    payload: {
                                        threadId: sessionId
                                    }
                                })
                            });
                            
                            if (executeResponse.ok) {
                                addLog('✅ Claude is now executing checkpoints!', 'success');
                                addLog('⏳ Monitor progress in the task card above', 'info');
                                
                                // Update task status
                                setState(prev => ({
                                    ...prev,
                                    reviewTasks: prev.reviewTasks.map(t => 
                                        t.sessionId === sessionId 
                                            ? { ...t, status: 'Executing' }
                                            : t
                                    )
                                }));
                            } else {
                                addLog('⚠️ Failed to start execution', 'warning');
                                addLog('💡 You can manually execute checkpoints later', 'info');
                            }
                        } catch (error) {
                            console.error('Execution start error:', error);
                            addLog('⚠️ Could not start execution', 'warning');
                        }
                    } else {
                        addLog('📋 Task is ready. Checkpoints can be executed when Claude is available.', 'info');
                    }
                    
                } catch (error) {
                    console.error('Task creation error:', error);
                    addLog(`❌ Error: ${error.message}`, 'error');
                    
                    // Provide helpful error messages
                    if (error.message.includes('500') || error.message.includes('executor')) {
                        addLog('⚠️ Claude executor is not ready', 'warning');
                        addLog('📝 The Claude tmux session needs to be set up on Fly.io', 'info');
                        addLog('💡 SSH into the Fly.io instance and run: tmux new -s claude-manual', 'info');
                        addLog('💡 Then start Claude in that session', 'info');
                    } else if (error.message.includes('GitHub')) {
                        addLog('⚠️ GitHub API issue - check your token', 'warning');
                    } else if (error.message.includes('JSON')) {
                        addLog('⚠️ Response format error - API may have changed', 'warning');
                    }
                } finally {
                    setLoading(false);
                }
            };

            // Execute checkpoints sequentially
            const executeCheckpointsSequentially = async () => {
                if (!state.checkpoints.length || !state.task) {
                    alert('No checkpoints to execute');
                    return;
                }
                
                setExecuting(true);
                addLog('Starting sequential checkpoint execution with Pass/Fail testing...', 'info');
                
                try {
                    // FRANK'S FIX: Send ONLY the first checkpoint, not context dump
                    const firstCheckpoint = state.checkpoints[0];
                    if (!firstCheckpoint) {
                        throw new Error('No checkpoints found to execute');
                    }
                    
                    const firstCheckpointMessage = `# CHECKPOINT 1: ${firstCheckpoint.name}

## Objective
${firstCheckpoint.objective}

## Task Context
${state.task.name}: ${state.task.objective}

## Blocking Status
${firstCheckpoint.blocking ? '🚫 BLOCKING - Must pass before continuing' : '⚡ NON-BLOCKING - Can fail without halting'}

## Instructions
${firstCheckpoint.instructions.map((inst, j) => `${j + 1}. ${inst}`).join('\n')}

## Pass Criteria (Must verify ALL):
${firstCheckpoint.passCriteria.map((pc, i) => `✓ ${i + 1}. ${pc.description}`).join('\n')}

Execute this checkpoint and report when complete. After completion, I will run tests to verify all pass criteria before proceeding to the next checkpoint.

SACRED FLOW: This is checkpoint 1 of ${state.checkpoints.length}. Each checkpoint will be sent individually after the previous one passes its tests.`;

                    // Create Claude session with FIRST CHECKPOINT ONLY
                    const dashboardPayload = [{
                        message: {
                            type: 'user',
                            model: 'sonnet',
                            parts: [{
                                type: 'rich-text',
                                nodes: [{
                                    type: 'text',
                                    text: firstCheckpointMessage
                                }]
                            }],
                            timestamp: new Date().toISOString()
                        },
                        githubRepoFullName: 'bhuman-ai/unclefrank-bootstrap',
                        repoBaseBranchName: 'master',
                        saveAsDraft: false
                    }];

                    const response = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'create-task',
                            payload: dashboardPayload
                        })
                    });
                    
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `Failed to create Claude task: ${response.status}`);
                    }
                    
                    const threadId = result.threadId;
                    addLog(`✅ Checkpoint 1 sent to Claude session: ${threadId}`, 'success', threadId);
                    addLog(`📍 Session ID: ${threadId}`, 'info', threadId);
                    
                    // Register main task with orchestrator
                    await registerWithOrchestrator(threadId, {
                        type: 'main-task',
                        task: dashboardPayload[0].message.parts[0].nodes[0].text,
                        branch: 'master'
                    });
                    
                    // Start orchestrator monitoring for task decomposition
                    if (orchestratorEnabled) {
                        addLog('🧠 Task Orchestrator is now monitoring this task...', 'info');
                        addLog('📋 Waiting for Task Agent to decompose into checkpoints...', 'info');
                        
                        // Poll orchestrator immediately to trigger decomposition
                        setTimeout(async () => {
                            try {
                                const pollResponse = await fetch('/api/task-orchestrator', {
                                    method: 'POST',
                                    headers: { 
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({ action: 'poll' })
                                });
                                
                                if (pollResponse.ok) {
                                    const pollData = await pollResponse.json();
                                    addLog(`🔄 Orchestrator polling ${pollData.instanceCount} instances`, 'info');
                                }
                            } catch (e) {
                                console.error('Orchestrator poll error:', e);
                            }
                        }, 2000);
                    }
                    
                    // Initialize state - mark checkpoint 1 as executing (since we just sent it)
                    setState(prev => {
                        const firstCheckpoint = prev.checkpoints[0];
                        const newExecutionStatus = {
                            [firstCheckpoint.id]: {
                                status: 'executing',
                                threadId: threadId,
                                startTime: new Date().toISOString(),
                                logs: [{ 
                                    message: `Checkpoint 1 sent to Claude`,
                                    url: threadUrl
                                }]
                            }
                        };
                        
                        const newState = { 
                            ...prev, 
                            sessionId: threadId,
                            taskThreadId: threadId,
                            checkpointQueue: [...prev.checkpoints],
                            currentCheckpointIndex: 0,
                            executionStatus: newExecutionStatus
                        };
                        
                        // FRANK'S REAL FIX: Poll Claude until actual completion
                        setTimeout(() => {
                            addLog('🔍 Polling Claude session for actual completion...', 'info');
                            // CRITICAL: Pass threadId as executionThreadId since we're using the same thread
                            pollClaudeForCompletion(threadId, firstCheckpoint, newState.checkpointQueue, 0, 0, threadId);
                        }, 5000); // Give it 5 seconds to start, then poll
                        
                        return newState;
                    });
                    
                } catch (error) {
                    addLog(`Execution error: ${error.message}`, 'error');
                    setExecuting(false);
                }
            };

            // FRANK'S UI-BASED COMPLETION DETECTION - TRACK UI INDICATORS
            const messageTracker = {}; // Store message state per thread
            
            const pollClaudeForCompletion = async (threadId, checkpoint, queue, currentIndex, pollCount = 0, executionThreadId = null) => {
                const maxPolls = 120; // Max 10 minutes of polling (5 seconds * 120)
                const minPolls = 36; // FRANK'S FIX: Minimum 3 minutes before allowing tests
                const checkpointNumber = currentIndex + 1;
                
                // Initialize tracker for this thread if needed
                if (!messageTracker[threadId]) {
                    messageTracker[threadId] = {
                        lastMessageCount: 0,
                        lastMessageTime: Date.now(),
                        uiQuietCount: 0, // Track polls without UI activity
                        startTime: Date.now() // Track when polling started
                    };
                }
                
                addLog(`🔄 Polling attempt ${pollCount + 1}: Checking if Claude completed checkpoint ${checkpointNumber}`, 'info');
                
                try {
                    // Check Claude session status via our API
                    const statusResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'check-claude-status',
                            threadId: threadId,
                            lastMessageCount: messageTracker[threadId].lastMessageCount,
                            lastMessageTime: messageTracker[threadId].lastMessageTime
                        })
                    });
                    
                    if (statusResponse.ok) {
                        const statusResult = await statusResponse.json();
                        
                        // FRANK'S FIX: Auto-record branch from API response
                        if (statusResult.claudeBranch && !messageTracker[threadId].branchRecorded) {
                            // Record for the task thread ID
                            await fetch('/api/branch-tracker', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'record',
                                    threadId: threadId,
                                    branchName: statusResult.claudeBranch
                                })
                            });
                            
                            // FRANK'S CRITICAL FIX: Also record for execution thread ID
                            // Tests use executionThreadId, not threadId!
                            if (executionThreadId && executionThreadId !== threadId) {
                                await fetch('/api/branch-tracker', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        action: 'record',
                                        threadId: executionThreadId,
                                        branchName: statusResult.claudeBranch
                                    })
                                });
                                console.log(`Also recorded branch for execution thread: ${executionThreadId}`);
                            }
                            
                            messageTracker[threadId].branchRecorded = true;
                            addLog(`🎯 Detected Claude branch: ${statusResult.claudeBranch}`, 'success');
                            
                            // FRANK'S FIX: Save branch to state for tests to use
                            setState(prev => ({
                                ...prev,
                                currentBranch: statusResult.claudeBranch
                            }));
                            
                            // FRANK'S BACKUP: Also save to window for persistence
                            window.lastDetectedBranch = statusResult.claudeBranch;
                        }
                        
                        // Update message tracker
                        if (statusResult.messageCount !== undefined) {
                            if (statusResult.messageCount > messageTracker[threadId].lastMessageCount) {
                                // New messages detected
                                addLog(`📝 New message detected (${statusResult.messageCount} total messages)`, 'info');
                                messageTracker[threadId].lastMessageCount = statusResult.messageCount;
                                messageTracker[threadId].lastMessageTime = statusResult.lastMessageTime;
                                
                                // Try to detect branch from message
                                if (statusResult.lastResponse) {
                                    try {
                                        const branchExtract = await fetch('/api/branch-tracker', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({
                                                action: 'extract',
                                                message: statusResult.lastResponse
                                            })
                                        });
                                        
                                        if (branchExtract.ok) {
                                            const branchData = await branchExtract.json();
                                            if (branchData.branch) {
                                                // Record the branch for this thread
                                                await fetch('/api/branch-tracker', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({
                                                        action: 'record',
                                                        threadId: threadId,
                                                        branchName: branchData.branch
                                                    })
                                                });
                                                addLog(`🔍 Detected branch: ${branchData.branch}`, 'info');
                                            }
                                        }
                                    } catch (e) {
                                        console.error('Branch extraction failed:', e);
                                    }
                                }
                                
                            }
                        }
                        
                        // Status-based updates
                        if (statusResult.status === 'starting') {
                            addLog(`⏳ Claude is starting up...`, 'info');
                        } else if (statusResult.status === 'checkpointing') {
                            addLog(`💾 Claude is creating a checkpoint...`, 'info');
                        }
                        
                        if (statusResult.completed && statusResult.status === 'completed') {
                            // FRANK'S TIMING CHECK: Don't trust completion too early
                            const elapsedTime = Date.now() - messageTracker[threadId].startTime;
                            const elapsedMinutes = Math.floor(elapsedTime / 60000);
                            
                            if (pollCount < minPolls) {
                                addLog(`⚠️ Claude marked complete but only ${elapsedMinutes} minutes elapsed. Minimum 3 minutes required.`, 'warning');
                                addLog(`⏳ Continuing to poll (${pollCount}/${minPolls} minimum attempts)...`, 'info');
                                setTimeout(() => {
                                    pollClaudeForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                                }, 5000);
                                return;
                            }
                            
                            addLog(`✅ Claude marked as completed after ${elapsedMinutes} minutes!`, 'success');
                            
                            // FRANK'S REAL FIX: Wait for API sync before trusting completion
                            addLog(`⏳ Waiting 30s for Claude API to sync full response...`, 'info');
                            await new Promise(resolve => setTimeout(resolve, 30000));
                            
                            // FRANK'S ATOMIC VERIFICATION: Get consistent state snapshot
                            let verificationPassed = false;
                            const maxVerifyAttempts = 3;
                            
                            for (let verifyAttempt = 0; verifyAttempt < maxVerifyAttempts; verifyAttempt++) {
                                const verifyResponse = await fetch('/api/execute', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ 
                                        action: 'check-claude-status',
                                        threadId: threadId
                                    })
                                });
                                
                                if (verifyResponse.ok) {
                                    const snapshot = await verifyResponse.json();
                                    
                                    // Wait 5 seconds and check again for stability
                                    await new Promise(resolve => setTimeout(resolve, 5000));
                                    
                                    const verifyResponse2 = await fetch('/api/execute', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ 
                                            action: 'check-claude-status',
                                            threadId: threadId
                                        })
                                    });
                                    
                                    if (verifyResponse2.ok) {
                                        const snapshot2 = await verifyResponse2.json();
                                        
                                        // FRANK'S ATOMIC CHECK: State must be stable across two snapshots
                                        const stateStable = snapshot.status === snapshot2.status &&
                                                          snapshot.completed === snapshot2.completed &&
                                                          snapshot.messageCount === snapshot2.messageCount;
                                        
                                        const isCompleted = snapshot2.completed && snapshot2.status === 'completed';
                                        
                                        if (stateStable && isCompleted) {
                                            addLog(`✅ Verification attempt ${verifyAttempt + 1}: State stable and completed`, 'success');
                                            verificationPassed = true;
                                            break;
                                        } else {
                                            addLog(`⚠️ Verification attempt ${verifyAttempt + 1} failed:`, 'warning');
                                            addLog(`  - State stable: ${stateStable}`, 'warning');
                                            addLog(`  - Completed: ${isCompleted}`, 'warning');
                                            addLog(`  - Status: ${snapshot2.status}`, 'warning');
                                            addLog(`  - Message count: ${snapshot.messageCount} → ${snapshot2.messageCount}`, 'warning');
                                        }
                                    }
                                }
                                
                                if (verifyAttempt < maxVerifyAttempts - 1) {
                                    addLog(`⏳ Waiting 10s before next verification attempt...`, 'info');
                                    await new Promise(resolve => setTimeout(resolve, 10000));
                                }
                            }
                            
                            if (!verificationPassed) {
                                addLog(`❌ Claude verification failed after ${maxVerifyAttempts} attempts`, 'error');
                                addLog(`Continuing to poll...`, 'info');
                                setTimeout(() => {
                                    pollClaudeForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                                }, 5000);
                                return;
                            }
                            
                            addLog(`✅ Claude completion verified after sync!`, 'success');
                            
                            // Wait for Claude to push changes before testing
                            addLog(`⏳ Waiting for Claude to push changes...`, 'info');
                            
                            // Poll for branch push confirmation (check if branch exists on GitHub)
                            const waitForPush = async (branchName, maxAttempts = 24) => {
                                let rateLimitHits = 0;
                                for (let i = 0; i < maxAttempts; i++) {
                                    try {
                                        // Check if branch exists on GitHub
                                        const checkResponse = await fetch(`https://api.github.com/repos/bhuman-ai/unclefrank-bootstrap/branches/${branchName}`, {
                                            headers: {
                                                'Accept': 'application/vnd.github.v3+json'
                                            }
                                        });
                                        
                                        if (checkResponse.ok) {
                                            // FRANK'S PARANOID CHECK: Verify branch has actual commits
                                            const branchData = await checkResponse.json();
                                            if (branchData.commit && branchData.commit.sha) {
                                                addLog(`✅ Branch ${branchName} pushed to GitHub with commit ${branchData.commit.sha.substring(0, 7)}!`, 'success');
                                                return true;
                                            } else {
                                                addLog(`⚠️ Branch ${branchName} exists but has no commits`, 'warning');
                                            }
                                        } else if (checkResponse.status === 403) {
                                            // GitHub rate limit hit
                                            rateLimitHits++;
                                            const rateLimitRemaining = checkResponse.headers.get('X-RateLimit-Remaining');
                                            const rateLimitReset = checkResponse.headers.get('X-RateLimit-Reset');
                                            addLog(`⚠️ GitHub API rate limit hit. Remaining: ${rateLimitRemaining}`, 'warning');
                                            if (rateLimitReset) {
                                                const resetTime = new Date(parseInt(rateLimitReset) * 1000);
                                                addLog(`⏰ Rate limit resets at: ${resetTime.toLocaleTimeString()}`, 'info');
                                            }
                                            // FRANK'S EXPONENTIAL BACKOFF
                                            const waitTime = Math.min(120000, 5000 * Math.pow(2, rateLimitHits));
                                            addLog(`⏳ Waiting ${waitTime/1000}s due to rate limit (exponential backoff)`, 'info');
                                            await new Promise(resolve => setTimeout(resolve, waitTime));
                                        }
                                    } catch (e) {
                                        console.error('Error checking branch:', e);
                                    }
                                    
                                    if (i < maxAttempts - 1) {
                                        addLog(`⏳ Branch not found yet, checking again in 5 seconds... (${i + 1}/${maxAttempts})`, 'info');
                                        await new Promise(resolve => setTimeout(resolve, 5000));
                                    }
                                }
                                return false;
                            };
                            
                            // Get the branch Claude is working on
                            let targetBranch = 'master';
                            try {
                                const branchResponse = await fetch('/api/branch-tracker', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        action: 'get',
                                        threadId: threadId
                                    })
                                });
                                
                                if (branchResponse.ok) {
                                    const branchData = await branchResponse.json();
                                    if (branchData.branch) {
                                        targetBranch = branchData.branch;
                                        addLog(`🔍 Detected Claude branch: ${targetBranch}`, 'info');
                                    }
                                }
                            } catch (e) {
                                console.error('Branch detection failed:', e);
                            }
                            
                            // Wait for push if not on master
                            if (targetBranch !== 'master') {
                                const pushed = await waitForPush(targetBranch);
                                if (!pushed) {
                                    addLog(`❌ TASK FAILED: Branch ${targetBranch} not pushed to GitHub after 2 minutes`, 'error');
                                    
                                    // FRANK'S STRICT RULE: No branch = No tests!
                                    setState(prev => ({
                                        ...prev,
                                        executionStatus: {
                                            ...prev.executionStatus,
                                            [checkpoint.id]: {
                                                ...prev.executionStatus[checkpoint.id],
                                                status: 'failed',
                                                endTime: new Date().toISOString(),
                                                error: `Branch ${targetBranch} not found on GitHub after push timeout`,
                                                logs: [
                                                    ...prev.executionStatus[checkpoint.id].logs,
                                                    { message: 'FAILED: Branch not pushed to GitHub - cannot test' }
                                                ]
                                            }
                                        }
                                    }));
                                    
                                    setExecuting(false);
                                    return; // NEVER continue without branch!
                                }
                            }
                            
                            // NOW run contextless tests ONLY after push confirmed
                            setTimeout(() => {
                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                            }, 1000);
                            return;
                        } else if (statusResult.completed && statusResult.status === 'error') {
                            addLog(`❌ Claude encountered an error in checkpoint ${checkpointNumber}`, 'error');
                            addLog(`📝 Error details: ${statusResult.message}`, 'error');
                            addLog(`🚫 Checkpoint execution failed - stopping`, 'error');
                            setExecuting(false);
                            return;
                        } else if (statusResult.status === 'error') {
                            addLog(`❌ Claude encountered an error`, 'error');
                            clearInterval(pollInterval);
                            reject(new Error('Claude execution failed'));
                            return;
                        }
                    } else {
                        addLog(`⚠️ Could not check Claude status, assuming still working...`, 'info');
                    }
                    
                    // Continue polling if not complete and under max attempts
                    if (pollCount < maxPolls) {
                        setTimeout(() => {
                            pollClaudeForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                        }, 5000); // Poll every 5 seconds
                    } else {
                        addLog(`🕐 Max polling time reached (10 minutes).`, 'error');
                        addLog(`❌ TASK FAILED: Claude did not complete within 10 minutes.`, 'error');
                        addLog(`📝 Session ID: ${threadId}`, 'info', threadId);
                        
                        // FRANK'S STRICT RULE: Mark checkpoint as failed if no completion signal
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'failed',
                                    endTime: new Date().toISOString(),
                                    error: 'Claude did not complete - timeout after 10 minutes',
                                    logs: [
                                        ...prev.executionStatus[checkpoint.id].logs,
                                        { message: 'FAILED: No completion signal from Claude after max polling time' }
                                    ]
                                }
                            }
                        }));
                        
                        setExecuting(false);
                        // NEVER continue without explicit completion!
                    }
                    
                } catch (error) {
                    addLog(`Polling error: ${error.message}`, 'error');
                    
                    // FRANK'S FIX: Don't give up on fetch errors - Claude might still be working!
                    // Network errors shouldn't trigger premature testing
                    if (pollCount < maxPolls) {
                        addLog(`⚠️ Network error, will retry in 10s (attempt ${pollCount}/${maxPolls})...`, 'warning');
                        setTimeout(() => {
                            pollClaudeForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                        }, 10000);
                    } else {
                        addLog(`🕐 Max polling time reached after network errors (10 minutes total).`, 'error');
                        addLog(`❌ TASK FAILED: Cannot verify Claude completion due to network errors`, 'error');
                        
                        // FRANK'S STRICT RULE: Fail on network errors too
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'failed',
                                    endTime: new Date().toISOString(),
                                    error: 'Network errors prevented Claude status verification',
                                    logs: [
                                        ...prev.executionStatus[checkpoint.id].logs,
                                        { message: 'FAILED: Network errors after max polling attempts' }
                                    ]
                                }
                            }
                        }));
                        
                        setExecuting(false);
                        // NEVER continue without verification!
                    }
                }
            };

            // FRANK'S REAL TEST AND CONTINUE FUNCTION
            const testCheckpointAndContinue = async (checkpoint, queue, currentIndex, executionThreadId) => {
                const checkpointNumber = currentIndex + 1;
                addLog(`🧪 Testing checkpoint ${checkpointNumber}: ${checkpoint.name}`, 'info');
                
                try {
                    addLog(`🎯 Running contextless tests for checkpoint ${checkpointNumber}`, 'info');
                    
                    // FRANK'S DIRECT APPROACH: Pass the branch we detected during polling
                    if (window.lastDetectedBranch) {
                        checkpoint._detectedBranch = window.lastDetectedBranch;
                        addLog(`📌 Passing detected branch to tests: ${window.lastDetectedBranch}`, 'info');
                    }
                    
                    // Pass the execution thread ID so we test the right branch
                    const testResult = await testCheckpoint(checkpoint, executionThreadId);
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        if (currentIndex + 1 < queue.length) {
                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                        } else {
                            addLog('🎉 All checkpoints completed!', 'success');
                            await validateTaskCompletion();
                            setExecuting(false);
                        }
                        
                    } else {
                        addLog(`❌ Checkpoint ${checkpointNumber} FAILED tests!`, 'error');
                        
                        // FRANK'S SMART LOGIC: Check if failures are retryable
                        const hasRetryableFailures = testResult.failedTests.some(test => 
                            test.details.includes('timeout') || 
                            test.details.includes('network') ||
                            test.details.includes('connection')
                        );
                        
                        const currentRetryCount = checkpoint._retryCount || 0;
                        
                        // Only retry for transient failures (network, timeouts)
                        if (hasRetryableFailures && currentRetryCount < 3) {
                            addLog(`🔄 TEST-RUNNER: Retrying due to possible transient failure (attempt ${currentRetryCount + 1}/3)...`, 'warning');
                            checkpoint._retryCount = currentRetryCount + 1;
                            
                            // Wait before retry
                            setTimeout(() => {
                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                            }, 5000);
                            return;
                        }
                        
                        // FRANK'S ORCHESTRATOR INTEGRATION - Let the brain decide
                        addLog(`🧠 Notifying Task Orchestrator of test failures...`, 'info');
                        
                        // Register test results with orchestrator
                        await registerWithOrchestrator(`test-${checkpoint.id}-${Date.now()}`, {
                            type: 'test-result',
                            parentId: executionThreadId,
                            checkpoint: checkpoint,
                            branch: state.currentBranch || window.lastDetectedBranch || 'master',
                            testResult: testResult,
                            retryCount: currentRetryCount,
                            hasRetryableFailures: hasRetryableFailures
                        });
                        
                        // Force orchestrator decision
                        addLog(`🤔 Asking Orchestrator for decision...`, 'info');
                        
                        try {
                            const orchestratorResponse = await fetch('/api/task-orchestrator', {
                                method: 'POST',
                                headers: { 
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    action: 'decide',
                                    instanceId: executionThreadId
                                })
                            });
                            
                            if (orchestratorResponse.ok) {
                                const decision = await orchestratorResponse.json();
                                const lastDecision = decision.lastDecision;
                                
                                if (lastDecision) {
                                    addLog(`🤖 Orchestrator decision: ${lastDecision.action} - ${lastDecision.reasoning}`, 'info');
                                    
                                    // Update UI based on decision
                                    switch (lastDecision.action) {
                                        case 'escalate':
                                            addLog('🚨 HUMAN ESCALATION REQUIRED', 'error');
                                            addLog('📋 Failed tests:', 'error');
                                            testResult.failedTests.forEach(test => {
                                                addLog(`  - ${test.description}: ${test.details}`, 'error');
                                            });
                                            
                                            setState(prev => ({
                                                ...prev,
                                                executionStatus: {
                                                    ...prev.executionStatus,
                                                    [checkpoint.id]: {
                                                        ...prev.executionStatus[checkpoint.id],
                                                        status: 'escalated',
                                                        escalationReason: lastDecision.reasoning,
                                                        failedTime: new Date().toISOString()
                                                    }
                                                }
                                            }));
                                            
                                            if (checkpoint.blocking) {
                                                addLog('🚫 Blocking checkpoint - execution stopped', 'error');
                                                setExecuting(false);
                                            } else {
                                                addLog('⚡ Non-blocking - continuing despite escalation', 'info');
                                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                            }
                                            break;
                                            
                                        case 'send_message':
                                        case 'create_instance':
                                            addLog(`🔧 Orchestrator is working on fixes...`, 'info');
                                            
                                            setState(prev => ({
                                                ...prev,
                                                executionStatus: {
                                                    ...prev.executionStatus,
                                                    [checkpoint.id]: {
                                                        ...prev.executionStatus[checkpoint.id],
                                                        status: 'resolving',
                                                        orchestratorActive: true
                                                    }
                                                }
                                            }));
                                            
                                            // Wait for orchestrator to work
                                            addLog(`⏳ Waiting 60 seconds for orchestrator actions...`, 'info');
                                            setTimeout(() => {
                                                checkpoint._retryCount = 0; // Reset for re-test
                                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                                            }, 60000);
                                            break;
                                            
                                        case 'wait':
                                            addLog(`⏳ Orchestrator waiting for more data...`, 'info');
                                            setTimeout(() => {
                                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                                            }, 10000);
                                            break;
                                            
                                        case 'decompose_task':
                                            addLog(`📋 Task Orchestrator is decomposing task into checkpoints...`, 'info');
                                            addLog(`🧠 Task Agent is analyzing requirements and creating execution plan...`, 'info');
                                            
                                            // Continue polling to see decomposition results
                                            setTimeout(() => {
                                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                                            }, 10000);
                                            break;
                                            
                                        case 'mark_complete':
                                            addLog(`✅ Orchestrator marked task as complete`, 'success');
                                            
                                            // Continue to next checkpoint
                                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                            break;
                                            
                                        default:
                                            addLog(`🤷 Unknown orchestrator action: ${lastDecision.action}`, 'warning');
                                            if (checkpoint.blocking) {
                                                setExecuting(false);
                                            } else {
                                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                            }
                                    }
                                } else {
                                    addLog(`⚠️ No decision from orchestrator`, 'warning');
                                    // Fallback to basic behavior
                                    if (checkpoint.blocking) {
                                        addLog('🚫 Blocking checkpoint failed - execution stopped', 'error');
                                        setExecuting(false);
                                    } else {
                                        addLog('⚡ Non-blocking checkpoint failed - continuing', 'info');
                                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                    }
                                }
                            }
                        } catch (error) {
                            addLog(`❌ Orchestrator error: ${error.message}`, 'error');
                            // Fallback to stopping on blocking checkpoints
                            if (checkpoint.blocking) {
                                addLog('🚫 Blocking checkpoint failed - execution stopped', 'error');
                                setExecuting(false);
                            } else {
                                addLog('⚡ Non-blocking checkpoint failed - continuing', 'info');
                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                            }
                        }
                    }
                } catch (error) {
                    addLog(`Test error: ${error.message}`, 'error');
                    setExecuting(false);
                }
            };

            // Execute next checkpoint with explicit parameters (avoids stale closure)
            const executeNextCheckpointWithQueue = async (queue, currentIndex, threadId) => {
                console.log('executeNextCheckpointWithQueue called with:', {
                    queueLength: queue?.length || 0,
                    currentIndex,
                    threadId
                });
                
                addLog(`Checking execution: index=${currentIndex}, queue length=${queue?.length || 0}`, 'info');
                
                if (!queue || queue.length === 0) {
                    addLog('ERROR: No checkpoints found in queue!', 'error');
                    setExecuting(false);
                    return;
                }
                
                if (currentIndex >= queue.length) {
                    addLog('All checkpoints completed, running final validation...', 'info');
                    await validateTaskCompletion();
                    setExecuting(false);
                    return;
                }
                
                const checkpoint = queue[currentIndex];
                const checkpointNumber = currentIndex + 1;
                addLog(`=== Starting Checkpoint ${checkpointNumber}/${queue.length}: ${checkpoint.name} ===`, 'info');
                
                // Update current checkpoint index in state
                setState(prev => ({
                    ...prev,
                    currentCheckpointIndex: currentIndex
                }));
                
                // Continue with checkpoint execution...
                await executeCheckpointWithParams(checkpoint, queue, currentIndex, threadId);
            };

            // Execute individual checkpoint with explicit parameters
            const executeCheckpointWithParams = async (checkpoint, queue, currentIndex, threadId) => {
                const checkpointNumber = currentIndex + 1;
                
                // Validate dependencies before execution
                const dependenciesValid = await validateDependencies(checkpoint);
                if (!dependenciesValid) {
                    addLog(`Dependencies not met for ${checkpoint.name}, waiting...`, 'error');
                    setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex, threadId), 2000);
                    return;
                }
                
                // Get current retry count
                const currentStatus = state.executionStatus[checkpoint.id];
                const retryCount = currentStatus?.retryCount || 0;
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { 
                            status: 'in_progress', 
                            logs: [], 
                            retryCount: retryCount,
                            startTime: new Date().toISOString()
                        }
                    }
                }));
                
                try {
                    // Send checkpoint to Claude via API proxy
                    const execResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: threadId
                        })
                    });
                    
                    if (!execResponse.ok) {
                        const errorData = await execResponse.json();
                        throw new Error(errorData.error || 'Failed to execute checkpoint');
                    }
                    
                    const execData = await execResponse.json();
                    
                    // FRANK'S CRITICAL FIX: execData.threadId is the EXECUTION thread, not task thread!
                    const executionThreadId = execData.threadId || threadId;
                    addLog(`Checkpoint sent to execution thread: ${executionThreadId}`, 'info');
                    
                    // Register checkpoint execution with orchestrator
                    await registerWithOrchestrator(executionThreadId, {
                        type: 'checkpoint-execution',
                        parentId: state.taskThreadId || threadId,
                        checkpoint: checkpoint,
                        branch: state.currentBranch || window.lastDetectedBranch || 'master'
                    });
                    
                    // Update status to executing with EXECUTION thread ID
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                ...prev.executionStatus[checkpoint.id],
                                status: 'executing',
                                threadId: executionThreadId,  // Store execution thread ID
                                executionThreadId: executionThreadId,  // Also store explicitly
                                taskThreadId: threadId,  // Keep task thread ID too
                                logs: [{ 
                                    message: `Executing in thread: ${executionThreadId}`,
                                    message: `Session: ${executionThreadId}`
                                }]
                            }
                        }
                    }));
                    
                    addLog(`✅ Checkpoint ${checkpointNumber} sent to Claude execution thread: ${executionThreadId}`, 'success', executionThreadId);
                    addLog(`📍 Session: ${executionThreadId}`, 'info', executionThreadId);
                    
                    // FRANK'S REAL POLLING - Pass both thread IDs
                    addLog(`🔍 Waiting for Claude to complete checkpoint ${checkpointNumber}...`, 'info');
                    setTimeout(() => {
                        pollClaudeForCompletion(threadId, checkpoint, queue, currentIndex, 0, executionThreadId);
                    }, 2000); // Small delay before polling starts
                    
                    return; // Exit here - polling will handle the rest
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                        
                    } else {
                        // Handle failure with retry logic
                        const newRetryCount = retryCount + 1;
                        
                        if (newRetryCount < 3) {
                            addLog(`❌ Test-Runner: Checkpoint ${checkpointNumber} FAILED - Retry ${newRetryCount}/3`, 'error');
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'retrying',
                                        retryCount: newRetryCount,
                                        testResults: testResult
                                    }
                                }
                            }));
                            
                            // Retry same checkpoint
                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex, threadId), 3000);
                        } else {
                            // Test-Runner exhausted - invoke Task-LLM-Resolver
                            addLog(`⚠️ Test-Runner exhausted 3 attempts. Escalating to Task-LLM-Resolver...`, 'warning');
                            
                            // FRANK'S FIX: Handle async Task-LLM-Resolver properly
                            try {
                                const resolverResult = await taskLLMResolver(checkpoint, testResult, executionThreadId || threadId);
                            
                            if (resolverResult.success) {
                                // Task-LLM-Resolver fixed it!
                                setState(prev => ({
                                    ...prev,
                                    executionStatus: {
                                        ...prev.executionStatus,
                                        [checkpoint.id]: {
                                            ...prev.executionStatus[checkpoint.id],
                                            status: 'pass',
                                            testResults: resolverResult.testResult,
                                            resolvedByLLM: true,
                                            completedTime: new Date().toISOString()
                                        }
                                    }
                                }));
                                
                                addLog(`🎉 Task-LLM-Resolver fixed the issues! Continuing...`, 'success');
                                
                                // Continue to next checkpoint
                                if (currentIndex + 1 < queue.length) {
                                    setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                } else {
                                    addLog('🎉 All checkpoints completed!', 'success');
                                    await validateTaskCompletion();
                                    setExecuting(false);
                                }
                            } else if (resolverResult.escalate) {
                                // Task-LLM-Resolver exhausted - need human help
                                addLog(`🚨 HUMAN ESCALATION REQUIRED for checkpoint ${checkpointNumber}`, 'error');
                                addLog(`📋 Summary: After 3 Test-Runner attempts and 5 Task-LLM-Resolver attempts, the following issues persist:`, 'error');
                                testResult.failedTests.forEach(failure => {
                                    addLog(`  - ${failure.description}: ${failure.details}`, 'error');
                                });
                                addLog(`🛑 Execution halted. Human intervention required.`, 'error');
                                
                                setState(prev => ({
                                    ...prev,
                                    executionStatus: {
                                        ...prev.executionStatus,
                                        [checkpoint.id]: {
                                            ...prev.executionStatus[checkpoint.id],
                                            status: 'human_escalation',
                                            requiresHumanIntervention: true,
                                            escalationReason: 'Test-Runner and Task-LLM-Resolver exhausted',
                                            failedTime: new Date().toISOString()
                                        }
                                    }
                                }));
                                
                                setExecuting(false);
                            } else {
                                addLog(`🛑 Checkpoint ${checkpointNumber} FAILED after all attempts!`, 'error');
                                handleFailedCheckpoint();
                            }
                        } catch (resolverError) {
                            // FRANK'S FIX: Handle Task-LLM-Resolver crashes
                            addLog(`🚨 Task-LLM-Resolver crashed: ${resolverError.message}`, 'error');
                            handleFailedCheckpoint();
                        }
                        
                        // Helper function to handle failed checkpoints
                        function handleFailedCheckpoint() {
                            if (checkpoint.blocking) {
                                addLog(`🚫 This is a BLOCKING checkpoint - execution halted`, 'error');
                            }
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'fail',
                                        testResults: testResult,
                                        failedTime: new Date().toISOString()
                                    }
                                }
                            }));
                            
                            // If blocking checkpoint failed, stop execution
                            if (checkpoint.blocking) {
                                setExecuting(false);
                                addLog('Execution stopped due to blocking checkpoint failure', 'error');
                            } else {
                                // Non-blocking can continue
                                addLog('Non-blocking checkpoint failed, continuing...', 'info');
                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                            }
                        }
                        }
                    }
                    
                } catch (error) {
                    addLog(`Checkpoint execution error: ${error.message}`, 'error');
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }],
                                error: error.message
                            }
                        }
                    }));
                    
                    if (checkpoint.blocking) {
                        setExecuting(false);
                        addLog('Execution stopped due to error in blocking checkpoint', 'error');
                    } else {
                        // Try next checkpoint for non-blocking
                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                    }
                }
            };

            // Execute next checkpoint in queue (legacy - uses state)
            const executeNextCheckpoint = async () => {
                console.log('executeNextCheckpoint called');
                console.log('Current state:', {
                    currentCheckpointIndex: state.currentCheckpointIndex,
                    checkpointQueue: state.checkpointQueue?.length,
                    checkpoints: state.checkpoints?.length
                });
                
                const currentIndex = state.currentCheckpointIndex || 0;
                const queue = state.checkpointQueue || state.checkpoints;
                
                addLog(`Checking execution: index=${currentIndex}, queue length=${queue?.length || 0}`, 'info');
                
                if (!queue || queue.length === 0) {
                    addLog('ERROR: No checkpoints found in queue!', 'error');
                    setExecuting(false);
                    return;
                }
                
                if (currentIndex >= queue.length) {
                    addLog('All checkpoints completed, running final validation...', 'info');
                    await validateTaskCompletion();
                    setExecuting(false);
                    return;
                }
                
                const checkpoint = queue[currentIndex];
                const checkpointNumber = currentIndex + 1;
                addLog(`=== Starting Checkpoint ${checkpointNumber}/${queue.length}: ${checkpoint.name} ===`, 'info');
                
                // Validate dependencies before execution
                const dependenciesValid = await validateDependencies(checkpoint);
                if (!dependenciesValid) {
                    addLog(`Dependencies not met for ${checkpoint.name}, waiting...`, 'error');
                    setTimeout(() => executeNextCheckpoint(), 2000);
                    return;
                }
                
                // Get current retry count
                const currentStatus = state.executionStatus[checkpoint.id];
                const retryCount = currentStatus?.retryCount || 0;
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { 
                            status: 'in_progress', 
                            logs: [], 
                            retryCount: retryCount,
                            startTime: new Date().toISOString()
                        }
                    }
                }));
                
                try {
                    // Send checkpoint execution message to existing Claude session
                    const checkpointMessage = `# CHECKPOINT ${checkpointNumber}: ${checkpoint.name}

## Objective
${checkpoint.objective}

## Blocking Status
${checkpoint.blocking ? '🚫 BLOCKING - Must pass before continuing' : '⚡ NON-BLOCKING - Can fail without halting'}

## Instructions
${checkpoint.instructions.map((inst, j) => `${j + 1}. ${inst}`).join('\n')}

## Pass Criteria (Must verify ALL):
${checkpoint.passCriteria.map((pc, i) => `✓ ${i + 1}. ${pc.description}`).join('\n')}

Please execute this checkpoint and report when complete. I will then run tests to verify all pass criteria.`;

                    // Send checkpoint to Claude via API proxy
                    const execResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: state.taskThreadId
                        })
                    });
                    
                    if (!execResponse.ok) {
                        const errorData = await execResponse.json();
                        throw new Error(errorData.error || 'Failed to execute checkpoint');
                    }
                    
                    const execData = await execResponse.json();
                    addLog(`Checkpoint sent to thread: ${execData.threadId}`, 'info');
                    
                    // Update status to executing
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                ...prev.executionStatus[checkpoint.id],
                                status: 'executing',
                                threadId: state.taskThreadId,
                                logs: [{ 
                                    message: `Executing in thread: ${state.taskThreadId}`,
                                    message: `Session: ${state.taskThreadId}`
                                }]
                            }
                        }
                    }));
                    
                    addLog(`Checkpoint sent to Claude, waiting for execution...`, 'info');
                    
                    // Wait for Claude to execute (in real implementation, would poll for completion)
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
                    // Run pass/fail tests
                    addLog(`Running Pass/Fail tests for ${checkpoint.name}...`, 'info');
                    const testResult = await testCheckpoint(checkpoint);
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            currentCheckpointIndex: currentIndex + 1,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        setTimeout(() => executeNextCheckpoint(), 2000);
                        
                    } else {
                        // Handle failure with retry logic
                        const newRetryCount = retryCount + 1;
                        
                        if (newRetryCount < 3) {
                            addLog(`❌ Checkpoint ${checkpointNumber} FAILED - Retry ${newRetryCount}/3`, 'error');
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'retrying',
                                        retryCount: newRetryCount,
                                        testResults: testResult
                                    }
                                }
                            }));
                            
                            // Retry same checkpoint
                            setTimeout(() => executeNextCheckpoint(), 3000);
                        } else {
                            addLog(`🛑 Checkpoint ${checkpointNumber} FAILED after 3 attempts!`, 'error');
                            if (checkpoint.blocking) {
                                addLog(`🚫 This is a BLOCKING checkpoint - execution halted`, 'error');
                            }
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'fail',
                                        testResults: testResult,
                                        failedTime: new Date().toISOString()
                                    }
                                }
                            }));
                            
                            // If blocking checkpoint failed, stop execution
                            if (checkpoint.blocking) {
                                setExecuting(false);
                                addLog('Execution stopped due to blocking checkpoint failure', 'error');
                            } else {
                                // Non-blocking can continue
                                addLog('Non-blocking checkpoint failed, continuing...', 'info');
                                setState(prev => ({
                                    ...prev,
                                    currentCheckpointIndex: currentIndex + 1
                                }));
                                setTimeout(() => executeNextCheckpoint(), 2000);
                            }
                        }
                    }
                    
                } catch (error) {
                    addLog(`Checkpoint execution error: ${error.message}`, 'error');
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }],
                                error: error.message
                            }
                        }
                    }));
                    
                    if (checkpoint.blocking) {
                        setExecuting(false);
                        addLog('Execution stopped due to error in blocking checkpoint', 'error');
                    } else {
                        // Try next checkpoint for non-blocking
                        setState(prev => ({
                            ...prev,
                            currentCheckpointIndex: currentIndex + 1
                        }));
                        setTimeout(() => executeNextCheckpoint(), 2000);
                    }
                }
            };

            // FRANK'S TASK-LLM-RESOLVER - ANALYZES AND FIXES TEST FAILURES
            const taskLLMResolver = async (checkpoint, testResult, mainThreadId, attemptNumber = 1) => {
                const MAX_ATTEMPTS = 5;
                
                if (attemptNumber > MAX_ATTEMPTS) {
                    addLog(`❌ Task-LLM-Resolver exhausted all ${MAX_ATTEMPTS} attempts`, 'error');
                    return { success: false, escalate: true };
                }
                
                addLog(`🔧 Task-LLM-Resolver activated (Attempt ${attemptNumber}/${MAX_ATTEMPTS})`, 'warning');
                addLog(`📊 Analyzing test failures for checkpoint: ${checkpoint.name}`, 'info');
                addLog(`📍 Sending fixes to Claude session: ${mainThreadId}`, 'info');
                
                // Analyze failure patterns
                const failureAnalysis = {
                    failedTests: testResult.failedTests || [],
                    patterns: [],
                    proposedFixes: []
                };
                
                // Pattern matching for common failures
                for (const failure of failureAnalysis.failedTests) {
                    const description = failure.description.toLowerCase();
                    const details = (failure.details || '').toLowerCase();
                    
                    if (details.includes('no such file') || details.includes('file not found') || details.includes('does not exist')) {
                        failureAnalysis.patterns.push('MISSING_FILE');
                        failureAnalysis.proposedFixes.push({
                            type: 'CREATE_FILE',
                            description: `Create missing file for: ${failure.description}`
                        });
                    } else if (details.includes('no mongodb') || details.includes('connection') || details.includes('mongodb')) {
                        failureAnalysis.patterns.push('MISSING_DEPENDENCY');
                        failureAnalysis.proposedFixes.push({
                            type: 'MOCK_DEPENDENCY',
                            description: `Mock or skip MongoDB test: ${failure.description}`
                        });
                    } else if (details.includes('branch') || details.includes('checkout')) {
                        failureAnalysis.patterns.push('BRANCH_ISSUE');
                        failureAnalysis.proposedFixes.push({
                            type: 'CHECKOUT_BRANCH',
                            description: `Ensure correct branch for: ${failure.description}`
                        });
                    } else if (details.includes('expected') && details.includes('found')) {
                        failureAnalysis.patterns.push('WRONG_CONTENT');
                        failureAnalysis.proposedFixes.push({
                            type: 'UPDATE_CONTENT',
                            description: `Fix content mismatch for: ${failure.description}`
                        });
                    } else {
                        failureAnalysis.patterns.push('UNKNOWN');
                        failureAnalysis.proposedFixes.push({
                            type: 'INVESTIGATE',
                            description: `Investigate failure: ${failure.description}`
                        });
                    }
                }
                
                addLog(`🔍 Identified patterns: ${failureAnalysis.patterns.join(', ')}`, 'info');
                addLog(`💡 Proposed fixes: ${failureAnalysis.proposedFixes.length}`, 'info');
                
                // Send fix message to Claude
                try {
                    const fixResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'send-message',
                            threadId: mainThreadId,
                            message: buildResolverMessage(failureAnalysis, attemptNumber)
                        })
                    });
                    
                    if (fixResponse.ok) {
                        addLog(`✅ Fix instructions sent to Claude session`, 'success');
                        
                        // Wait for Claude to implement fixes
                        addLog(`⏳ Waiting 60 seconds for Claude to implement fixes...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, 60000));
                        
                        // Continue with success - tests will re-run
                        return { success: true };
                    } else {
                        addLog(`❌ Failed to send fix instructions to Claude`, 'error');
                        return { success: false, escalate: attemptNumber >= MAX_ATTEMPTS };
                    }
                } catch (error) {
                    addLog(`❌ Task-LLM-Resolver error: ${error.message}`, 'error');
                    return { success: false, escalate: attemptNumber >= MAX_ATTEMPTS };
                }
            };
            
            // Helper to build resolver message
            const buildResolverMessage = (failureAnalysis, attemptNumber) => {
                // Build fix message for Claude
                const fixMessage = `# TASK-LLM-RESOLVER FIX ATTEMPT ${attemptNumber}

## Test Failures Analysis
${failureAnalysis.failedTests.map(f => `- **${f.description}**: ${f.details}`).join('\n')}

## Root Cause Analysis
Patterns identified: ${failureAnalysis.patterns.join(', ')}

## Proposed Fixes
${failureAnalysis.proposedFixes.map((fix, i) => `${i + 1}. **${fix.type}**: ${fix.description}`).join('\n')}

## Instructions
Please execute the following fixes to resolve the test failures:

${failureAnalysis.proposedFixes.map(fix => {
                    switch(fix.type) {
                        case 'CREATE_FILE':
                            return `- Create the missing file with appropriate content based on the test requirements`;
                        case 'MOCK_DEPENDENCY':
                            return `- Since this is a Document Manager test, MongoDB tests should be skipped or mocked`;
                        case 'CHECKOUT_BRANCH':
                            return `- Ensure you're on the correct branch with latest changes`;
                        case 'UPDATE_CONTENT':
                            return `- Update file content to match expected values in the test`;
                        default:
                            return `- Investigate and fix the issue: ${fix.description}`;
                    }
                }).join('\n')}

After completing these fixes, I will re-run the tests automatically.`;
                
                return fixMessage;
            };
            
            // Test checkpoint pass/fail criteria
            const testCheckpoint = async (checkpoint, executionThreadId) => {
                addLog(`Running tests for ${checkpoint.name}...`, 'info');
                
                try {
                    const testResults = {
                        checkpointId: checkpoint.id,
                        checkpointName: checkpoint.name,
                        totalTests: checkpoint.passCriteria.length,
                        passedTests: [],
                        failedTests: [],
                        passed: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    // Test each pass criteria
                    for (let i = 0; i < checkpoint.passCriteria.length; i++) {
                        const criteria = checkpoint.passCriteria[i];
                        addLog(`Testing: ${criteria.description}`, 'info');
                        
                        try {
                            // FRANK'S CONTEXTLESS TEST - NEW TERRAGON INSTANCE
                            // Use execution thread ID, not task thread ID!
                            const testPassed = await executeContextlessTest(criteria, checkpoint, executionThreadId || state.taskThreadId);
                            
                            if (testPassed) {
                                testResults.passedTests.push({
                                    description: criteria.description,
                                    status: 'pass',
                                    details: `✓ ${criteria.description} verified successfully`
                                });
                                addLog(`✓ Test passed: ${criteria.description}`, 'success');
                            } else {
                                testResults.failedTests.push({
                                    description: criteria.description,
                                    status: 'fail',
                                    details: `✗ ${criteria.description} did not meet requirements`
                                });
                                addLog(`✗ Test failed: ${criteria.description}`, 'error');
                            }
                            
                        } catch (testError) {
                            testResults.failedTests.push({
                                description: criteria.description,
                                status: 'error',
                                details: `Error testing ${criteria.description}: ${testError.message}`
                            });
                            addLog(`Error testing ${criteria.description}: ${testError.message}`, 'error');
                        }
                    }
                    
                    // Determine overall pass/fail
                    testResults.passed = testResults.failedTests.length === 0;
                    
                    addLog(`Test summary: ${testResults.passedTests.length}/${testResults.totalTests} passed`, 
                           testResults.passed ? 'success' : 'error');
                    
                    return testResults;
                    
                } catch (error) {
                    addLog(`Test runner error: ${error.message}`, 'error');
                    return {
                        checkpointId: checkpoint.id,
                        passed: false,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    };
                }
            };

            // FRANK'S CONTEXTLESS TEST EXECUTION - NEW TERRAGON INSTANCE FOR EACH TEST
            const executeContextlessTest = async (criteria, checkpoint, mainThreadId) => {
                addLog(`🆕 CONTEXTLESS TEST: ${criteria.description}`, 'info');
                addLog(`Creating fresh Claude instance for unbiased testing...`, 'info');
                
                // FRANK'S DEBUG: Log all thread IDs
                console.log('Thread ID debug:');
                console.log(`  mainThreadId (param): ${mainThreadId}`);
                console.log(`  state.taskThreadId: ${state.taskThreadId}`);
                console.log(`  state.sessionId: ${state.sessionId}`);
                
                try {
                    // Create NEW Claude instance for contextless testing
                    // Detect branch for testing using branch tracker
                    let targetBranch = 'master';
                    
                    // FRANK'S SIMPLE FIX: Just check branch tracker - Claude is explicit
                    console.log(`Branch detection for thread: ${mainThreadId}`);
                    console.log(`Test criteria: "${criteria.description}"`);
                    
                    try {
                        // FRANK'S REAL FIX: Use the ORIGINAL Claude session ID, not test thread
                        const originalThreadId = state.taskThreadId || mainThreadId;
                        console.log(`Looking up branch for original thread: ${originalThreadId}`);
                        
                        // FRANK'S WORKAROUND: Also check if we have the branch in state
                        if (state.currentBranch) {
                            targetBranch = state.currentBranch;
                            console.log(`Using branch from state: ${targetBranch}`);
                            addLog(`📌 Using tracked branch: ${targetBranch}`, 'success');
                        }
                        
                        // FRANK'S FALLBACK: Try to get branch from window/global if available
                        if (targetBranch === 'master' && window.lastDetectedBranch) {
                            targetBranch = window.lastDetectedBranch;
                            console.log(`Using branch from window: ${targetBranch}`);
                            addLog(`📌 Using last detected branch: ${targetBranch}`, 'info');
                        }
                        
                        // FRANK'S DIRECT: Check if branch was passed through checkpoint
                        if (targetBranch === 'master' && checkpoint._detectedBranch) {
                            targetBranch = checkpoint._detectedBranch;
                            console.log(`Using branch from checkpoint: ${targetBranch}`);
                            addLog(`📌 Using checkpoint branch: ${targetBranch}`, 'success');
                        }
                        
                        const branchResponse = await fetch('/api/branch-tracker', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'get',
                                threadId: originalThreadId
                            })
                        });
                        
                        if (branchResponse.ok) {
                            const branchData = await branchResponse.json();
                            if (branchData.branch) {
                                targetBranch = branchData.branch;
                                console.log(`Testing on tracked branch: ${targetBranch}`);
                                addLog(`📌 Testing on branch: ${targetBranch}`, 'info');
                                
                                // FRANK'S DEBUG: Log if branch seems wrong
                                if (targetBranch.includes('mongodb') && !criteria.description.toLowerCase().includes('mongodb')) {
                                    console.warn(`WARNING: Branch mismatch? Testing '${criteria.description}' on MongoDB branch '${targetBranch}'`);
                                    addLog(`⚠️ Branch name doesn't match test criteria - possible stale branch tracking`, 'warning');
                                }
                            } else {
                                console.log(`No branch found for thread ${mainThreadId}`);
                                addLog(`⚠️ No branch tracked for thread ${mainThreadId} - using master`, 'warning');
                            }
                        } else {
                            console.error('Branch tracker request failed:', branchResponse.status);
                        }
                    } catch (e) {
                        console.error('Branch detection failed:', e);
                        addLog(`❌ Branch detection error: ${e.message}`, 'error');
                    }
                    
                    // FRANK'S LAST RESORT: If we still don't have a branch, log error
                    if (!targetBranch || targetBranch === 'master') {
                        console.error('BRANCH DETECTION FAILED - All methods returned master');
                        console.error('Available sources:', {
                            state: state.currentBranch,
                            window: window.lastDetectedBranch,
                            checkpoint: checkpoint._detectedBranch,
                            tracker: 'check logs above'
                        });
                    }
                    
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'test-real',
                            criteria,
                            testDescription: criteria.description,
                            mainThreadId: mainThreadId,
                            targetBranch: targetBranch
                        })
                    });
                    
                    if (!testResponse.ok) {
                        addLog(`Test instance creation failed: ${testResponse.status}`, 'error');
                        return false;
                    }
                    
                    const testResult = await testResponse.json();
                    
                    if (testResult.testInstanceCreated) {
                        addLog(`✅ Test instance created: ${testResult.testThreadId}`, 'success');
                        
                        // Register test instance with orchestrator
                        await registerWithOrchestrator(testResult.testThreadId, {
                            type: 'test',
                            parentId: executionThreadId || mainThreadId,
                            checkpoint: checkpoint,
                            branch: testResult.targetBranch,
                            criteria: criteria.description
                        });
                        
                        // FRANK'S WARNING: Check what branch was actually used
                        const actualBranch = testResult.targetBranch || 'master';
                        if (actualBranch === 'master' && targetBranch && targetBranch !== 'master') {
                            addLog(`❌ WARNING: Test created on MASTER but should be on ${targetBranch}!`, 'error');
                            addLog(`🔍 Branch detection failed - targetBranch was: ${targetBranch}`, 'error');
                        } else if (testResult.targetBranch && testResult.targetBranch !== 'master') {
                            addLog(`✅ Testing on branch: ${testResult.targetBranch}`, 'success');
                        } else {
                            addLog(`⚠️ Testing on master branch (no feature branch detected)`, 'warning');
                        }
                        addLog(`🔗 Test URL: ${testResult.testUrl}`, 'info');
                        addLog(`⏳ Polling test instance for REAL results...`, 'info');
                        
                        // FRANK'S REAL TEST RESULT POLLING - NO BULLSHIT
                        const testInstanceResult = await pollTestInstanceForResults(testResult.testThreadId, 60); // 5 minute max
                        
                        if (testInstanceResult.completed && testInstanceResult.result) {
                            const passed = testInstanceResult.result.toLowerCase().includes('pass');
                            addLog(`🧪 Test instance completed: ${passed ? 'PASS' : 'FAIL'}`, passed ? 'success' : 'error');
                            addLog(`📝 Test evidence: ${testInstanceResult.evidence}`, 'info');
                            return passed;
                        } else {
                            addLog(`❌ Test instance failed to complete or provide results`, 'error');
                            return false;
                        }
                        
                    } else {
                        addLog(`Test instance creation failed`, 'error');
                        return false;
                    }
                    
                } catch (error) {
                    addLog(`Contextless test error: ${error.message}`, 'error');
                    return false;
                }
            };

            // FRANK'S REAL TEST INSTANCE POLLING - NO FAKE RESULTS
            const pollTestInstanceForResults = async (testThreadId, maxPolls = 60, retryCount = 0) => {
                addLog(`🔄 Polling test instance ${testThreadId} for real results...`, 'info');
                
                for (let pollCount = 0; pollCount < maxPolls; pollCount++) {
                    try {
                        // Check test instance status
                        const statusResponse = await fetch('/api/execute', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                action: 'check-claude-status',
                                threadId: testThreadId
                            })
                        });
                        
                        if (statusResponse.ok) {
                            let statusResult = await statusResponse.json();
                            
                            if (statusResult.completed) {
                                addLog(`✅ Test instance ${testThreadId} completed!`, 'success');
                                
                                // FRANK'S FIX: RED TEAM found the real bug - API sync delay
                                // Claude UI updates before API syncs the full response
                                addLog(`⏳ Waiting 30s for Claude API to sync full response...`, 'info');
                                await new Promise(resolve => setTimeout(resolve, 30000));
                                
                                // Re-fetch after sync delay to get complete response
                                const syncResponse = await fetch('/api/execute', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ 
                                        action: 'check-claude-status',
                                        threadId: testThreadId
                                    })
                                });
                                
                                if (syncResponse.ok) {
                                    const syncResult = await syncResponse.json();
                                    // Use the synced result instead
                                    statusResult = syncResult;
                                }
                                
                                // FRANK'S DEBUG: Log what we're getting
                                console.log('Test status result after sync:', statusResult);
                                
                                // Parse the actual test result from Claude response
                                // Look for RESULT: PASS/FAIL pattern in the response
                                const testContent = statusResult.lastResponse || statusResult.message || '';
                                
                                // If test content is empty, we have a problem
                                if (!testContent || testContent.length < 10) {
                                    console.error('Test content is empty or too short:', testContent);
                                    addLog(`⚠️ Test response appears empty, length: ${testContent.length}`, 'warning');
                                }
                                
                                let result = 'UNKNOWN';
                                let evidence = 'No evidence found';
                                
                                // Extract RESULT: and EVIDENCE: from Claude response
                                const resultMatch = testContent.match(/RESULT:\s*(PASS|FAIL)/i);
                                const evidenceMatch = testContent.match(/EVIDENCE:\s*([^\n]+)/i);
                                
                                if (resultMatch) {
                                    result = resultMatch[1].toUpperCase();
                                }
                                if (evidenceMatch) {
                                    evidence = evidenceMatch[1].trim();
                                }
                                
                                // FRANK'S RETRY: If still no result, retry with delay
                                if (result === 'UNKNOWN' && retryCount < 3) {
                                    console.log(`Result not found, retry attempt ${retryCount + 1}/3...`);
                                    addLog(`⚠️ Result not found in response, retrying (${retryCount + 1}/3)...`, 'warning');
                                    await new Promise(resolve => setTimeout(resolve, 5000));
                                    return await pollTestInstanceForResults(testThreadId, maxPolls, retryCount + 1);
                                }
                                
                                return {
                                    completed: true,
                                    result: result,
                                    evidence: evidence,
                                    fullResponse: testContent
                                };
                            } else {
                                if (pollCount % 6 === 0) { // Log every 30 seconds
                                    addLog(`⏳ Test instance still running... (${pollCount * 5}s elapsed)`, 'info');
                                }
                            }
                        }
                        
                        // Wait 5 seconds before next poll
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        
                    } catch (error) {
                        addLog(`Test polling error: ${error.message}`, 'error');
                    }
                }
                
                // Max polls reached
                addLog(`🕐 Test instance polling timeout after ${maxPolls * 5} seconds`, 'error');
                return {
                    completed: false,
                    result: 'TIMEOUT',
                    evidence: 'Test instance did not complete within timeout period'
                };
            };

            // Validate checkpoint dependencies
            const validateDependencies = async (checkpoint) => {
                const currentIndex = state.currentCheckpointIndex || 0;
                const queue = state.checkpointQueue || state.checkpoints;
                
                // For the first checkpoint, no dependencies to check
                if (currentIndex === 0) {
                    return true;
                }
                
                // Check all previous checkpoints
                for (let i = 0; i < currentIndex; i++) {
                    const previousCheckpoint = queue[i];
                    const previousStatus = state.executionStatus[previousCheckpoint.id];
                    
                    // If previous checkpoint is blocking and hasn't passed, we can't proceed
                    if (previousCheckpoint.blocking && previousStatus?.status !== 'pass') {
                        addLog(`Blocked by ${previousCheckpoint.name} (status: ${previousStatus?.status || 'unknown'})`, 'error');
                        return false;
                    }
                    
                    // If previous checkpoint is still executing, wait for non-blocking
                    if (previousStatus?.status === 'in_progress' || previousStatus?.status === 'executing') {
                        if (previousCheckpoint.blocking) {
                            addLog(`Waiting for blocking checkpoint: ${previousCheckpoint.name}`, 'info');
                            return false;
                        } else {
                            // Non-blocking can run in parallel - this is allowed
                            addLog(`Running in parallel with non-blocking: ${previousCheckpoint.name}`, 'info');
                        }
                    }
                    
                    // If a blocking checkpoint failed, halt execution
                    if (previousCheckpoint.blocking && previousStatus?.status === 'fail') {
                        addLog(`Cannot proceed: blocking checkpoint ${previousCheckpoint.name} failed`, 'error');
                        return false;
                    }
                }
                
                // All dependency checks passed
                return true;
            };

            // Get dependency status for UI display
            const getDependencyStatus = (checkpoint) => {
                const currentIndex = state.checkpoints.findIndex(cp => cp.id === checkpoint.id);
                if (currentIndex === 0) return 'ready';
                
                // Check blocking dependencies
                for (let i = 0; i < currentIndex; i++) {
                    const previousCheckpoint = state.checkpoints[i];
                    const previousStatus = state.executionStatus[previousCheckpoint.id];
                    
                    if (previousCheckpoint.blocking && previousStatus?.status !== 'pass') {
                        return 'blocked';
                    }
                }
                
                return 'ready';
            };

            // Validate task completion - end-to-end validation
            const validateTaskCompletion = async () => {
                addLog('Running end-to-end task validation...', 'info');
                
                try {
                    if (!state.task || !state.task.acceptanceCriteria) {
                        addLog('No acceptance criteria defined for task', 'error');
                        return false;
                    }
                    
                    const taskValidation = {
                        taskId: state.task.id || 'current-task',
                        taskName: state.task.name,
                        totalCriteria: state.task.acceptanceCriteria.length,
                        passedCriteria: [],
                        failedCriteria: [],
                        checkpointSummary: {},
                        passed: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    // First, verify all checkpoints have passed
                    let allCheckpointsPassed = true;
                    state.checkpoints.forEach(checkpoint => {
                        const status = state.executionStatus[checkpoint.id];
                        taskValidation.checkpointSummary[checkpoint.id] = {
                            name: checkpoint.name,
                            status: status?.status || 'unknown',
                            blocking: checkpoint.blocking
                        };
                        
                        if (checkpoint.blocking && status?.status !== 'pass') {
                            allCheckpointsPassed = false;
                            addLog(`Critical checkpoint failed: ${checkpoint.name}`, 'error');
                        }
                    });
                    
                    if (!allCheckpointsPassed) {
                        addLog('Task validation failed: critical checkpoints not passed', 'error');
                        return false;
                    }
                    
                    // Test each acceptance criteria
                    for (let i = 0; i < state.task.acceptanceCriteria.length; i++) {
                        const criteria = state.task.acceptanceCriteria[i];
                        addLog(`Validating acceptance criteria: ${criteria}`, 'info');
                        
                        try {
                            // Call API for end-to-end testing
                            const validationResponse = await fetch(EXECUTE_URL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    action: 'validate-task',
                                    task: state.task,
                                    criteria,
                                    checkpointResults: state.executionStatus,
                                    sessionId: state.taskThreadId
                                })
                            });
                            
                            // REAL VALIDATION - NO FAKE SHIT
                            const criteriaPassed = await executeRealTaskValidation(criteria);
                            
                            if (criteriaPassed) {
                                taskValidation.passedCriteria.push({
                                    description: criteria,
                                    status: 'pass',
                                    details: `✓ ${criteria} validated successfully`
                                });
                                addLog(`✓ Acceptance criteria passed: ${criteria}`, 'success');
                            } else {
                                taskValidation.failedCriteria.push({
                                    description: criteria,
                                    status: 'fail',
                                    details: `✗ ${criteria} does not meet requirements`
                                });
                                addLog(`✗ Acceptance criteria failed: ${criteria}`, 'error');
                            }
                            
                        } catch (validationError) {
                            taskValidation.failedCriteria.push({
                                description: criteria,
                                status: 'error',
                                details: `Error validating ${criteria}: ${validationError.message}`
                            });
                            addLog(`Error validating ${criteria}: ${validationError.message}`, 'error');
                        }
                    }
                    
                    // Determine overall task completion
                    taskValidation.passed = taskValidation.failedCriteria.length === 0;
                    
                    if (taskValidation.passed) {
                        addLog(`🎉 Task validation successful! All ${taskValidation.totalCriteria} criteria passed`, 'success');
                        addLog('Task is ready for human review', 'success');
                        
                        // Update task status to awaiting review
                        setState(prev => ({
                            ...prev,
                            taskStatus: 'Awaiting Review',
                            taskValidationResults: taskValidation
                        }));
                        
                        // Add to review queue
                        const reviewTask = {
                            id: `task-${Date.now()}`,
                            name: state.task.name,
                            objective: state.task.objective,
                            status: 'Awaiting Review',
                            branch: `claude/${state.task.name.toLowerCase().replace(/\s+/g, '-')}`,
                            threadId: state.taskThreadId,
                            acceptanceCriteria: state.task.acceptanceCriteria,
                            completedAt: new Date().toISOString(),
                            validationResults: taskValidation
                        };
                        
                        setState(prev => ({
                            ...prev,
                            reviewTasks: [...prev.reviewTasks, reviewTask]
                        }));
                        
                    } else {
                        addLog(`Task validation failed: ${taskValidation.failedCriteria.length}/${taskValidation.totalCriteria} criteria failed`, 'error');
                        addLog('Task requires additional work before review', 'error');
                    }
                    
                    return taskValidation.passed;
                    
                } catch (error) {
                    addLog(`Task validation error: ${error.message}`, 'error');
                    return false;
                }
            };

            // REAL TASK VALIDATION - NO FAKE BULLSHIT
            const executeRealTaskValidation = async (criteria) => {
                addLog(`REAL TASK VALIDATION: ${criteria}`, 'info');
                
                try {
                    // Call API to run actual task-level validation
                    const validationResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            criteria,
                            task: state.task,
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (!validationResponse.ok) {
                        addLog(`Task validation API failed: ${validationResponse.status}`, 'error');
                        return false;
                    }
                    
                    const validationResult = await validationResponse.json();
                    addLog(`Task validation: ${validationResult.passed ? 'PASSED' : 'FAILED'} - ${validationResult.details}`, 
                           validationResult.passed ? 'success' : 'error');
                    
                    return validationResult.passed;
                    
                } catch (error) {
                    addLog(`Task validation error: ${error.message}`, 'error');
                    return false;
                }
            };

            // No longer executing checkpoints individually
            const executeCheckpoint = async (checkpoint) => {
                // DEPRECATED - we now send all checkpoints to one thread
                addLog(`Executing: ${checkpoint.name}`, 'info');
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { status: 'in_progress', logs: [] }
                    }
                }));
                
                try {
                    // Execute via Claude
                    const execResponse = await fetch(EXECUTE_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: state.sessionId
                        })
                    });
                    
                    const execData = await execResponse.json();
                    if (!execResponse.ok) throw new Error(execData.error);
                    
                    addLog(`${checkpoint.name}: Created in session ${execData.threadId}`, 'success');
                    
                    // Update status to show execution was sent to Claude
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'sent',
                                threadId: execData.threadId,
                                logs: [{ 
                                    message: `Executing in Claude session: ${execData.threadId}`,
                                    url: threadUrl
                                }]
                            }
                        },
                        activeThreads: {
                            ...prev.activeThreads,
                            [checkpoint.id]: execData.threadId
                        }
                    }));
                    
                } catch (error) {
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }]
                            }
                        }
                    }));
                    addLog(`${checkpoint.name} failed: ${error.message}`, 'error');
                }
            };

            // Checkpoint status badge
            const StatusBadge = ({ status }) => {
                const colors = {
                    pending: 'bg-gray-600',
                    in_progress: 'bg-blue-600',
                    sent: 'bg-purple-600',
                    pass: 'bg-green-600',
                    fail: 'bg-red-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status}
                    </span>
                );
            };

            // Chat functions
            const sendChatMessage = async () => {
                if (!state.chatInput.trim() || !state.chatThreadId) return;
                
                const message = state.chatInput;
                setState(prev => ({
                    ...prev,
                    chatMessages: [...prev.chatMessages, { 
                        type: 'user', 
                        text: message, 
                        timestamp: new Date().toLocaleTimeString() 
                    }],
                    chatInput: ''
                }));
                
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            threadId: state.chatThreadId, 
                            message 
                        })
                    });
                    
                    const data = await response.json();
                    if (data.responses) {
                        data.responses.forEach(resp => {
                            setState(prev => ({
                                ...prev,
                                chatMessages: [...prev.chatMessages, { 
                                    type: 'assistant', 
                                    text: resp.text, 
                                    timestamp: resp.timestamp 
                                }]
                            }));
                        });
                    }
                } catch (error) {
                    addLog(`Chat error: ${error.message}`, 'error');
                }
            };

            const startChatSession = async () => {
                const threadId = `chat-${Date.now()}-${Math.random().toString(36).substring(7)}`;
                setState(prev => ({
                    ...prev,
                    chatThreadId: threadId,
                    chatVisible: true,
                    chatMessages: [{
                        type: 'system',
                        text: 'Chat connected to UncleFrank system. You can create tasks by describing what you want.',
                        timestamp: new Date().toLocaleTimeString()
                    }]
                }));
                addLog(`Chat session started: ${threadId}`, 'success');
            };

            const createTaskFromChat = (message) => {
                setState(prev => ({ ...prev, request: message }));
                addLog('Task request populated from chat', 'info');
            };

            // Task Review handlers
            const handleUpdateTaskStatus = (taskId, newStatus) => {
                setState(prev => ({
                    ...prev,
                    reviewTasks: prev.reviewTasks.map(task =>
                        task.id === taskId ? { ...task, status: newStatus } : task
                    )
                }));
                addLog(`Task ${taskId} status updated to ${newStatus}`, 'info');
            };

            const handleViewChanges = (task) => {
                addLog(`Opening diff viewer for ${task.name}`, 'info');
                setSelectedTask(task);
                setDiffViewerOpen(true);
            };

            const handleRunTests = async (task) => {
                addLog(`Running comprehensive tests for ${task.name}`, 'info');
                
                try {
                    // FRANK'S REAL TEST RUNNER - NO TODOS
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            task: task,
                            criteria: task.acceptanceCriteria || task.description,
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (testResponse.ok) {
                        const testData = await testResponse.json();
                        addLog(`Task validation: ${testData.passed ? 'PASSED' : 'FAILED'}`, 
                               testData.passed ? 'success' : 'error');
                        addLog(`Details: ${testData.details}`, 'info');
                        return testData.passed;
                    } else {
                        addLog('Task validation API failed', 'error');
                        return false;
                    }
                } catch (error) {
                    addLog(`Test runner error: ${error.message}`, 'error');
                    return false;
                }
            };

            const handleApprove = async (task) => {
                try {
                    if (task.prUrl) {
                        // PR already exists, just open it
                        addLog(`Opening existing PR for ${task.name}...`, 'info');
                        window.open(task.prUrl, '_blank');
                        return;
                    }
                    
                    addLog(`Creating PR for ${task.name}...`, 'info');
                    
                    // Create PR body with task details
                    const prBody = `## Task: ${task.name}

### Objective
${task.objective}

### Acceptance Criteria
${task.acceptanceCriteria ? task.acceptanceCriteria.map(criteria => `- ${criteria}`).join('\n') : 'No criteria specified'}

### Branch
\`${task.branch}\`

### Execution Session
Claude Session ID: ${task.threadId}

---
🤖 This PR was automatically created by Uncle Frank's Task Review System`;

                    // Create the actual PR via GitHub API
                    const pr = await GitHubService.createPullRequest(
                        `Task: ${task.name}`,
                        prBody,
                        task.branch,
                        'master'
                    );
                    
                    if (pr) {
                        addLog(`PR created: ${pr.html_url}`, 'success');
                        
                        // Update task with PR info and status
                        setState(prev => ({
                            ...prev,
                            reviewTasks: prev.reviewTasks.map(t =>
                                t.id === task.id ? { 
                                    ...t, 
                                    status: 'In Review',
                                    prUrl: pr.html_url,
                                    prNumber: pr.number
                                } : t
                            )
                        }));
                        
                        // Open the PR in a new tab
                        window.open(pr.html_url, '_blank');
                    } else {
                        // Fallback: try to open compare view
                        const compareUrl = GitHubService.getCompareUrl('master', task.branch);
                        addLog(`PR creation failed, opening compare view: ${compareUrl}`, 'error');
                        window.open(compareUrl, '_blank');
                        
                        // Update status to In Review anyway
                        handleUpdateTaskStatus(task.id, 'In Review');
                    }
                    
                } catch (error) {
                    addLog(`Failed to create PR: ${error.message}`, 'error');
                    
                    // Fallback: open compare view
                    const compareUrl = GitHubService.getCompareUrl('master', task.branch);
                    addLog(`Opening compare view instead: ${compareUrl}`, 'info');
                    window.open(compareUrl, '_blank');
                }
            };

            const handleRequestChanges = (task) => {
                handleUpdateTaskStatus(task.id, 'Changes Requested');
                addLog(`Changes requested for ${task.name}`, 'info');
            };

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl">
                    <div className="flex justify-between items-start mb-8">
                        <div>
                            <h1 className="text-4xl font-bold mb-2">🔨 Uncle Frank's Bootstrap Core</h1>
                            <p className="text-gray-400">No BS Autonomous LLM Development Platform</p>
                        </div>
                        <div className="flex items-center gap-3">
                            <div className="flex items-center gap-2 px-3 py-1 bg-gray-800 rounded">
                                <div className={`w-2 h-2 rounded-full ${state.githubConnected ? 'bg-green-500' : 'bg-red-500'}`}></div>
                                <span className="text-sm text-gray-400">
                                    GitHub: {state.githubConnected ? 'Connected' : 'Disconnected'}
                                </span>
                            </div>
                            <div className="flex items-center gap-2 px-3 py-1 bg-gray-800 rounded">
                                <div className={`w-2 h-2 rounded-full ${state.claudeExecutorOnline ? 'bg-green-500' : 'bg-red-500'}`}></div>
                                <span className="text-sm text-gray-400">
                                    Claude: {state.claudeExecutorOnline ? 'Online' : 'Offline'}
                                </span>
                                {!state.claudeExecutorOnline && (
                                    <button
                                        onClick={async () => {
                                            addLog('🚀 Starting Claude executor...', 'info');
                                            try {
                                                const response = await fetch('/api/claude-health-monitor', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({ action: 'force-restart' })
                                                });
                                                const data = await response.json();
                                                if (data.success) {
                                                    addLog('✅ Claude restart initiated. Please wait 30-60 seconds...', 'success');
                                                    setTimeout(checkClaudeExecutor, 30000);
                                                } else {
                                                    addLog('❌ Failed to restart Claude', 'error');
                                                }
                                            } catch (error) {
                                                addLog(`❌ Restart error: ${error.message}`, 'error');
                                            }
                                        }}
                                        className="ml-2 px-2 py-0.5 bg-red-600 hover:bg-red-700 rounded text-xs"
                                    >
                                        Start
                                    </button>
                                )}
                            </div>
                            <button 
                                onClick={() => {
                                    checkGitHubConnection();
                                    checkClaudeExecutor();
                                }}
                                className="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded transition text-sm"
                                title="Refresh connection status"
                            >
                                🔄 Refresh
                            </button>
                        </div>
                    </div>

                    {/* Task Review Queue */}
                    <div className="mb-6">
                        {loadingTasks ? (
                            <div className="bg-gray-800 rounded-lg p-6">
                                <div className="text-center py-8">
                                    <div className="text-blue-400">Loading tasks from GitHub...</div>
                                </div>
                            </div>
                        ) : (
                            <KanbanBoard 
                                tasks={state.reviewTasks}
                                onUpdateTaskStatus={handleUpdateTaskStatus}
                                onViewChanges={handleViewChanges}
                                onRunTests={handleRunTests}
                                onApprove={handleApprove}
                                onRequestChanges={handleRequestChanges}
                                onTaskClick={openTaskWorkspace}
                            />
                        )}
                    </div>
                    
                    {/* FRANK'S DRAFT MANAGEMENT - Enforces the sacred flow */}
                    <DraftManager />

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/* Left Panel - Input */}
                        <div>
                            <div className="bg-gray-800 rounded-lg p-6 mb-6">
                                <h2 className="text-2xl font-semibold mb-4">Create New Task</h2>
                                
                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Request</label>
                                    <textarea 
                                        value={state.request}
                                        onChange={(e) => setState(prev => ({ ...prev, request: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="e.g., Add Discord bot integration"
                                    />
                                </div>

                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Project Context (optional)</label>
                                    <textarea 
                                        value={state.projectContext}
                                        onChange={(e) => setState(prev => ({ ...prev, projectContext: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="Paste your Project.md content here..."
                                    />
                                </div>

                                <div className="flex gap-2">
                                    <button 
                                        onClick={classifyRequest}
                                        disabled={loading}
                                        className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded transition disabled:opacity-50"
                                    >
                                        Classify
                                    </button>
                                    <button 
                                        onClick={decomposeTask}
                                        disabled={loading}
                                        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded transition disabled:opacity-50"
                                    >
                                        Decompose Task
                                    </button>
                                    {state.checkpoints.length > 0 && (
                                        <button 
                                            onClick={executeCheckpointsSequentially}
                                            disabled={executing}
                                            className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition disabled:opacity-50"
                                        >
                                            {executing ? 'Executing...' : 'Execute Sequential'}
                                        </button>
                                    )}
                                </div>
                            </div>

                            {/* Task Summary */}
                            {state.task && (
                                <div className="bg-gray-800 rounded-lg p-6">
                                    <h3 className="text-lg font-semibold mb-2">{state.task.name}</h3>
                                    <p className="text-gray-400 mb-2">{state.task.objective}</p>
                                    <p className="text-sm">{state.task.acceptanceCriteria.length} acceptance criteria</p>
                                    
                                    {/* Task-level Claude Execution */}
                                    {state.taskThreadId && (
                                        <div className="mt-4 pt-4 border-t border-gray-700">
                                            <div className="flex items-center justify-between mb-2">
                                                <span className="text-sm font-semibold">Claude Session</span>
                                                <span className="text-xs text-gray-500">{state.taskThreadId}</span>
                                            </div>
                                            <button 
                                                onClick={() => addLog(`Claude session: ${state.taskThreadId}`, 'info')}
                                                className="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                                            >
                                                View Claude Logs →
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Right Panel - Logs Only */}
                        <div>

                            {/* Execution Logs */}
                            <div className="bg-gray-800 rounded-lg p-6">
                                <h3 className="text-lg font-semibold mb-4">Execution Logs</h3>
                                <div className="h-64 overflow-y-auto bg-gray-900 rounded p-3 font-mono text-xs">
                                    {state.logs.map((log, i) => (
                                        <div key={i} className={`mb-1 ${
                                            log.level === 'error' ? 'text-red-400' : 
                                            log.level === 'success' ? 'text-green-400' : 
                                            'text-gray-300'
                                        }`}>
                                            <span className="text-gray-500">[{log.timestamp}]</span> {log.message}
                                            {log.sessionId && (
                                                <button 
                                                    onClick={() => openSessionViewer(log.sessionId)}
                                                    className="ml-2 text-blue-400 hover:text-blue-300 underline text-xs"
                                                >
                                                    View Session
                                                </button>
                                            )}
                                        </div>
                                    ))}
                                    {state.logs.length === 0 && (
                                        <div className="text-gray-500">No logs yet...</div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Diff Viewer Modal */}
                    <DiffViewer 
                        isOpen={diffViewerOpen}
                        onClose={() => setDiffViewerOpen(false)}
                        task={selectedTask}
                    />
                    
                    {/* Orchestrator Status - Disabled (annoying box) */}
                    {/* <OrchestratorStatus /> */}
                    
                    {/* Task Workspace View Modal - As per Interface.md */}
                    {taskWorkspaceOpen && workspaceTask && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-gray-900 rounded-lg p-6 max-w-6xl w-full max-h-[90vh] overflow-hidden flex flex-col">
                                {/* Header */}
                                <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-4">
                                    <div>
                                        <h2 className="text-2xl font-bold text-white">Task Workspace</h2>
                                        <p className="text-gray-400 mt-1">{workspaceTask.name || workspaceTask.objective}</p>
                                    </div>
                                    <button 
                                        onClick={() => setTaskWorkspaceOpen(false)}
                                        className="text-gray-400 hover:text-white p-2"
                                    >
                                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                        </svg>
                                    </button>
                                </div>
                                
                                {/* Content Grid */}
                                <div className="flex-1 overflow-hidden grid grid-cols-3 gap-4">
                                    {/* Left Panel - Task Details */}
                                    <div className="col-span-1 border-r border-gray-700 pr-4 overflow-y-auto">
                                        <h3 className="text-lg font-semibold mb-3 text-blue-400">Task Details</h3>
                                        
                                        {/* Status Badge */}
                                        <div className="mb-4">
                                            <label className="text-xs text-gray-400">Status</label>
                                            <div className="mt-1">
                                                <span className={`px-3 py-1 rounded text-sm ${
                                                    workspaceTask.status === 'In Progress' ? 'bg-blue-600' :
                                                    workspaceTask.status === 'Completed' ? 'bg-green-600' :
                                                    workspaceTask.status === 'In Review' ? 'bg-purple-600' :
                                                    'bg-gray-600'
                                                }`}>
                                                    {workspaceTask.status || 'Pending'}
                                                </span>
                                            </div>
                                        </div>
                                        
                                        {/* Objective */}
                                        {workspaceTask.objective && (
                                            <div className="mb-4">
                                                <label className="text-xs text-gray-400">Objective</label>
                                                <p className="mt-1 text-sm">{workspaceTask.objective}</p>
                                            </div>
                                        )}
                                        
                                        {/* Acceptance Criteria */}
                                        {workspaceTask.acceptanceCriteria && (
                                            <div className="mb-4">
                                                <label className="text-xs text-gray-400">Acceptance Criteria</label>
                                                <ul className="mt-1 text-sm space-y-1">
                                                    {workspaceTask.acceptanceCriteria.map((criteria, i) => (
                                                        <li key={i} className="flex items-start">
                                                            <span className="text-green-500 mr-2">✓</span>
                                                            <span>{criteria}</span>
                                                        </li>
                                                    ))}
                                                </ul>
                                            </div>
                                        )}
                                        
                                        {/* GitHub Links */}
                                        <div className="mb-4">
                                            <label className="text-xs text-gray-400">GitHub Integration</label>
                                            <div className="mt-2 space-y-2">
                                                {workspaceTask.issueNumber && (
                                                    <a 
                                                        href={workspaceTask.issueUrl}
                                                        target="_blank"
                                                        className="text-blue-400 hover:underline text-sm block"
                                                    >
                                                        Issue #{workspaceTask.issueNumber} ↗
                                                    </a>
                                                )}
                                                {workspaceTask.branch && (
                                                    <a 
                                                        href={GitHubService.getBranchUrl(workspaceTask.branch)}
                                                        target="_blank"
                                                        className="text-blue-400 hover:underline text-sm block"
                                                    >
                                                        Branch: {workspaceTask.branch} ↗
                                                    </a>
                                                )}
                                                {workspaceTask.prUrl && (
                                                    <a 
                                                        href={workspaceTask.prUrl}
                                                        target="_blank"
                                                        className="text-blue-400 hover:underline text-sm block"
                                                    >
                                                        Pull Request ↗
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                        
                                        {/* Session Info with History */}
                                        <div className="mb-4">
                                            <label className="text-xs text-gray-400">Claude Sessions</label>
                                            
                                            {/* Current Session */}
                                            {(workspaceTask?.sessionId || workspaceTask?.threadId) && (
                                                <div className="mt-2" key={`session-${workspaceTask.sessionId || workspaceTask.threadId}-${workspaceTask.lastUpdated || Date.now()}`}>
                                                    <div className="bg-gray-800 rounded p-2">
                                                        <div className="flex items-center justify-between">
                                                            <p className="text-sm font-mono text-gray-300">
                                                                {workspaceTask.isRestarting ? (
                                                                    <span className="text-yellow-400 animate-pulse">🔄 Restarting...</span>
                                                                ) : (
                                                                    <>
                                                                        <span className="text-green-400">●</span> {(workspaceTask.sessionId || workspaceTask.threadId || 'none').substring(0, 12)}...
                                                                        {workspaceTask.sessionExpired && !workspaceTask.justRestarted && (
                                                                            <span className="ml-2 text-red-500 text-xs">(Expired)</span>
                                                                        )}
                                                                        {workspaceTask.justRestarted && (
                                                                            <span className="ml-2 text-green-500 text-xs">✅ (Just Created)</span>
                                                                        )}
                                                                        {!workspaceTask.sessionExpired && !workspaceTask.justRestarted && (
                                                                            <span className="ml-2 text-blue-500 text-xs">(Active)</span>
                                                                        )}
                                                                    </>
                                                                )}
                                                            </p>
                                                            <button
                                                                onClick={() => {
                                                                    setSelectedSessionId(workspaceTask.sessionId || workspaceTask.threadId);
                                                                    fetchSessionMessages(workspaceTask.sessionId || workspaceTask.threadId);
                                                                    setSessionViewerOpen(true);
                                                                }}
                                                                className="text-xs px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded transition"
                                                            >
                                                                🖥️ View
                                                            </button>
                                                        </div>
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {/* Session History */}
                                            {workspaceTask?.sessionHistory && workspaceTask.sessionHistory.length > 0 && (
                                                <div className="mt-2">
                                                    <p className="text-xs text-gray-500 mb-1">Previous Sessions:</p>
                                                    <div className="space-y-1">
                                                        {workspaceTask.sessionHistory.map((session, idx) => (
                                                            <div key={session.id || idx} className="bg-gray-900 rounded p-2">
                                                                <div className="flex items-center justify-between">
                                                                    <p className="text-xs font-mono text-gray-400">
                                                                        <span className="text-gray-600">●</span> {session.id.substring(0, 12)}...
                                                                        <span className="ml-2 text-gray-600 text-xs">
                                                                            ({session.timestamp ? new Date(session.timestamp).toLocaleTimeString() : 'Unknown time'})
                                                                        </span>
                                                                    </p>
                                                                    <button
                                                                        onClick={() => {
                                                                            setSelectedSessionId(session.id);
                                                                            fetchSessionMessages(session.id);
                                                                            setSessionViewerOpen(true);
                                                                        }}
                                                                        className="text-xs px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded transition"
                                                                    >
                                                                        View
                                                                    </button>
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {/* Old session reference if exists */}
                                            {workspaceTask?.oldSessionId && workspaceTask.oldSessionId !== workspaceTask.sessionId && 
                                             (!workspaceTask?.sessionHistory || !workspaceTask.sessionHistory.find(s => s.id === workspaceTask.oldSessionId)) && (
                                                <div className="mt-2 p-2 bg-gray-900 rounded text-xs">
                                                    <div className="flex items-center justify-between">
                                                        <span className="text-gray-500">
                                                            <span className="text-gray-600">●</span> Previous: {workspaceTask.oldSessionId.substring(0, 12)}...
                                                        </span>
                                                        <button
                                                            onClick={() => {
                                                                setSelectedSessionId(workspaceTask.oldSessionId);
                                                                fetchSessionMessages(workspaceTask.oldSessionId);
                                                                setSessionViewerOpen(true);
                                                            }}
                                                            className="text-xs px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded transition"
                                                        >
                                                            View
                                                        </button>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* Middle Panel - Checkpoints */}
                                    <div className="col-span-1 border-r border-gray-700 pr-4 overflow-y-auto">
                                        <h3 className="text-lg font-semibold mb-3 text-green-400">Checkpoints</h3>
                                        
                                        {workspaceTask.checkpoints && workspaceTask.checkpoints.length > 0 ? (
                                            <div className="space-y-3">
                                                {workspaceTask.checkpoints.map((checkpoint, i) => (
                                                    <div key={i} className="bg-gray-800 rounded p-3">
                                                        <div className="flex items-center justify-between mb-2">
                                                            <span className="font-medium text-sm">
                                                                Checkpoint {i + 1}
                                                            </span>
                                                            <span className={`w-6 h-6 rounded-full flex items-center justify-center text-xs ${
                                                                checkpoint.status === 'completed' ? 'bg-green-600' :
                                                                checkpoint.status === 'in_progress' ? 'bg-blue-600' :
                                                                checkpoint.status === 'failed' ? 'bg-red-600' :
                                                                'bg-gray-600'
                                                            }`}>
                                                                {checkpoint.status === 'completed' ? '✓' :
                                                                 checkpoint.status === 'in_progress' ? '•' :
                                                                 checkpoint.status === 'failed' ? '✗' : ''}
                                                            </span>
                                                        </div>
                                                        <p className="text-xs text-gray-400">
                                                            {checkpoint.name || checkpoint.objective}
                                                        </p>
                                                        {checkpoint.test && (
                                                            <p className="text-xs text-gray-500 mt-1">
                                                                Test: {checkpoint.test}
                                                            </p>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>
                                        ) : (
                                            <p className="text-sm text-gray-500">No checkpoints defined</p>
                                        )}
                                    </div>
                                    
                                    {/* Right Panel - Execution Logs */}
                                    <div className="col-span-1 overflow-y-auto">
                                        <h3 className="text-lg font-semibold mb-3 text-purple-400">Execution Logs</h3>
                                        
                                        {loadingSession ? (
                                            <div className="text-center py-4">
                                                <div className="text-blue-400">Loading session logs...</div>
                                            </div>
                                        ) : taskExecutionLogs.length > 0 ? (
                                            <div className="space-y-2">
                                                {taskExecutionLogs.map((msg, i) => (
                                                    <div key={i} className="bg-gray-800 rounded p-2">
                                                        <div className="text-xs text-gray-400 mb-1">
                                                            {msg.role === 'user' ? 'System' : 'Claude'}
                                                        </div>
                                                        <div className="text-sm text-gray-200 whitespace-pre-wrap break-words">
                                                            {msg.content.substring(0, 200)}
                                                            {msg.content.length > 200 && '...'}
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        ) : (
                                            <p className="text-sm text-gray-500">No execution logs available</p>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Footer Actions - FRANK'S HUMAN APPROVAL REQUIRED */}
                                <div className="mt-4 pt-4 border-t border-gray-700 flex justify-between">
                                    <div className="flex gap-2">
                                        {workspaceTask.status === 'In Progress' && (
                                            <>
                                                <button 
                                                    className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition font-bold"
                                                    onClick={async () => {
                                                        console.log('Execute button clicked');
                                                        console.log('Current workspaceTask:', workspaceTask);
                                                        console.log('Checkpoints:', workspaceTask.checkpoints);
                                                        console.log('Session ID:', workspaceTask.sessionId);
                                                        
                                                        if (!workspaceTask.checkpoints || workspaceTask.checkpoints.length === 0) {
                                                            addLog('⚠️ No checkpoints to execute. Please restart task with decomposition.', 'warning');
                                                            alert('No checkpoints found! Please use "Restart Task" to decompose the task into checkpoints first.');
                                                            return;
                                                        }
                                                        
                                                        if (!workspaceTask.sessionId) {
                                                            addLog('⚠️ No session ID found. Please restart the task.', 'warning');
                                                            alert('No session ID found! Please restart the task.');
                                                            return;
                                                        }
                                                        
                                                        addLog('🚀 Executing checkpoints on Claude...', 'info');
                                                        
                                                        try {
                                                            // Format checkpoints as instructions for Claude
                                                            const instructions = workspaceTask.checkpoints.map((checkpoint, index) => 
                                                                `### Checkpoint ${index + 1}: ${checkpoint.name}\n` +
                                                                `- Objective: ${checkpoint.objective || checkpoint.description}\n` +
                                                                `- Deliverables: ${checkpoint.deliverables || 'Complete the objective'}\n` +
                                                                `- Pass Criteria: ${checkpoint.passFail || checkpoint.passCriteria || 'Task completed successfully'}`
                                                            ).join('\n\n');
                                                            
                                                            const fullTask = `# CHECKPOINT EXECUTION REQUEST
                                                            
Execute each checkpoint in order, starting with Checkpoint 1.
Create all files in the working directory: /app/sessions/${workspaceTask.sessionId}/repo
After each checkpoint, run tests to verify it works.
Report results for each checkpoint.

${instructions}`;
                                                            
                                                            console.log('Sending task to Claude:', fullTask);
                                                            
                                                            // Send to Claude via Fly.io
                                                            const url = 'https://uncle-frank-claude.fly.dev/api/sessions/' + workspaceTask.sessionId + '/execute';
                                                            console.log('Sending to URL:', url);
                                                            
                                                            const response = await fetch(url, {
                                                                method: 'POST',
                                                                headers: { 'Content-Type': 'application/json' },
                                                                body: JSON.stringify({ 
                                                                    message: fullTask
                                                                })
                                                            });
                                                            
                                                            console.log('Response status:', response.status);
                                                            
                                                            if (response.ok) {
                                                                const result = await response.json();
                                                                console.log('Execution result:', result);
                                                                addLog('✅ Checkpoints sent to Claude for execution', 'success');
                                                                addLog(`📌 Session: ${workspaceTask.sessionId}`, 'info');
                                                                
                                                                // Auto-open terminal viewer
                                                                setTimeout(() => {
                                                                    openSessionViewer(workspaceTask.sessionId);
                                                                }, 1000);
                                                            } else {
                                                                const error = await response.text();
                                                                console.error('Execute failed:', error);
                                                                addLog(`❌ Failed to execute: ${error}`, 'error');
                                                                alert(`Failed to execute: ${error}`);
                                                            }
                                                        } catch (error) {
                                                            console.error('Execute error:', error);
                                                            addLog(`❌ Execution error: ${error.message}`, 'error');
                                                            alert(`Error: ${error.message}`);
                                                        }
                                                    }}
                                                >
                                                    ▶️ Execute Checkpoints
                                                </button>
                                                <button 
                                                    className="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded transition"
                                                    onClick={() => {
                                                        console.log('Pause task:', workspaceTask.id);
                                                    }}
                                                >
                                                    Pause Execution
                                                </button>
                                                <button 
                                                    className="px-4 py-2 bg-orange-600 hover:bg-orange-700 rounded transition"
                                                    onClick={async () => {
                                                        if (confirm('Restart this task with checkpoint decomposition?\n\nThis will close the current session and restart with proper checkpoints.')) {
                                                            addLog('🔄 Restarting task with checkpoint decomposition...', 'info');
                                                            
                                                            // CAPTURE CURRENT VALUES BEFORE ANY ASYNC OPERATIONS
                                                            const currentTask = { ...workspaceTask };
                                                            const taskId = currentTask.id;
                                                            const taskName = currentTask.objective || currentTask.name;
                                                            const oldSession = currentTask.sessionId || currentTask.threadId;
                                                            
                                                            // IMMEDIATELY mark session as restarting
                                                            setWorkspaceTask(prev => ({
                                                                ...prev,
                                                                sessionExpired: false,
                                                                justRestarted: false,
                                                                isRestarting: true,
                                                                sessionId: 'restarting...'
                                                            }));
                                                            
                                                            try {
                                                                if (oldSession) {
                                                                    addLog(`📝 Previous session: ${oldSession}`, 'info');
                                                                }
                                                                
                                                                addLog('🔄 Creating new Claude session...', 'info');
                                                                
                                                                // Create a new Claude session directly on Fly.io
                                                                const claudeResponse = await fetch('https://uncle-frank-claude.fly.dev/api/sessions', {
                                                                    method: 'POST',
                                                                    headers: { 'Content-Type': 'application/json' },
                                                                    body: JSON.stringify({
                                                                        repoUrl: 'https://github.com/bhuman-ai/unclefrank-bootstrap'
                                                                    })
                                                                });
                                                                
                                                                if (!claudeResponse.ok) {
                                                                    throw new Error('Failed to create Claude session');
                                                                }
                                                                
                                                                const session = await claudeResponse.json();
                                                                
                                                                // WAIT FOR SESSION TO BE READY (fix race condition)
                                                                addLog('⏳ Waiting for session to initialize...', 'info');
                                                                await new Promise(resolve => setTimeout(resolve, 2000));
                                                                
                                                                // Execute the task using CAPTURED values, not closure values
                                                                addLog(`📝 Sending task to Claude: "${taskName}"`, 'info');
                                                                
                                                                // CRITICAL: Tell Claude to decompose into checkpoints FIRST
                                                                const checkpointMessage = `# Task: ${taskName}

## CRITICAL: Follow the Sacred Flow

**FIRST, before doing ANY implementation:**
1. Break this task down into 3-5 specific checkpoints
2. Each checkpoint must have:
   - Clear objective
   - Specific deliverables
   - Pass/Fail criteria
   - Dependencies on other checkpoints

**Format your response as:**

### Checkpoint Decomposition

#### Checkpoint 1: [Name]
- Objective: [What to achieve]
- Deliverables: [What files/code to create]
- Pass Criteria: [How to verify success]
- Dependencies: None

#### Checkpoint 2: [Name]
- Objective: [What to achieve]
- Deliverables: [What files/code to create]
- Pass Criteria: [How to verify success]
- Dependencies: Checkpoint 1

[Continue for all checkpoints...]

### Execution Plan
[Describe how you'll execute these checkpoints]

**THEN proceed with Checkpoint 1 implementation.**

Original task description: ${taskName}`;
                                                                
                                                                const executeResponse = await fetch(`https://uncle-frank-claude.fly.dev/api/sessions/${session.sessionId}/execute`, {
                                                                    method: 'POST',
                                                                    headers: { 'Content-Type': 'application/json' },
                                                                    body: JSON.stringify({
                                                                        message: checkpointMessage
                                                                    })
                                                                });
                                                                
                                                                if (!executeResponse.ok) {
                                                                    const errorText = await executeResponse.text();
                                                                    addLog(`❌ Failed to execute task on Claude: ${errorText}`, 'error');
                                                                    throw new Error(`Execute failed: ${errorText}`);
                                                                }
                                                                
                                                                const result = await executeResponse.json();
                                                                
                                                                // ONLY UPDATE STATE AFTER VERIFICATION
                                                                addLog('✅ Task sent to Claude successfully!', 'success');
                                                                addLog(`📍 New Session: ${session.sessionId}`, 'info');
                                                                addLog(`🌿 Branch: ${session.branch}`, 'info');
                                                                
                                                                // Parse checkpoints from response if present
                                                                const checkpoints = [];
                                                                if (result.response) {
                                                                    // Look for checkpoint definitions in Claude's response
                                                                    const checkpointPattern = /#### Checkpoint (\d+): ([^\n]+)\n- Objective: ([^\n]+)\n- Deliverables: ([^\n]+)\n- Pass Criteria: ([^\n]+)/g;
                                                                    let match;
                                                                    while ((match = checkpointPattern.exec(result.response)) !== null) {
                                                                        checkpoints.push({
                                                                            number: parseInt(match[1]),
                                                                            name: match[2],
                                                                            objective: match[3],
                                                                            deliverables: match[4],
                                                                            passCriteria: match[5],
                                                                            status: 'pending'
                                                                        });
                                                                    }
                                                                    
                                                                    if (checkpoints.length > 0) {
                                                                        addLog(`🎯 Extracted ${checkpoints.length} checkpoints from Claude's response`, 'success');
                                                                    }
                                                                }
                                                                
                                                                // Show Claude's response (or indication it's processing)
                                                                if (result.response) {
                                                                    addLog(`🤖 Claude says: ${result.response.substring(0, 200)}...`, 'info');
                                                                } else {
                                                                    addLog(`⏳ Claude is processing the task...`, 'info');
                                                                }
                                                                
                                                                // VERIFY the task was actually executed
                                                                let executeSuccess = false;
                                                                try {
                                                                    addLog('🔍 Verifying task execution...', 'info');
                                                                    const verifyResponse = await fetch(`https://uncle-frank-claude.fly.dev/api/sessions/${session.sessionId}`);
                                                                    if (verifyResponse.ok) {
                                                                        const verifyData = await verifyResponse.json();
                                                                        executeSuccess = verifyData.messageCount > 0;
                                                                        addLog(`✅ Verified: ${verifyData.messageCount} messages in session`, 'success');
                                                                    }
                                                                } catch (e) {
                                                                    console.error('Failed to verify execution:', e);
                                                                    // If verification fails, assume success since execute didn't throw
                                                                    executeSuccess = true;
                                                                }
                                                                
                                                                if (!executeSuccess) {
                                                                    addLog('⚠️ Task execution could not be verified - keeping old session', 'warning');
                                                                    return;
                                                                }
                                                                    
                                                                    // Debug logging with CAPTURED values
                                                                    addLog(`🔍 DEBUG: Task ID = ${taskId}`, 'warning');
                                                                    addLog(`🔍 DEBUG: Old session = ${oldSession}`, 'warning');
                                                                    addLog(`🔍 DEBUG: New session = ${session.sessionId}`, 'warning');
                                                                    
                                                                    // Build session history
                                                                    const sessionHistory = currentTask.sessionHistory || [];
                                                                    if (oldSession && oldSession !== 'restarting...') {
                                                                        // Add old session to history if not already there
                                                                        if (!sessionHistory.find(s => s.id === oldSession)) {
                                                                            sessionHistory.push({
                                                                                id: oldSession,
                                                                                timestamp: new Date().toISOString(),
                                                                                reason: 'Restarted'
                                                                            });
                                                                        }
                                                                    }
                                                                    
                                                                    // UPDATE the workspace task with new session ID using CAPTURED values
                                                                    const updatedTask = {
                                                                        ...currentTask,  // Use captured task, not closure
                                                                        sessionId: session.sessionId,
                                                                        threadId: session.sessionId,
                                                                        branch: session.branch,
                                                                        status: 'In Progress',
                                                                        sessionExpired: false,
                                                                        justRestarted: true,
                                                                        isRestarting: false,  // Clear restarting flag
                                                                        oldSessionId: oldSession,  // Use captured old session
                                                                        sessionHistory: sessionHistory,  // Add session history
                                                                        checkpoints: checkpoints.length > 0 ? checkpoints : currentTask.checkpoints,  // Add checkpoints
                                                                        lastUpdated: Date.now()  // Force re-render
                                                                    };
                                                                    
                                                                    addLog(`🔍 DEBUG: Updating state with new session`, 'warning');
                                                                    
                                                                    // CRITICAL: UPDATE GITHUB ISSUE WITH NEW SESSION ID
                                                                    if (currentTask.issueNumber) {
                                                                        addLog(`📝 Updating GitHub issue #${currentTask.issueNumber} with new session...`, 'info');
                                                                        try {
                                                                            // Use gh CLI to update the issue
                                                                            const updateCmd = `gh issue edit ${currentTask.issueNumber} --repo bhuman-ai/unclefrank-bootstrap --body "$(gh issue view ${currentTask.issueNumber} --repo bhuman-ai/unclefrank-bootstrap --json body -q .body | sed 's/Claude Session: [a-f0-9-]*/Claude Session: ${session.sessionId}/g')"`;
                                                                            
                                                                            const updateResponse = await fetch('/api/github', {
                                                                                method: 'POST',
                                                                                headers: { 'Content-Type': 'application/json' },
                                                                                body: JSON.stringify({
                                                                                    action: 'update-issue-session',
                                                                                    issueNumber: currentTask.issueNumber,
                                                                                    newSessionId: session.sessionId,
                                                                                    oldSessionId: oldSession
                                                                                })
                                                                            });
                                                                            
                                                                            if (updateResponse.ok) {
                                                                                addLog(`✅ Updated GitHub issue #${currentTask.issueNumber} with new session`, 'success');
                                                                            } else {
                                                                                addLog(`⚠️ Failed to update GitHub issue #${currentTask.issueNumber}`, 'warning');
                                                                            }
                                                                        } catch (error) {
                                                                            console.error('Failed to update GitHub issue:', error);
                                                                            addLog(`⚠️ Could not update GitHub issue: ${error.message}`, 'warning');
                                                                        }
                                                                    } else {
                                                                        // Create a GitHub issue for this task if it doesn't have one
                                                                        addLog(`📝 Creating GitHub issue for task tracking...`, 'info');
                                                                        try {
                                                                            const issueResponse = await fetch('/api/github', {
                                                                                method: 'POST',
                                                                                headers: { 'Content-Type': 'application/json' },
                                                                                body: JSON.stringify({
                                                                                    endpoint: '/repos/bhuman-ai/unclefrank-bootstrap/issues',
                                                                                    method: 'POST',
                                                                                    body: {
                                                                                        title: `Task: ${taskName}`,
                                                                                        body: `## Task Details
- Name: ${taskName}
- Status: Restarted
- Claude Session: ${session.sessionId}
- Previous Session: ${oldSession || 'N/A'}

## Task Information
This task was restarted and is being tracked.

---
*Automatically created by Uncle Frank's Task Management System*`,
                                                                                        labels: ['task', 'auto-generated', 'restarted']
                                                                                    }
                                                                                })
                                                                            });
                                                                            
                                                                            if (issueResponse.ok) {
                                                                                const issueData = await issueResponse.json();
                                                                                updatedTask.issueNumber = issueData.number;
                                                                                updatedTask.issueUrl = issueData.html_url;
                                                                                addLog(`✅ Created GitHub issue #${issueData.number}`, 'success');
                                                                            } else {
                                                                                addLog(`⚠️ Failed to create GitHub issue - task won't persist`, 'warning');
                                                                            }
                                                                        } catch (error) {
                                                                            addLog(`⚠️ Could not create GitHub issue: ${error.message}`, 'warning');
                                                                        }
                                                                    }
                                                                    
                                                                    // CRITICAL: Force React to see this as a new object
                                                                    setWorkspaceTask(prev => {
                                                                        console.log('Previous workspace task:', prev);
                                                                        console.log('New updated task:', updatedTask);
                                                                        return updatedTask;
                                                                    });
                                                                    
                                                                    // Update state tasks using CAPTURED task ID
                                                                    setState(prev => ({
                                                                        ...prev,
                                                                        tasks: prev.tasks.map(t => 
                                                                            t.id === taskId  // Use captured ID, not closure
                                                                                ? { ...t, sessionId: session.sessionId, threadId: session.sessionId, status: 'In Progress' }
                                                                                : t
                                                                        )
                                                                    }));
                                                                    
                                                                    // Don't close the modal - user might want to view the new session
                                                                    addLog('📌 Task workspace updated with new session', 'success');
                                                                    
                                                                    // Force a re-render and update UI
                                                                    setTimeout(() => {
                                                                        addLog(`✨ Session updated to: ${session.sessionId.substring(0, 12)}...`, 'success');
                                                                        // Also update any global tracking of current session
                                                                        if (window.currentViewingSessionId === oldSession) {
                                                                            window.currentViewingSessionId = session.sessionId;
                                                                        }
                                                                        
                                                                        // FORCE UPDATE: Set a flag to trigger re-render
                                                                        setWorkspaceTask(prev => ({
                                                                            ...prev,
                                                                            sessionId: session.sessionId,
                                                                            threadId: session.sessionId,
                                                                            isRestarting: false,
                                                                            justRestarted: true,
                                                                            sessionExpired: false,
                                                                            lastUpdated: Date.now()
                                                                        }));
                                                                    }, 100);
                                                            } catch (error) {
                                                                addLog(`❌ Error restarting task: ${error.message}`, 'error');
                                                            }
                                                        }
                                                    }}
                                                >
                                                    🔄 Restart Task
                                                </button>
                                            </>
                                        )}
                                        {(workspaceTask.status === 'Awaiting Review' || 
                                          workspaceTask.status === 'Ready for Review' || 
                                          workspaceTask.status === 'AI Complete') && (
                                            <>
                                                <div className="bg-yellow-900 border border-yellow-600 rounded p-2 mr-2">
                                                    <span className="text-yellow-400 text-sm font-bold">
                                                        ⚠️ HUMAN REVIEW REQUIRED
                                                    </span>
                                                </div>
                                                <button 
                                                    className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition font-bold"
                                                    onClick={() => {
                                                        if (confirm('Are you a HUMAN approving this task as complete?')) {
                                                            console.log('Human approved task:', workspaceTask.id);
                                                            // Update task status to Human Approved
                                                        }
                                                    }}
                                                >
                                                    HUMAN APPROVE ✓
                                                </button>
                                                <button 
                                                    className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded transition"
                                                    onClick={() => {
                                                        const feedback = prompt('What changes are needed?');
                                                        if (feedback) {
                                                            console.log('Human requested changes:', workspaceTask.id, feedback);
                                                        }
                                                    }}
                                                >
                                                    Request Changes
                                                </button>
                                            </>
                                        )}
                                    </div>
                                    <button 
                                        onClick={() => {
                                            // Use the current workspaceTask state directly
                                            const currentSessionId = workspaceTask.sessionId || workspaceTask.threadId;
                                            
                                            if (currentSessionId) {
                                                addLog(`📂 Opening session viewer for: ${currentSessionId}`, 'info');
                                                addLog(`📌 Task ID: ${workspaceTask.id}`, 'info');
                                                setTaskWorkspaceOpen(false);
                                                openSessionViewer(currentSessionId);
                                            } else {
                                                addLog('⚠️ No session ID available for this task', 'warning');
                                            }
                                        }}
                                        className="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded transition"
                                    >
                                        🖥️ View Terminal
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Session Viewer Modal */}
                    {sessionViewerOpen && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-gray-900 rounded-lg p-6 max-w-4xl w-full max-h-[80vh] overflow-hidden flex flex-col">
                                <div className="flex justify-between items-center mb-4">
                                    <h3 className="text-xl font-semibold">
                                        Claude Session: {selectedSessionId}
                                    </h3>
                                    <button 
                                        onClick={() => setSessionViewerOpen(false)}
                                        className="text-gray-400 hover:text-white"
                                    >
                                        ✕
                                    </button>
                                </div>
                                
                                {loadingSession ? (
                                    <div className="text-center py-4">
                                        <div className="animate-spin h-8 w-8 border-b-2 border-white mx-auto"></div>
                                        <p className="text-gray-400 mt-2">Loading session messages...</p>
                                    </div>
                                ) : (
                                    <div className="overflow-y-auto flex-1 bg-gray-800 rounded p-4">
                                        {sessionMessages.length === 0 ? (
                                            <p className="text-gray-400">No messages found in this session.</p>
                                        ) : (
                                            <div className="space-y-4">
                                                {sessionMessages.map((msg, idx) => (
                                                    <div key={idx}>
                                                        {msg.role === 'terminal' ? (
                                                            <div className="font-mono text-sm text-gray-300 whitespace-pre-wrap">
                                                                {msg.content}
                                                            </div>
                                                        ) : (
                                                            <div className="border-b border-gray-700 pb-4">
                                                                <div className="flex items-center gap-2 mb-2">
                                                                    <span className={`px-2 py-1 rounded text-xs ${
                                                                        msg.role === 'user' ? 'bg-blue-600' : 'bg-green-600'
                                                                    }`}>
                                                                        {msg.role}
                                                                    </span>
                                                                    <span className="text-gray-500 text-xs">
                                                                        {new Date(msg.timestamp).toLocaleString()}
                                                                    </span>
                                                                </div>
                                                                <div className="text-gray-300 whitespace-pre-wrap">
                                                                    {msg.content}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                <div className="mt-4 flex justify-end">
                                    <button 
                                        onClick={async () => {
                                            addLog('🔄 Refreshing terminal output...', 'info');
                                            const output = await fetchTerminalOutput(selectedSessionId);
                                            setSessionMessages([{
                                                role: 'terminal',
                                                content: output,
                                                timestamp: new Date().toISOString()
                                            }]);
                                        }}
                                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 mr-2"
                                    >
                                        🔄 Refresh
                                    </button>
                                    <button 
                                        onClick={() => setSessionViewerOpen(false)}
                                        className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>