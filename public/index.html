<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncle Frank's Bootstrap Core</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/diff-match-patch@1.0.5/index.js"></script>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // FRANK'S ORCHESTRATOR INTEGRATION
        async function registerWithOrchestrator(instanceId, metadata) {
            try {
                const response = await fetch('/api/task-orchestrator', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'register',
                        instanceId,
                        metadata
                    })
                });
                
                if (response.ok) {
                    console.log(`[Orchestrator] Registered ${metadata.type} instance: ${instanceId}`);
                }
            } catch (error) {
                console.error('[Orchestrator] Registration failed:', error);
            }
        }
        
        // Orchestrator Status Component
        function OrchestratorStatus() {
            const [orchestratorData, setOrchestratorData] = useState(null);
            
            useEffect(() => {
                const pollOrchestrator = async () => {
                    try {
                        const response = await fetch('/api/task-orchestrator', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'poll' })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            setOrchestratorData(result);
                        }
                    } catch (error) {
                        console.error('[Orchestrator] Polling failed:', error);
                    }
                };
                
                // Poll immediately and then every 5 seconds
                pollOrchestrator();
                const interval = setInterval(pollOrchestrator, 5000);
                
                return () => clearInterval(interval);
            }, []);
            
            if (!orchestratorData) return null;
            
            const activeCount = orchestratorData.instances.filter(i => i.status === 'active').length;
            
            return (
                <div className="fixed top-4 right-4 bg-gray-800 border border-gray-700 rounded-lg p-4 w-64 shadow-lg z-50">
                    <h3 className="text-purple-400 font-semibold mb-3 flex items-center">
                        <span className="text-xl mr-2">🧠</span> Task Orchestrator
                    </h3>
                    <div className="space-y-2 text-sm">
                        <p className="text-gray-400">
                            Active: <span className="text-white">{activeCount}</span>
                        </p>
                        <p className="text-gray-400">
                            Total: <span className="text-white">{orchestratorData.instanceCount}</span>
                        </p>
                        
                        {orchestratorData.instances.length > 0 && (
                            <div className="mt-3 pt-3 border-t border-gray-700">
                                <p className="text-gray-500 text-xs mb-2">Instances:</p>
                                {orchestratorData.instances.slice(0, 5).map((inst, idx) => {
                                    const emoji = inst.type === 'main-task' ? '📋' : 
                                                 inst.type === 'test' ? '🧪' : 
                                                 inst.type === 'resolver' ? '🔧' : '📦';
                                    const statusColor = inst.status === 'active' ? 'text-green-400' : 
                                                       inst.status === 'completed' ? 'text-blue-400' : 
                                                       inst.status === 'failed' ? 'text-red-400' : 'text-gray-400';
                                    
                                    return (
                                        <div key={idx} className="text-xs ml-2 flex items-center space-x-2">
                                            <span>{emoji}</span>
                                            <span className="text-gray-300">{inst.type}:</span>
                                            <span className={statusColor}>{inst.status}</span>
                                        </div>
                                    );
                                })}
                                {orchestratorData.instances.length > 5 && (
                                    <p className="text-gray-500 text-xs mt-1 ml-2">+{orchestratorData.instances.length - 5} more</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }
        
        // GitHub API Service
        const GitHubService = {
            baseUrl: 'https://api.github.com',
            owner: 'bhuman-ai',
            repo: 'unclefrank-bootstrap',

            async getBranches() {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/branches`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch branches:', error);
                    return [];
                }
            },

            async getBranchDetails(branchName) {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/branches/${branchName}`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch branch details:', error);
                    return null;
                }
            },

            async getCommitDiff(baseBranch = 'master', headBranch) {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                    return null;
                }
            },

            async createPullRequest(title, body, headBranch, baseBranch = 'master') {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/pulls`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            // Note: In production, you'd need proper authentication
                        },
                        body: JSON.stringify({
                            title,
                            body,
                            head: headBranch,
                            base: baseBranch
                        })
                    });
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to create PR:', error);
                    return null;
                }
            },

            getCompareUrl(baseBranch = 'master', headBranch) {
                return `https://github.com/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`;
            },

            getBranchUrl(branchName) {
                return `https://github.com/${this.owner}/${this.repo}/tree/${branchName}`;
            }
        };

        // Review Actions Component
        const ReviewActions = ({ task, onViewChanges, onRunTests, onApprove, onRequestChanges }) => {
            const [testStatus, setTestStatus] = useState(null);
            const [loading, setLoading] = useState(false);

            const handleRunTests = async () => {
                setLoading(true);
                setTestStatus('running');
                
                try {
                    // FRANK'S REAL TEST EXECUTION - NO SIMULATIONS
                    setTestStatus('running');
                    addLog(`Running real tests for ${task.name}...`, 'info');
                    
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            task: task,
                            criteria: task.acceptanceCriteria || 'Task completion validation',
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (testResponse.ok) {
                        const testData = await testResponse.json();
                        const status = testData.passed ? 'passed' : 'failed';
                        setTestStatus(status);
                        addLog(`Test result: ${status.toUpperCase()} - ${testData.details}`, 
                               status === 'passed' ? 'success' : 'error');
                        if (status === 'passed') onRunTests(task);
                    } else {
                        setTestStatus('failed');
                        addLog('Test execution failed', 'error');
                    }
                } catch (error) {
                    setTestStatus('failed');
                    addLog(`Test error: ${error.message}`, 'error');
                } finally {
                    setLoading(false);
                }
            };

            const getTestStatusColor = () => {
                switch (testStatus) {
                    case 'running': return 'bg-blue-600';
                    case 'passed': return 'bg-green-600';
                    case 'failed': return 'bg-red-600';
                    default: return 'bg-gray-600';
                }
            };

            return (
                <div className="flex gap-1">
                    <button 
                        onClick={() => onViewChanges(task)}
                        className="px-2 py-1 bg-gray-600 hover:bg-gray-700 rounded text-xs transition"
                    >
                        View Changes
                    </button>
                    <button 
                        onClick={handleRunTests}
                        disabled={loading}
                        className={`px-2 py-1 rounded text-xs transition ${getTestStatusColor()} hover:opacity-80 disabled:opacity-50`}
                    >
                        {loading ? 'Running...' : testStatus === 'passed' ? '✓ Tests' : testStatus === 'failed' ? '✗ Tests' : 'Run Tests'}
                    </button>
                    <button 
                        onClick={() => onApprove(task)}
                        className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-xs transition"
                    >
                        {task.prUrl ? 'Open PR' : 'Create PR'}
                    </button>
                    <button 
                        onClick={() => onRequestChanges(task)}
                        className="px-2 py-1 bg-orange-600 hover:bg-orange-700 rounded text-xs transition"
                    >
                        Request Changes
                    </button>
                </div>
            );
        };

        // Diff Viewer Component
        const DiffViewer = ({ isOpen, onClose, task, diffData }) => {
            const [loading, setLoading] = useState(false);
            const [files, setFiles] = useState([]);

            useEffect(() => {
                if (isOpen && task && task.branch) {
                    fetchDiffData();
                }
            }, [isOpen, task]);

            const fetchDiffData = async () => {
                setLoading(true);
                try {
                    const diff = await GitHubService.getCommitDiff('master', task.branch);
                    if (diff && diff.files) {
                        setFiles(diff.files);
                    }
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                } finally {
                    setLoading(false);
                }
            };

            const renderDiffLines = (patch) => {
                if (!patch) return null;
                
                const lines = patch.split('\n');
                return lines.map((line, index) => {
                    let className = 'font-mono text-sm px-4 py-1 ';
                    if (line.startsWith('+')) {
                        className += 'bg-green-900 text-green-200';
                    } else if (line.startsWith('-')) {
                        className += 'bg-red-900 text-red-200';
                    } else if (line.startsWith('@@')) {
                        className += 'bg-blue-900 text-blue-200 font-semibold';
                    } else {
                        className += 'bg-gray-800 text-gray-300';
                    }
                    
                    return (
                        <div key={index} className={className}>
                            {line || ' '}
                        </div>
                    );
                });
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-gray-800 rounded-lg max-w-6xl max-h-[90vh] w-full mx-4 flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h2 className="text-xl font-semibold">
                                Changes for: {task?.name}
                            </h2>
                            <button 
                                onClick={onClose}
                                className="text-gray-400 hover:text-white text-2xl"
                            >
                                ×
                            </button>
                        </div>
                        
                        <div className="flex-1 overflow-auto p-4">
                            {loading ? (
                                <div className="text-center py-8">
                                    <div className="text-blue-400">Loading diff...</div>
                                </div>
                            ) : files.length > 0 ? (
                                <div className="space-y-6">
                                    {files.map((file, index) => (
                                        <div key={index} className="border border-gray-700 rounded">
                                            <div className="bg-gray-700 px-4 py-2 font-mono text-sm">
                                                <span className="text-gray-300">{file.filename}</span>
                                                <span className="ml-4 text-green-400">+{file.additions}</span>
                                                <span className="ml-2 text-red-400">-{file.deletions}</span>
                                            </div>
                                            <div className="max-h-96 overflow-auto">
                                                {renderDiffLines(file.patch)}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="text-center py-8">
                                    <div className="text-gray-500">No changes found</div>
                                    <a 
                                        href={GitHubService.getCompareUrl('master', task?.branch)}
                                        target="_blank"
                                        className="text-blue-400 hover:underline mt-2 inline-block"
                                    >
                                        View on GitHub →
                                    </a>
                                </div>
                            )}
                        </div>
                        
                        <div className="p-4 border-t border-gray-700 flex justify-end gap-2">
                            <button 
                                onClick={onClose}
                                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
                            >
                                Close
                            </button>
                            <a 
                                href={GitHubService.getCompareUrl('master', task?.branch)}
                                target="_blank"
                                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
                            >
                                View on GitHub
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // Task Queue Component
        const TaskQueue = ({ tasks, onUpdateTaskStatus, onViewChanges, onRunTests, onApprove, onRequestChanges }) => {
            const [filter, setFilter] = useState('Awaiting Review');
            
            const filteredTasks = tasks.filter(task => 
                !filter || task.status === filter
            );

            const StatusBadge = ({ status }) => {
                const colors = {
                    'Awaiting Review': 'bg-yellow-600',
                    'In Review': 'bg-blue-600',
                    'Approved': 'bg-green-600',
                    'Changes Requested': 'bg-red-600',
                    'Merged': 'bg-purple-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status}
                    </span>
                );
            };

            return (
                <div className="bg-gray-800 rounded-lg p-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-xl font-semibold">Task Queue</h2>
                        <div className="flex gap-2">
                            <button 
                                onClick={() => window.location.reload()}
                                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                            >
                                Refresh from GitHub
                            </button>
                            <select 
                                value={filter}
                                onChange={(e) => setFilter(e.target.value)}
                                className="px-3 py-1 bg-gray-700 rounded border border-gray-600 text-sm"
                            >
                                <option value="">All Tasks</option>
                                <option value="Awaiting Review">Awaiting Review</option>
                                <option value="In Review">In Review</option>
                                <option value="Approved">Approved</option>
                                <option value="Changes Requested">Changes Requested</option>
                                <option value="Merged">Merged</option>
                            </select>
                        </div>
                    </div>
                    
                    <div className="overflow-x-auto">
                        <table className="w-full text-sm">
                            <thead>
                                <tr className="border-b border-gray-700">
                                    <th className="text-left py-2 px-3">Task Name</th>
                                    <th className="text-left py-2 px-3">Status</th>
                                    <th className="text-left py-2 px-3">Branch</th>
                                    <th className="text-left py-2 px-3">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {filteredTasks.map(task => (
                                    <tr key={task.id} className="border-b border-gray-700 hover:bg-gray-750">
                                        <td className="py-3 px-3">
                                            <div>
                                                <div className="font-medium">{task.name}</div>
                                                <div className="text-xs text-gray-400">{task.objective}</div>
                                            </div>
                                        </td>
                                        <td className="py-3 px-3">
                                            <StatusBadge status={task.status} />
                                        </td>
                                        <td className="py-3 px-3">
                                            <div className="space-y-1">
                                                {task.branch ? (
                                                    <a 
                                                        href={GitHubService.getBranchUrl(task.branch)}
                                                        target="_blank"
                                                        className="text-blue-400 hover:underline text-xs block"
                                                    >
                                                        {task.branch}
                                                    </a>
                                                ) : (
                                                    <span className="text-gray-500 text-xs">No branch</span>
                                                )}
                                                {task.prUrl && (
                                                    <a 
                                                        href={task.prUrl}
                                                        target="_blank"
                                                        className="text-green-400 hover:underline text-xs block"
                                                    >
                                                        View PR →
                                                    </a>
                                                )}
                                            </div>
                                        </td>
                                        <td className="py-3 px-3">
                                            <ReviewActions 
                                                task={task}
                                                onViewChanges={onViewChanges}
                                                onRunTests={onRunTests}
                                                onApprove={onApprove}
                                                onRequestChanges={onRequestChanges}
                                            />
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                        {filteredTasks.length === 0 && (
                            <div className="text-center py-8 text-gray-500">
                                No tasks found with status "{filter}"
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // State management
        const initialState = {
            request: 'Implement Task Review UI that shows completed tasks awaiting human review with GitHub integration. This must include: 1) Task Queue view showing tasks with "Awaiting Review" status after Terragon completes them, 2) Display the GitHub branch created by Terragon, 3) Show acceptance criteria as a review checklist, 4) Provide View Changes, Run Tests, Approve, and Request Changes buttons, 5) Integration with GitHub API to detect branches and create PRs, 6) Merge Review Screen showing diffs, 7) Update task status from "sent" through "completed", "awaiting review", to "merged"',
            projectContext: `# Current State
The system can execute tasks in Terragon, which creates GitHub branches, but there's no UI to review and approve these completed tasks. According to Interface.md, we need screens #3 (Task Queue), #7 (Merge Review), #9 (GitHub Integration), and #15 (Escalation Notifications).

# Requirements from Interface.md
- Task Queue must show task status management
- Merge Review Screen must show Draft vs Production diff viewer  
- GitHub Integration Panel must show repo browser and PR statuses
- System must enforce the immutable flow - no bypassing allowed
- Every action must have immediate feedback

# Technical Context
- Tasks are executed in Terragon and push to branches like "terragon/project-md-validation-system"
- System uses GitHub API for integration
- React-based UI in public/index.html
- Task state is managed in React component state`,
            task: null,
            checkpoints: [],
            executionStatus: {},
            sessionId: null,
            logs: [],
            activeThreads: {}, // Track thread IDs for each checkpoint
            taskThreadId: null, // One thread per task
            checkpointQueue: [], // Queue of checkpoints to execute
            currentCheckpointIndex: 0, // Current position in queue
            reviewTasks: [
                {
                    id: 'task-1',
                    name: 'Task Review UI Implementation',
                    objective: 'Build review interface for completed Terragon tasks with GitHub integration',
                    status: 'Awaiting Review',
                    branch: 'terragon/task-review-ui-github-integration',
                    threadId: 'thread-123',
                    acceptanceCriteria: [
                        'Task Queue component renders without errors',
                        'GitHub API integration works correctly',
                        'Review actions update task status',
                        'PR creation flow functions properly'
                    ]
                },
                {
                    id: 'task-2',
                    name: 'Discord Bot Integration',
                    objective: 'Add Discord bot for task notifications',
                    status: 'In Review',
                    branch: 'terragon/discord-bot-integration',
                    threadId: 'thread-456',
                    acceptanceCriteria: [
                        'Bot connects to Discord successfully',
                        'Notifications sent on task completion'
                    ]
                }
            ]
        };

        function App() {
            const [state, setState] = useState(initialState);
            const [loading, setLoading] = useState(false);
            const [loadingTasks, setLoadingTasks] = useState(true);
            const [executing, setExecuting] = useState(false);
            const [diffViewerOpen, setDiffViewerOpen] = useState(false);
            const [selectedTask, setSelectedTask] = useState(null);
            const executionInterval = useRef(null);

            const API_URL = '/api/task';
            const EXECUTE_URL = '/api/execute';

            // Load tasks from GitHub PRs on component mount
            useEffect(() => {
                loadTasksFromGitHub();
            }, []);

            // Load tasks by checking GitHub PR status
            const loadTasksFromGitHub = async () => {
                setLoadingTasks(true);
                addLog('Loading task status from GitHub PRs...', 'info');
                
                try {
                    // Get list of branches that match terragon pattern
                    const branches = await GitHubService.getBranches();
                    const terragonBranches = branches.filter(branch => 
                        branch.name.startsWith('terragon/')
                    );
                    
                    const updatedTasks = [];
                    
                    for (const branch of terragonBranches) {
                        try {
                            // Check if PR exists for this branch
                            const response = await fetch(`https://api.github.com/repos/bhuman-ai/unclefrank-bootstrap/pulls?head=bhuman-ai:${branch.name}&state=all`);
                            const prs = await response.json();
                            
                            let status = 'Awaiting Review'; // Default if no PR
                            let prUrl = null;
                            
                            if (prs && prs.length > 0) {
                                const pr = prs[0]; // Get most recent PR for this branch
                                prUrl = pr.html_url;
                                
                                if (pr.state === 'open') {
                                    // Check if changes are requested
                                    const reviewsResponse = await fetch(`https://api.github.com/repos/bhuman-ai/unclefrank-bootstrap/pulls/${pr.number}/reviews`);
                                    const reviews = await reviewsResponse.json();
                                    const hasRequestedChanges = reviews && reviews.some(review => review.state === 'CHANGES_REQUESTED');
                                    
                                    status = hasRequestedChanges ? 'Changes Requested' : 'In Review';
                                } else if (pr.merged) {
                                    status = 'Merged';
                                } else if (pr.state === 'closed') {
                                    status = 'Approved';
                                }
                            }
                            
                            // Create task object from branch info
                            const taskName = branch.name.replace('terragon/', '').replace(/-/g, ' ')
                                .replace(/\b\w/g, l => l.toUpperCase());
                            
                            updatedTasks.push({
                                id: `task-${branch.name}`,
                                name: taskName,
                                objective: `Implementation of ${taskName}`,
                                status: status,
                                branch: branch.name,
                                threadId: `thread-${branch.name}`,
                                prUrl: prUrl,
                                acceptanceCriteria: [
                                    'Implementation completed successfully',
                                    'Tests pass',
                                    'Code review approved'
                                ]
                            });
                            
                        } catch (error) {
                            console.error(`Error checking PR for branch ${branch.name}:`, error);
                        }
                    }
                    
                    // Update state with GitHub-sourced tasks
                    setState(prev => ({
                        ...prev,
                        reviewTasks: updatedTasks
                    }));
                    
                    addLog(`Loaded ${updatedTasks.length} tasks from GitHub`, 'success');
                    
                } catch (error) {
                    addLog(`Failed to load tasks from GitHub: ${error.message}`, 'error');
                    // FRANK'S RULE: NO FALLBACKS - FAIL FAST AND HONEST
                    addLog('System requires GitHub integration to function. Fix the connection.', 'error');
                    setTasks([]);
                }
                
                setLoadingTasks(false);
            };

            // Add log entry
            const addLog = (message, level = 'info') => {
                setState(prev => ({
                    ...prev,
                    logs: [...prev.logs, {
                        timestamp: new Date().toLocaleTimeString(),
                        message,
                        level
                    }]
                }));
            };

            // Classify request
            const classifyRequest = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('Classifying request...', 'info');
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'classify', request: state.request })
                    });
                    
                    const data = await response.json();
                    if (response.ok) {
                        addLog(`Classification: ${data.classification.type} (${(data.classification.confidence * 100).toFixed(0)}%)`, 'success');
                    } else {
                        addLog(data.error || 'Classification failed', 'error');
                    }
                } catch (error) {
                    addLog(error.message, 'error');
                }
                setLoading(false);
            };

            // Decompose task
            const decomposeTask = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('Decomposing task into checkpoints...', 'info');
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'decompose', 
                            request: state.request, 
                            projectContext: state.projectContext 
                        })
                    });
                    
                    const data = await response.json();
                    if (response.ok) {
                        setState(prev => ({
                            ...prev,
                            task: data.task,
                            checkpoints: data.checkpoints,
                            executionStatus: data.checkpoints.reduce((acc, cp) => ({
                                ...acc,
                                [cp.id]: { status: 'pending', logs: [] }
                            }), {})
                        }));
                        addLog(`Task decomposed into ${data.checkpoints.length} checkpoints`, 'success');
                    } else {
                        addLog(data.error || 'Decomposition failed', 'error');
                    }
                } catch (error) {
                    addLog(error.message, 'error');
                }
                setLoading(false);
            };

            // Execute checkpoints sequentially
            const executeCheckpointsSequentially = async () => {
                if (!state.checkpoints.length || !state.task) {
                    alert('No checkpoints to execute');
                    return;
                }
                
                setExecuting(true);
                addLog('Starting sequential checkpoint execution with Pass/Fail testing...', 'info');
                
                try {
                    // FRANK'S FIX: Send ONLY the first checkpoint, not context dump
                    const firstCheckpoint = state.checkpoints[0];
                    if (!firstCheckpoint) {
                        throw new Error('No checkpoints found to execute');
                    }
                    
                    const firstCheckpointMessage = `# CHECKPOINT 1: ${firstCheckpoint.name}

## Objective
${firstCheckpoint.objective}

## Task Context
${state.task.name}: ${state.task.objective}

## Blocking Status
${firstCheckpoint.blocking ? '🚫 BLOCKING - Must pass before continuing' : '⚡ NON-BLOCKING - Can fail without halting'}

## Instructions
${firstCheckpoint.instructions.map((inst, j) => `${j + 1}. ${inst}`).join('\n')}

## Pass Criteria (Must verify ALL):
${firstCheckpoint.passCriteria.map((pc, i) => `✓ ${i + 1}. ${pc.description}`).join('\n')}

Execute this checkpoint and report when complete. After completion, I will run tests to verify all pass criteria before proceeding to the next checkpoint.

SACRED FLOW: This is checkpoint 1 of ${state.checkpoints.length}. Each checkpoint will be sent individually after the previous one passes its tests.`;

                    // Create Terragon thread with FIRST CHECKPOINT ONLY
                    const dashboardPayload = [{
                        message: {
                            type: 'user',
                            model: 'sonnet',
                            parts: [{
                                type: 'rich-text',
                                nodes: [{
                                    type: 'text',
                                    text: firstCheckpointMessage
                                }]
                            }],
                            timestamp: new Date().toISOString()
                        },
                        githubRepoFullName: 'bhuman-ai/unclefrank-bootstrap',
                        repoBaseBranchName: 'master',
                        saveAsDraft: false
                    }];

                    const response = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'create-task',
                            payload: dashboardPayload
                        })
                    });
                    
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `Failed to create Terragon task: ${response.status}`);
                    }
                    
                    const threadId = result.threadId;
                    const threadUrl = `https://www.terragonlabs.com/task/${threadId}`;
                    
                    addLog(`✅ Checkpoint 1 sent to Terragon thread: ${threadId}`, 'success');
                    addLog(`Monitor at: ${threadUrl}`, 'info');
                    
                    // Register main task with orchestrator
                    await registerWithOrchestrator(threadId, {
                        type: 'main-task',
                        task: dashboardPayload[0].message.parts[0].nodes[0].text,
                        branch: 'master'
                    });
                    
                    // Initialize state - mark checkpoint 1 as executing (since we just sent it)
                    setState(prev => {
                        const firstCheckpoint = prev.checkpoints[0];
                        const newExecutionStatus = {
                            [firstCheckpoint.id]: {
                                status: 'executing',
                                threadId: threadId,
                                startTime: new Date().toISOString(),
                                logs: [{ 
                                    message: `Checkpoint 1 sent to Terragon`,
                                    url: threadUrl
                                }]
                            }
                        };
                        
                        const newState = { 
                            ...prev, 
                            sessionId: threadId,
                            taskThreadId: threadId,
                            checkpointQueue: [...prev.checkpoints],
                            currentCheckpointIndex: 0,
                            executionStatus: newExecutionStatus
                        };
                        
                        // FRANK'S REAL FIX: Poll Terragon until actual completion
                        setTimeout(() => {
                            addLog('🔍 Polling Terragon thread for actual completion...', 'info');
                            // CRITICAL: Pass threadId as executionThreadId since we're using the same thread
                            pollTerragonForCompletion(threadId, firstCheckpoint, newState.checkpointQueue, 0, 0, threadId);
                        }, 5000); // Give it 5 seconds to start, then poll
                        
                        return newState;
                    });
                    
                } catch (error) {
                    addLog(`Execution error: ${error.message}`, 'error');
                    setExecuting(false);
                }
            };

            // FRANK'S UI-BASED COMPLETION DETECTION - TRACK UI INDICATORS
            const messageTracker = {}; // Store message state per thread
            
            const pollTerragonForCompletion = async (threadId, checkpoint, queue, currentIndex, pollCount = 0, executionThreadId = null) => {
                const maxPolls = 120; // Max 10 minutes of polling (5 seconds * 120)
                const minPolls = 36; // FRANK'S FIX: Minimum 3 minutes before allowing tests
                const checkpointNumber = currentIndex + 1;
                
                // Initialize tracker for this thread if needed
                if (!messageTracker[threadId]) {
                    messageTracker[threadId] = {
                        lastMessageCount: 0,
                        lastMessageTime: Date.now(),
                        uiQuietCount: 0, // Track polls without UI activity
                        startTime: Date.now() // Track when polling started
                    };
                }
                
                addLog(`🔄 Polling attempt ${pollCount + 1}: Checking if Terragon completed checkpoint ${checkpointNumber}`, 'info');
                
                try {
                    // Check Terragon thread status via our API
                    const statusResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'check-terragon-status',
                            threadId: threadId,
                            lastMessageCount: messageTracker[threadId].lastMessageCount,
                            lastMessageTime: messageTracker[threadId].lastMessageTime
                        })
                    });
                    
                    if (statusResponse.ok) {
                        const statusResult = await statusResponse.json();
                        
                        // FRANK'S FIX: Auto-record branch from API response
                        if (statusResult.terragonBranch && !messageTracker[threadId].branchRecorded) {
                            // Record for the task thread ID
                            await fetch('/api/branch-tracker', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'record',
                                    threadId: threadId,
                                    branchName: statusResult.terragonBranch
                                })
                            });
                            
                            // FRANK'S CRITICAL FIX: Also record for execution thread ID
                            // Tests use executionThreadId, not threadId!
                            if (executionThreadId && executionThreadId !== threadId) {
                                await fetch('/api/branch-tracker', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        action: 'record',
                                        threadId: executionThreadId,
                                        branchName: statusResult.terragonBranch
                                    })
                                });
                                console.log(`Also recorded branch for execution thread: ${executionThreadId}`);
                            }
                            
                            messageTracker[threadId].branchRecorded = true;
                            addLog(`🎯 Detected Terragon branch: ${statusResult.terragonBranch}`, 'success');
                            
                            // FRANK'S FIX: Save branch to state for tests to use
                            setState(prev => ({
                                ...prev,
                                currentBranch: statusResult.terragonBranch
                            }));
                            
                            // FRANK'S BACKUP: Also save to window for persistence
                            window.lastDetectedBranch = statusResult.terragonBranch;
                        }
                        
                        // Update message tracker
                        if (statusResult.messageCount !== undefined) {
                            if (statusResult.messageCount > messageTracker[threadId].lastMessageCount) {
                                // New messages detected
                                addLog(`📝 New message detected (${statusResult.messageCount} total messages)`, 'info');
                                messageTracker[threadId].lastMessageCount = statusResult.messageCount;
                                messageTracker[threadId].lastMessageTime = statusResult.lastMessageTime;
                                
                                // Try to detect branch from message
                                if (statusResult.lastResponse) {
                                    try {
                                        const branchExtract = await fetch('/api/branch-tracker', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({
                                                action: 'extract',
                                                message: statusResult.lastResponse
                                            })
                                        });
                                        
                                        if (branchExtract.ok) {
                                            const branchData = await branchExtract.json();
                                            if (branchData.branch) {
                                                // Record the branch for this thread
                                                await fetch('/api/branch-tracker', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({
                                                        action: 'record',
                                                        threadId: threadId,
                                                        branchName: branchData.branch
                                                    })
                                                });
                                                addLog(`🔍 Detected branch: ${branchData.branch}`, 'info');
                                            }
                                        }
                                    } catch (e) {
                                        console.error('Branch extraction failed:', e);
                                    }
                                }
                                
                            }
                        }
                        
                        // Status-based updates
                        if (statusResult.status === 'starting') {
                            addLog(`⏳ Terragon is starting up...`, 'info');
                        } else if (statusResult.status === 'checkpointing') {
                            addLog(`💾 Terragon is creating a checkpoint...`, 'info');
                        }
                        
                        if (statusResult.completed && statusResult.status === 'completed') {
                            // FRANK'S TIMING CHECK: Don't trust completion too early
                            const elapsedTime = Date.now() - messageTracker[threadId].startTime;
                            const elapsedMinutes = Math.floor(elapsedTime / 60000);
                            
                            if (pollCount < minPolls) {
                                addLog(`⚠️ Terragon marked complete but only ${elapsedMinutes} minutes elapsed. Minimum 3 minutes required.`, 'warning');
                                addLog(`⏳ Continuing to poll (${pollCount}/${minPolls} minimum attempts)...`, 'info');
                                setTimeout(() => {
                                    pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                                }, 5000);
                                return;
                            }
                            
                            addLog(`✅ Terragon marked as completed after ${elapsedMinutes} minutes!`, 'success');
                            
                            // FRANK'S REAL FIX: Wait for API sync before trusting completion
                            addLog(`⏳ Waiting 30s for Terragon API to sync full response...`, 'info');
                            await new Promise(resolve => setTimeout(resolve, 30000));
                            
                            // FRANK'S ATOMIC VERIFICATION: Get consistent state snapshot
                            let verificationPassed = false;
                            const maxVerifyAttempts = 3;
                            
                            for (let verifyAttempt = 0; verifyAttempt < maxVerifyAttempts; verifyAttempt++) {
                                const verifyResponse = await fetch('/api/execute', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ 
                                        action: 'check-terragon-status',
                                        threadId: threadId
                                    })
                                });
                                
                                if (verifyResponse.ok) {
                                    const snapshot = await verifyResponse.json();
                                    
                                    // Wait 5 seconds and check again for stability
                                    await new Promise(resolve => setTimeout(resolve, 5000));
                                    
                                    const verifyResponse2 = await fetch('/api/execute', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ 
                                            action: 'check-terragon-status',
                                            threadId: threadId
                                        })
                                    });
                                    
                                    if (verifyResponse2.ok) {
                                        const snapshot2 = await verifyResponse2.json();
                                        
                                        // FRANK'S ATOMIC CHECK: State must be stable across two snapshots
                                        const stateStable = snapshot.status === snapshot2.status &&
                                                          snapshot.completed === snapshot2.completed &&
                                                          snapshot.messageCount === snapshot2.messageCount;
                                        
                                        const isCompleted = snapshot2.completed && snapshot2.status === 'completed';
                                        
                                        if (stateStable && isCompleted) {
                                            addLog(`✅ Verification attempt ${verifyAttempt + 1}: State stable and completed`, 'success');
                                            verificationPassed = true;
                                            break;
                                        } else {
                                            addLog(`⚠️ Verification attempt ${verifyAttempt + 1} failed:`, 'warning');
                                            addLog(`  - State stable: ${stateStable}`, 'warning');
                                            addLog(`  - Completed: ${isCompleted}`, 'warning');
                                            addLog(`  - Status: ${snapshot2.status}`, 'warning');
                                            addLog(`  - Message count: ${snapshot.messageCount} → ${snapshot2.messageCount}`, 'warning');
                                        }
                                    }
                                }
                                
                                if (verifyAttempt < maxVerifyAttempts - 1) {
                                    addLog(`⏳ Waiting 10s before next verification attempt...`, 'info');
                                    await new Promise(resolve => setTimeout(resolve, 10000));
                                }
                            }
                            
                            if (!verificationPassed) {
                                addLog(`❌ Terragon verification failed after ${maxVerifyAttempts} attempts`, 'error');
                                addLog(`Continuing to poll...`, 'info');
                                setTimeout(() => {
                                    pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                                }, 5000);
                                return;
                            }
                            
                            addLog(`✅ Terragon completion verified after sync!`, 'success');
                            
                            // Wait for Terragon to push changes before testing
                            addLog(`⏳ Waiting for Terragon to push changes...`, 'info');
                            
                            // Poll for branch push confirmation (check if branch exists on GitHub)
                            const waitForPush = async (branchName, maxAttempts = 24) => {
                                let rateLimitHits = 0;
                                for (let i = 0; i < maxAttempts; i++) {
                                    try {
                                        // Check if branch exists on GitHub
                                        const checkResponse = await fetch(`https://api.github.com/repos/bhuman-ai/unclefrank-bootstrap/branches/${branchName}`, {
                                            headers: {
                                                'Accept': 'application/vnd.github.v3+json'
                                            }
                                        });
                                        
                                        if (checkResponse.ok) {
                                            // FRANK'S PARANOID CHECK: Verify branch has actual commits
                                            const branchData = await checkResponse.json();
                                            if (branchData.commit && branchData.commit.sha) {
                                                addLog(`✅ Branch ${branchName} pushed to GitHub with commit ${branchData.commit.sha.substring(0, 7)}!`, 'success');
                                                return true;
                                            } else {
                                                addLog(`⚠️ Branch ${branchName} exists but has no commits`, 'warning');
                                            }
                                        } else if (checkResponse.status === 403) {
                                            // GitHub rate limit hit
                                            rateLimitHits++;
                                            const rateLimitRemaining = checkResponse.headers.get('X-RateLimit-Remaining');
                                            const rateLimitReset = checkResponse.headers.get('X-RateLimit-Reset');
                                            addLog(`⚠️ GitHub API rate limit hit. Remaining: ${rateLimitRemaining}`, 'warning');
                                            if (rateLimitReset) {
                                                const resetTime = new Date(parseInt(rateLimitReset) * 1000);
                                                addLog(`⏰ Rate limit resets at: ${resetTime.toLocaleTimeString()}`, 'info');
                                            }
                                            // FRANK'S EXPONENTIAL BACKOFF
                                            const waitTime = Math.min(120000, 5000 * Math.pow(2, rateLimitHits));
                                            addLog(`⏳ Waiting ${waitTime/1000}s due to rate limit (exponential backoff)`, 'info');
                                            await new Promise(resolve => setTimeout(resolve, waitTime));
                                        }
                                    } catch (e) {
                                        console.error('Error checking branch:', e);
                                    }
                                    
                                    if (i < maxAttempts - 1) {
                                        addLog(`⏳ Branch not found yet, checking again in 5 seconds... (${i + 1}/${maxAttempts})`, 'info');
                                        await new Promise(resolve => setTimeout(resolve, 5000));
                                    }
                                }
                                return false;
                            };
                            
                            // Get the branch Terragon is working on
                            let targetBranch = 'master';
                            try {
                                const branchResponse = await fetch('/api/branch-tracker', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        action: 'get',
                                        threadId: threadId
                                    })
                                });
                                
                                if (branchResponse.ok) {
                                    const branchData = await branchResponse.json();
                                    if (branchData.branch) {
                                        targetBranch = branchData.branch;
                                        addLog(`🔍 Detected Terragon branch: ${targetBranch}`, 'info');
                                    }
                                }
                            } catch (e) {
                                console.error('Branch detection failed:', e);
                            }
                            
                            // Wait for push if not on master
                            if (targetBranch !== 'master') {
                                const pushed = await waitForPush(targetBranch);
                                if (!pushed) {
                                    addLog(`❌ TASK FAILED: Branch ${targetBranch} not pushed to GitHub after 2 minutes`, 'error');
                                    
                                    // FRANK'S STRICT RULE: No branch = No tests!
                                    setState(prev => ({
                                        ...prev,
                                        executionStatus: {
                                            ...prev.executionStatus,
                                            [checkpoint.id]: {
                                                ...prev.executionStatus[checkpoint.id],
                                                status: 'failed',
                                                endTime: new Date().toISOString(),
                                                error: `Branch ${targetBranch} not found on GitHub after push timeout`,
                                                logs: [
                                                    ...prev.executionStatus[checkpoint.id].logs,
                                                    { message: 'FAILED: Branch not pushed to GitHub - cannot test' }
                                                ]
                                            }
                                        }
                                    }));
                                    
                                    setExecuting(false);
                                    return; // NEVER continue without branch!
                                }
                            }
                            
                            // NOW run contextless tests ONLY after push confirmed
                            setTimeout(() => {
                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                            }, 1000);
                            return;
                        } else if (statusResult.completed && statusResult.status === 'error') {
                            addLog(`❌ Terragon encountered an error in checkpoint ${checkpointNumber}`, 'error');
                            addLog(`📝 Error details: ${statusResult.message}`, 'error');
                            addLog(`🚫 Checkpoint execution failed - stopping`, 'error');
                            setExecuting(false);
                            return;
                        } else if (statusResult.status === 'error') {
                            addLog(`❌ Terragon encountered an error`, 'error');
                            clearInterval(pollInterval);
                            reject(new Error('Terragon execution failed'));
                            return;
                        }
                    } else {
                        addLog(`⚠️ Could not check Terragon status, assuming still working...`, 'info');
                    }
                    
                    // Continue polling if not complete and under max attempts
                    if (pollCount < maxPolls) {
                        setTimeout(() => {
                            pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                        }, 5000); // Poll every 5 seconds
                    } else {
                        addLog(`🕐 Max polling time reached (10 minutes).`, 'error');
                        addLog(`❌ TASK FAILED: Terragon did not complete within 10 minutes.`, 'error');
                        addLog(`📝 Check thread at: https://www.terragonlabs.com/task/${threadId}`, 'info');
                        
                        // FRANK'S STRICT RULE: Mark checkpoint as failed if no completion signal
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'failed',
                                    endTime: new Date().toISOString(),
                                    error: 'Terragon did not complete - timeout after 10 minutes',
                                    logs: [
                                        ...prev.executionStatus[checkpoint.id].logs,
                                        { message: 'FAILED: No completion signal from Terragon after max polling time' }
                                    ]
                                }
                            }
                        }));
                        
                        setExecuting(false);
                        // NEVER continue without explicit completion!
                    }
                    
                } catch (error) {
                    addLog(`Polling error: ${error.message}`, 'error');
                    
                    // FRANK'S FIX: Don't give up on fetch errors - Terragon might still be working!
                    // Network errors shouldn't trigger premature testing
                    if (pollCount < maxPolls) {
                        addLog(`⚠️ Network error, will retry in 10s (attempt ${pollCount}/${maxPolls})...`, 'warning');
                        setTimeout(() => {
                            pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex, pollCount + 1, executionThreadId);
                        }, 10000);
                    } else {
                        addLog(`🕐 Max polling time reached after network errors (10 minutes total).`, 'error');
                        addLog(`❌ TASK FAILED: Cannot verify Terragon completion due to network errors`, 'error');
                        
                        // FRANK'S STRICT RULE: Fail on network errors too
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'failed',
                                    endTime: new Date().toISOString(),
                                    error: 'Network errors prevented Terragon status verification',
                                    logs: [
                                        ...prev.executionStatus[checkpoint.id].logs,
                                        { message: 'FAILED: Network errors after max polling attempts' }
                                    ]
                                }
                            }
                        }));
                        
                        setExecuting(false);
                        // NEVER continue without verification!
                    }
                }
            };

            // FRANK'S REAL TEST AND CONTINUE FUNCTION
            const testCheckpointAndContinue = async (checkpoint, queue, currentIndex, executionThreadId) => {
                const checkpointNumber = currentIndex + 1;
                addLog(`🧪 Testing checkpoint ${checkpointNumber}: ${checkpoint.name}`, 'info');
                
                try {
                    addLog(`🎯 Running contextless tests for checkpoint ${checkpointNumber}`, 'info');
                    
                    // FRANK'S DIRECT APPROACH: Pass the branch we detected during polling
                    if (window.lastDetectedBranch) {
                        checkpoint._detectedBranch = window.lastDetectedBranch;
                        addLog(`📌 Passing detected branch to tests: ${window.lastDetectedBranch}`, 'info');
                    }
                    
                    // Pass the execution thread ID so we test the right branch
                    const testResult = await testCheckpoint(checkpoint, executionThreadId);
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        if (currentIndex + 1 < queue.length) {
                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                        } else {
                            addLog('🎉 All checkpoints completed!', 'success');
                            await validateTaskCompletion();
                            setExecuting(false);
                        }
                        
                    } else {
                        addLog(`❌ Checkpoint ${checkpointNumber} FAILED tests!`, 'error');
                        
                        // FRANK'S SMART LOGIC: Check if failures are retryable
                        const hasRetryableFailures = testResult.failedTests.some(test => 
                            test.details.includes('timeout') || 
                            test.details.includes('network') ||
                            test.details.includes('connection')
                        );
                        
                        const currentRetryCount = checkpoint._retryCount || 0;
                        
                        // Only retry for transient failures (network, timeouts)
                        if (hasRetryableFailures && currentRetryCount < 3) {
                            addLog(`🔄 TEST-RUNNER: Retrying due to possible transient failure (attempt ${currentRetryCount + 1}/3)...`, 'warning');
                            checkpoint._retryCount = currentRetryCount + 1;
                            
                            // Wait before retry
                            setTimeout(() => {
                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                            }, 5000);
                            return;
                        }
                        
                        // FRANK'S ORCHESTRATOR INTEGRATION - Let the brain decide
                        addLog(`🧠 Notifying Task Orchestrator of test failures...`, 'info');
                        
                        // Register test results with orchestrator
                        await registerWithOrchestrator(`test-${checkpoint.id}-${Date.now()}`, {
                            type: 'test-result',
                            parentId: executionThreadId,
                            checkpoint: checkpoint,
                            branch: state.currentBranch || window.lastDetectedBranch || 'master',
                            testResult: testResult,
                            retryCount: currentRetryCount,
                            hasRetryableFailures: hasRetryableFailures
                        });
                        
                        // Force orchestrator decision
                        try {
                            const orchestratorResponse = await fetch('/api/task-orchestrator', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    action: 'decide',
                                    instanceId: executionThreadId
                                })
                            });
                            
                            if (orchestratorResponse.ok) {
                                const decision = await orchestratorResponse.json();
                                const lastDecision = decision.lastDecision;
                                
                                if (lastDecision) {
                                    addLog(`🤖 Orchestrator decision: ${lastDecision.action} - ${lastDecision.reasoning}`, 'info');
                                    
                                    // Update UI based on decision
                                    switch (lastDecision.action) {
                                        case 'escalate':
                                            addLog('🚨 HUMAN ESCALATION REQUIRED', 'error');
                                            addLog('📋 Failed tests:', 'error');
                                            testResult.failedTests.forEach(test => {
                                                addLog(`  - ${test.description}: ${test.details}`, 'error');
                                            });
                                            
                                            setState(prev => ({
                                                ...prev,
                                                executionStatus: {
                                                    ...prev.executionStatus,
                                                    [checkpoint.id]: {
                                                        ...prev.executionStatus[checkpoint.id],
                                                        status: 'escalated',
                                                        escalationReason: lastDecision.reasoning,
                                                        failedTime: new Date().toISOString()
                                                    }
                                                }
                                            }));
                                            
                                            if (checkpoint.blocking) {
                                                addLog('🚫 Blocking checkpoint - execution stopped', 'error');
                                                setExecuting(false);
                                            } else {
                                                addLog('⚡ Non-blocking - continuing despite escalation', 'info');
                                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                            }
                                            break;
                                            
                                        case 'send_message':
                                        case 'create_instance':
                                            addLog(`🔧 Orchestrator is working on fixes...`, 'info');
                                            
                                            setState(prev => ({
                                                ...prev,
                                                executionStatus: {
                                                    ...prev.executionStatus,
                                                    [checkpoint.id]: {
                                                        ...prev.executionStatus[checkpoint.id],
                                                        status: 'resolving',
                                                        orchestratorActive: true
                                                    }
                                                }
                                            }));
                                            
                                            // Wait for orchestrator to work
                                            addLog(`⏳ Waiting 60 seconds for orchestrator actions...`, 'info');
                                            setTimeout(() => {
                                                checkpoint._retryCount = 0; // Reset for re-test
                                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                                            }, 60000);
                                            break;
                                            
                                        case 'wait':
                                            addLog(`⏳ Orchestrator waiting for more data...`, 'info');
                                            setTimeout(() => {
                                                testCheckpointAndContinue(checkpoint, queue, currentIndex, executionThreadId);
                                            }, 10000);
                                            break;
                                            
                                        default:
                                            addLog(`🤷 Unknown orchestrator action: ${lastDecision.action}`, 'warning');
                                            if (checkpoint.blocking) {
                                                setExecuting(false);
                                            } else {
                                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                            }
                                    }
                                } else {
                                    addLog(`⚠️ No decision from orchestrator`, 'warning');
                                    // Fallback to basic behavior
                                    if (checkpoint.blocking) {
                                        addLog('🚫 Blocking checkpoint failed - execution stopped', 'error');
                                        setExecuting(false);
                                    } else {
                                        addLog('⚡ Non-blocking checkpoint failed - continuing', 'info');
                                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                    }
                                }
                            }
                        } catch (error) {
                            addLog(`❌ Orchestrator error: ${error.message}`, 'error');
                            // Fallback to stopping on blocking checkpoints
                            if (checkpoint.blocking) {
                                addLog('🚫 Blocking checkpoint failed - execution stopped', 'error');
                                setExecuting(false);
                            } else {
                                addLog('⚡ Non-blocking checkpoint failed - continuing', 'info');
                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                            }
                        }
                    }
                } catch (error) {
                    addLog(`Test error: ${error.message}`, 'error');
                    setExecuting(false);
                }
            };

            // Execute next checkpoint with explicit parameters (avoids stale closure)
            const executeNextCheckpointWithQueue = async (queue, currentIndex, threadId) => {
                console.log('executeNextCheckpointWithQueue called with:', {
                    queueLength: queue?.length || 0,
                    currentIndex,
                    threadId
                });
                
                addLog(`Checking execution: index=${currentIndex}, queue length=${queue?.length || 0}`, 'info');
                
                if (!queue || queue.length === 0) {
                    addLog('ERROR: No checkpoints found in queue!', 'error');
                    setExecuting(false);
                    return;
                }
                
                if (currentIndex >= queue.length) {
                    addLog('All checkpoints completed, running final validation...', 'info');
                    await validateTaskCompletion();
                    setExecuting(false);
                    return;
                }
                
                const checkpoint = queue[currentIndex];
                const checkpointNumber = currentIndex + 1;
                addLog(`=== Starting Checkpoint ${checkpointNumber}/${queue.length}: ${checkpoint.name} ===`, 'info');
                
                // Update current checkpoint index in state
                setState(prev => ({
                    ...prev,
                    currentCheckpointIndex: currentIndex
                }));
                
                // Continue with checkpoint execution...
                await executeCheckpointWithParams(checkpoint, queue, currentIndex, threadId);
            };

            // Execute individual checkpoint with explicit parameters
            const executeCheckpointWithParams = async (checkpoint, queue, currentIndex, threadId) => {
                const checkpointNumber = currentIndex + 1;
                
                // Validate dependencies before execution
                const dependenciesValid = await validateDependencies(checkpoint);
                if (!dependenciesValid) {
                    addLog(`Dependencies not met for ${checkpoint.name}, waiting...`, 'error');
                    setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex, threadId), 2000);
                    return;
                }
                
                // Get current retry count
                const currentStatus = state.executionStatus[checkpoint.id];
                const retryCount = currentStatus?.retryCount || 0;
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { 
                            status: 'in_progress', 
                            logs: [], 
                            retryCount: retryCount,
                            startTime: new Date().toISOString()
                        }
                    }
                }));
                
                try {
                    // Send checkpoint to Terragon via API proxy
                    const execResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: threadId
                        })
                    });
                    
                    if (!execResponse.ok) {
                        const errorData = await execResponse.json();
                        throw new Error(errorData.error || 'Failed to execute checkpoint');
                    }
                    
                    const execData = await execResponse.json();
                    
                    // FRANK'S CRITICAL FIX: execData.threadId is the EXECUTION thread, not task thread!
                    const executionThreadId = execData.threadId || threadId;
                    addLog(`Checkpoint sent to execution thread: ${executionThreadId}`, 'info');
                    
                    // Register checkpoint execution with orchestrator
                    await registerWithOrchestrator(executionThreadId, {
                        type: 'checkpoint-execution',
                        parentId: state.taskThreadId || threadId,
                        checkpoint: checkpoint,
                        branch: state.currentBranch || window.lastDetectedBranch || 'master'
                    });
                    
                    // Update status to executing with EXECUTION thread ID
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                ...prev.executionStatus[checkpoint.id],
                                status: 'executing',
                                threadId: executionThreadId,  // Store execution thread ID
                                executionThreadId: executionThreadId,  // Also store explicitly
                                taskThreadId: threadId,  // Keep task thread ID too
                                logs: [{ 
                                    message: `Executing in thread: ${executionThreadId}`,
                                    url: `https://www.terragonlabs.com/task/${executionThreadId}`
                                }]
                            }
                        }
                    }));
                    
                    addLog(`✅ Checkpoint ${checkpointNumber} sent to Terragon execution thread: ${executionThreadId}`, 'success');
                    addLog(`Monitor at: https://www.terragonlabs.com/task/${executionThreadId}`, 'info');
                    
                    // FRANK'S REAL POLLING - Pass both thread IDs
                    addLog(`🔍 Waiting for Terragon to complete checkpoint ${checkpointNumber}...`, 'info');
                    setTimeout(() => {
                        pollTerragonForCompletion(threadId, checkpoint, queue, currentIndex, 0, executionThreadId);
                    }, 2000); // Small delay before polling starts
                    
                    return; // Exit here - polling will handle the rest
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                        
                    } else {
                        // Handle failure with retry logic
                        const newRetryCount = retryCount + 1;
                        
                        if (newRetryCount < 3) {
                            addLog(`❌ Test-Runner: Checkpoint ${checkpointNumber} FAILED - Retry ${newRetryCount}/3`, 'error');
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'retrying',
                                        retryCount: newRetryCount,
                                        testResults: testResult
                                    }
                                }
                            }));
                            
                            // Retry same checkpoint
                            setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex, threadId), 3000);
                        } else {
                            // Test-Runner exhausted - invoke Task-LLM-Resolver
                            addLog(`⚠️ Test-Runner exhausted 3 attempts. Escalating to Task-LLM-Resolver...`, 'warning');
                            
                            // FRANK'S FIX: Handle async Task-LLM-Resolver properly
                            try {
                                const resolverResult = await taskLLMResolver(checkpoint, testResult, executionThreadId || threadId);
                            
                            if (resolverResult.success) {
                                // Task-LLM-Resolver fixed it!
                                setState(prev => ({
                                    ...prev,
                                    executionStatus: {
                                        ...prev.executionStatus,
                                        [checkpoint.id]: {
                                            ...prev.executionStatus[checkpoint.id],
                                            status: 'pass',
                                            testResults: resolverResult.testResult,
                                            resolvedByLLM: true,
                                            completedTime: new Date().toISOString()
                                        }
                                    }
                                }));
                                
                                addLog(`🎉 Task-LLM-Resolver fixed the issues! Continuing...`, 'success');
                                
                                // Continue to next checkpoint
                                if (currentIndex + 1 < queue.length) {
                                    setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                                } else {
                                    addLog('🎉 All checkpoints completed!', 'success');
                                    await validateTaskCompletion();
                                    setExecuting(false);
                                }
                            } else if (resolverResult.escalate) {
                                // Task-LLM-Resolver exhausted - need human help
                                addLog(`🚨 HUMAN ESCALATION REQUIRED for checkpoint ${checkpointNumber}`, 'error');
                                addLog(`📋 Summary: After 3 Test-Runner attempts and 5 Task-LLM-Resolver attempts, the following issues persist:`, 'error');
                                testResult.failedTests.forEach(failure => {
                                    addLog(`  - ${failure.description}: ${failure.details}`, 'error');
                                });
                                addLog(`🛑 Execution halted. Human intervention required.`, 'error');
                                
                                setState(prev => ({
                                    ...prev,
                                    executionStatus: {
                                        ...prev.executionStatus,
                                        [checkpoint.id]: {
                                            ...prev.executionStatus[checkpoint.id],
                                            status: 'human_escalation',
                                            requiresHumanIntervention: true,
                                            escalationReason: 'Test-Runner and Task-LLM-Resolver exhausted',
                                            failedTime: new Date().toISOString()
                                        }
                                    }
                                }));
                                
                                setExecuting(false);
                            } else {
                                addLog(`🛑 Checkpoint ${checkpointNumber} FAILED after all attempts!`, 'error');
                                handleFailedCheckpoint();
                            }
                        } catch (resolverError) {
                            // FRANK'S FIX: Handle Task-LLM-Resolver crashes
                            addLog(`🚨 Task-LLM-Resolver crashed: ${resolverError.message}`, 'error');
                            handleFailedCheckpoint();
                        }
                        
                        // Helper function to handle failed checkpoints
                        function handleFailedCheckpoint() {
                            if (checkpoint.blocking) {
                                addLog(`🚫 This is a BLOCKING checkpoint - execution halted`, 'error');
                            }
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'fail',
                                        testResults: testResult,
                                        failedTime: new Date().toISOString()
                                    }
                                }
                            }));
                            
                            // If blocking checkpoint failed, stop execution
                            if (checkpoint.blocking) {
                                setExecuting(false);
                                addLog('Execution stopped due to blocking checkpoint failure', 'error');
                            } else {
                                // Non-blocking can continue
                                addLog('Non-blocking checkpoint failed, continuing...', 'info');
                                setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                            }
                        }
                        }
                    }
                    
                } catch (error) {
                    addLog(`Checkpoint execution error: ${error.message}`, 'error');
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }],
                                error: error.message
                            }
                        }
                    }));
                    
                    if (checkpoint.blocking) {
                        setExecuting(false);
                        addLog('Execution stopped due to error in blocking checkpoint', 'error');
                    } else {
                        // Try next checkpoint for non-blocking
                        setTimeout(() => executeNextCheckpointWithQueue(queue, currentIndex + 1, threadId), 2000);
                    }
                }
            };

            // Execute next checkpoint in queue (legacy - uses state)
            const executeNextCheckpoint = async () => {
                console.log('executeNextCheckpoint called');
                console.log('Current state:', {
                    currentCheckpointIndex: state.currentCheckpointIndex,
                    checkpointQueue: state.checkpointQueue?.length,
                    checkpoints: state.checkpoints?.length
                });
                
                const currentIndex = state.currentCheckpointIndex || 0;
                const queue = state.checkpointQueue || state.checkpoints;
                
                addLog(`Checking execution: index=${currentIndex}, queue length=${queue?.length || 0}`, 'info');
                
                if (!queue || queue.length === 0) {
                    addLog('ERROR: No checkpoints found in queue!', 'error');
                    setExecuting(false);
                    return;
                }
                
                if (currentIndex >= queue.length) {
                    addLog('All checkpoints completed, running final validation...', 'info');
                    await validateTaskCompletion();
                    setExecuting(false);
                    return;
                }
                
                const checkpoint = queue[currentIndex];
                const checkpointNumber = currentIndex + 1;
                addLog(`=== Starting Checkpoint ${checkpointNumber}/${queue.length}: ${checkpoint.name} ===`, 'info');
                
                // Validate dependencies before execution
                const dependenciesValid = await validateDependencies(checkpoint);
                if (!dependenciesValid) {
                    addLog(`Dependencies not met for ${checkpoint.name}, waiting...`, 'error');
                    setTimeout(() => executeNextCheckpoint(), 2000);
                    return;
                }
                
                // Get current retry count
                const currentStatus = state.executionStatus[checkpoint.id];
                const retryCount = currentStatus?.retryCount || 0;
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { 
                            status: 'in_progress', 
                            logs: [], 
                            retryCount: retryCount,
                            startTime: new Date().toISOString()
                        }
                    }
                }));
                
                try {
                    // Send checkpoint execution message to existing Terragon thread
                    const checkpointMessage = `# CHECKPOINT ${checkpointNumber}: ${checkpoint.name}

## Objective
${checkpoint.objective}

## Blocking Status
${checkpoint.blocking ? '🚫 BLOCKING - Must pass before continuing' : '⚡ NON-BLOCKING - Can fail without halting'}

## Instructions
${checkpoint.instructions.map((inst, j) => `${j + 1}. ${inst}`).join('\n')}

## Pass Criteria (Must verify ALL):
${checkpoint.passCriteria.map((pc, i) => `✓ ${i + 1}. ${pc.description}`).join('\n')}

Please execute this checkpoint and report when complete. I will then run tests to verify all pass criteria.`;

                    // Send checkpoint to Terragon via API proxy
                    const execResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: state.taskThreadId
                        })
                    });
                    
                    if (!execResponse.ok) {
                        const errorData = await execResponse.json();
                        throw new Error(errorData.error || 'Failed to execute checkpoint');
                    }
                    
                    const execData = await execResponse.json();
                    addLog(`Checkpoint sent to thread: ${execData.threadId}`, 'info');
                    
                    // Update status to executing
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                ...prev.executionStatus[checkpoint.id],
                                status: 'executing',
                                threadId: state.taskThreadId,
                                logs: [{ 
                                    message: `Executing in thread: ${state.taskThreadId}`,
                                    url: `https://www.terragonlabs.com/task/${state.taskThreadId}`
                                }]
                            }
                        }
                    }));
                    
                    addLog(`Checkpoint sent to Terragon, waiting for execution...`, 'info');
                    
                    // Wait for Terragon to execute (in real implementation, would poll for completion)
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
                    // Run pass/fail tests
                    addLog(`Running Pass/Fail tests for ${checkpoint.name}...`, 'info');
                    const testResult = await testCheckpoint(checkpoint);
                    
                    if (testResult.passed) {
                        // Mark as passed and move to next
                        setState(prev => ({
                            ...prev,
                            currentCheckpointIndex: currentIndex + 1,
                            executionStatus: {
                                ...prev.executionStatus,
                                [checkpoint.id]: {
                                    ...prev.executionStatus[checkpoint.id],
                                    status: 'pass',
                                    testResults: testResult,
                                    completedTime: new Date().toISOString()
                                }
                            }
                        }));
                        
                        addLog(`✅ Checkpoint ${checkpointNumber} PASSED all tests!`, 'success');
                        
                        // Continue to next checkpoint
                        setTimeout(() => executeNextCheckpoint(), 2000);
                        
                    } else {
                        // Handle failure with retry logic
                        const newRetryCount = retryCount + 1;
                        
                        if (newRetryCount < 3) {
                            addLog(`❌ Checkpoint ${checkpointNumber} FAILED - Retry ${newRetryCount}/3`, 'error');
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'retrying',
                                        retryCount: newRetryCount,
                                        testResults: testResult
                                    }
                                }
                            }));
                            
                            // Retry same checkpoint
                            setTimeout(() => executeNextCheckpoint(), 3000);
                        } else {
                            addLog(`🛑 Checkpoint ${checkpointNumber} FAILED after 3 attempts!`, 'error');
                            if (checkpoint.blocking) {
                                addLog(`🚫 This is a BLOCKING checkpoint - execution halted`, 'error');
                            }
                            setState(prev => ({
                                ...prev,
                                executionStatus: {
                                    ...prev.executionStatus,
                                    [checkpoint.id]: {
                                        ...prev.executionStatus[checkpoint.id],
                                        status: 'fail',
                                        testResults: testResult,
                                        failedTime: new Date().toISOString()
                                    }
                                }
                            }));
                            
                            // If blocking checkpoint failed, stop execution
                            if (checkpoint.blocking) {
                                setExecuting(false);
                                addLog('Execution stopped due to blocking checkpoint failure', 'error');
                            } else {
                                // Non-blocking can continue
                                addLog('Non-blocking checkpoint failed, continuing...', 'info');
                                setState(prev => ({
                                    ...prev,
                                    currentCheckpointIndex: currentIndex + 1
                                }));
                                setTimeout(() => executeNextCheckpoint(), 2000);
                            }
                        }
                    }
                    
                } catch (error) {
                    addLog(`Checkpoint execution error: ${error.message}`, 'error');
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }],
                                error: error.message
                            }
                        }
                    }));
                    
                    if (checkpoint.blocking) {
                        setExecuting(false);
                        addLog('Execution stopped due to error in blocking checkpoint', 'error');
                    } else {
                        // Try next checkpoint for non-blocking
                        setState(prev => ({
                            ...prev,
                            currentCheckpointIndex: currentIndex + 1
                        }));
                        setTimeout(() => executeNextCheckpoint(), 2000);
                    }
                }
            };

            // FRANK'S TASK-LLM-RESOLVER - ANALYZES AND FIXES TEST FAILURES
            const taskLLMResolver = async (checkpoint, testResult, mainThreadId, attemptNumber = 1) => {
                const MAX_ATTEMPTS = 5;
                
                if (attemptNumber > MAX_ATTEMPTS) {
                    addLog(`❌ Task-LLM-Resolver exhausted all ${MAX_ATTEMPTS} attempts`, 'error');
                    return { success: false, escalate: true };
                }
                
                addLog(`🔧 Task-LLM-Resolver activated (Attempt ${attemptNumber}/${MAX_ATTEMPTS})`, 'warning');
                addLog(`📊 Analyzing test failures for checkpoint: ${checkpoint.name}`, 'info');
                addLog(`📍 Sending fixes to Terragon thread: ${mainThreadId}`, 'info');
                
                // Analyze failure patterns
                const failureAnalysis = {
                    failedTests: testResult.failedTests || [],
                    patterns: [],
                    proposedFixes: []
                };
                
                // Pattern matching for common failures
                for (const failure of failureAnalysis.failedTests) {
                    const description = failure.description.toLowerCase();
                    const details = (failure.details || '').toLowerCase();
                    
                    if (details.includes('no such file') || details.includes('file not found') || details.includes('does not exist')) {
                        failureAnalysis.patterns.push('MISSING_FILE');
                        failureAnalysis.proposedFixes.push({
                            type: 'CREATE_FILE',
                            description: `Create missing file for: ${failure.description}`
                        });
                    } else if (details.includes('no mongodb') || details.includes('connection') || details.includes('mongodb')) {
                        failureAnalysis.patterns.push('MISSING_DEPENDENCY');
                        failureAnalysis.proposedFixes.push({
                            type: 'MOCK_DEPENDENCY',
                            description: `Mock or skip MongoDB test: ${failure.description}`
                        });
                    } else if (details.includes('branch') || details.includes('checkout')) {
                        failureAnalysis.patterns.push('BRANCH_ISSUE');
                        failureAnalysis.proposedFixes.push({
                            type: 'CHECKOUT_BRANCH',
                            description: `Ensure correct branch for: ${failure.description}`
                        });
                    } else if (details.includes('expected') && details.includes('found')) {
                        failureAnalysis.patterns.push('WRONG_CONTENT');
                        failureAnalysis.proposedFixes.push({
                            type: 'UPDATE_CONTENT',
                            description: `Fix content mismatch for: ${failure.description}`
                        });
                    } else {
                        failureAnalysis.patterns.push('UNKNOWN');
                        failureAnalysis.proposedFixes.push({
                            type: 'INVESTIGATE',
                            description: `Investigate failure: ${failure.description}`
                        });
                    }
                }
                
                addLog(`🔍 Identified patterns: ${failureAnalysis.patterns.join(', ')}`, 'info');
                addLog(`💡 Proposed fixes: ${failureAnalysis.proposedFixes.length}`, 'info');
                
                // Send fix message to Terragon
                try {
                    const fixResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'send-message',
                            threadId: mainThreadId,
                            message: buildResolverMessage(failureAnalysis, attemptNumber)
                        })
                    });
                    
                    if (fixResponse.ok) {
                        addLog(`✅ Fix instructions sent to Terragon thread`, 'success');
                        
                        // Wait for Terragon to implement fixes
                        addLog(`⏳ Waiting 60 seconds for Terragon to implement fixes...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, 60000));
                        
                        // Continue with success - tests will re-run
                        return { success: true };
                    } else {
                        addLog(`❌ Failed to send fix instructions to Terragon`, 'error');
                        return { success: false, escalate: attemptNumber >= MAX_ATTEMPTS };
                    }
                } catch (error) {
                    addLog(`❌ Task-LLM-Resolver error: ${error.message}`, 'error');
                    return { success: false, escalate: attemptNumber >= MAX_ATTEMPTS };
                }
            };
            
            // Helper to build resolver message
            const buildResolverMessage = (failureAnalysis, attemptNumber) => {
                // Build fix message for Terragon
                const fixMessage = `# TASK-LLM-RESOLVER FIX ATTEMPT ${attemptNumber}

## Test Failures Analysis
${failureAnalysis.failedTests.map(f => `- **${f.description}**: ${f.details}`).join('\n')}

## Root Cause Analysis
Patterns identified: ${failureAnalysis.patterns.join(', ')}

## Proposed Fixes
${failureAnalysis.proposedFixes.map((fix, i) => `${i + 1}. **${fix.type}**: ${fix.description}`).join('\n')}

## Instructions
Please execute the following fixes to resolve the test failures:

${failureAnalysis.proposedFixes.map(fix => {
                    switch(fix.type) {
                        case 'CREATE_FILE':
                            return `- Create the missing file with appropriate content based on the test requirements`;
                        case 'MOCK_DEPENDENCY':
                            return `- Since this is a Document Manager test, MongoDB tests should be skipped or mocked`;
                        case 'CHECKOUT_BRANCH':
                            return `- Ensure you're on the correct branch with latest changes`;
                        case 'UPDATE_CONTENT':
                            return `- Update file content to match expected values in the test`;
                        default:
                            return `- Investigate and fix the issue: ${fix.description}`;
                    }
                }).join('\n')}

After completing these fixes, I will re-run the tests automatically.`;
                
                return fixMessage;
            };
            
            // Test checkpoint pass/fail criteria
            const testCheckpoint = async (checkpoint, executionThreadId) => {
                addLog(`Running tests for ${checkpoint.name}...`, 'info');
                
                try {
                    const testResults = {
                        checkpointId: checkpoint.id,
                        checkpointName: checkpoint.name,
                        totalTests: checkpoint.passCriteria.length,
                        passedTests: [],
                        failedTests: [],
                        passed: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    // Test each pass criteria
                    for (let i = 0; i < checkpoint.passCriteria.length; i++) {
                        const criteria = checkpoint.passCriteria[i];
                        addLog(`Testing: ${criteria.description}`, 'info');
                        
                        try {
                            // FRANK'S CONTEXTLESS TEST - NEW TERRAGON INSTANCE
                            // Use execution thread ID, not task thread ID!
                            const testPassed = await executeContextlessTest(criteria, checkpoint, executionThreadId || state.taskThreadId);
                            
                            if (testPassed) {
                                testResults.passedTests.push({
                                    description: criteria.description,
                                    status: 'pass',
                                    details: `✓ ${criteria.description} verified successfully`
                                });
                                addLog(`✓ Test passed: ${criteria.description}`, 'success');
                            } else {
                                testResults.failedTests.push({
                                    description: criteria.description,
                                    status: 'fail',
                                    details: `✗ ${criteria.description} did not meet requirements`
                                });
                                addLog(`✗ Test failed: ${criteria.description}`, 'error');
                            }
                            
                        } catch (testError) {
                            testResults.failedTests.push({
                                description: criteria.description,
                                status: 'error',
                                details: `Error testing ${criteria.description}: ${testError.message}`
                            });
                            addLog(`Error testing ${criteria.description}: ${testError.message}`, 'error');
                        }
                    }
                    
                    // Determine overall pass/fail
                    testResults.passed = testResults.failedTests.length === 0;
                    
                    addLog(`Test summary: ${testResults.passedTests.length}/${testResults.totalTests} passed`, 
                           testResults.passed ? 'success' : 'error');
                    
                    return testResults;
                    
                } catch (error) {
                    addLog(`Test runner error: ${error.message}`, 'error');
                    return {
                        checkpointId: checkpoint.id,
                        passed: false,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    };
                }
            };

            // FRANK'S CONTEXTLESS TEST EXECUTION - NEW TERRAGON INSTANCE FOR EACH TEST
            const executeContextlessTest = async (criteria, checkpoint, mainThreadId) => {
                addLog(`🆕 CONTEXTLESS TEST: ${criteria.description}`, 'info');
                addLog(`Creating fresh Terragon instance for unbiased testing...`, 'info');
                
                // FRANK'S DEBUG: Log all thread IDs
                console.log('Thread ID debug:');
                console.log(`  mainThreadId (param): ${mainThreadId}`);
                console.log(`  state.taskThreadId: ${state.taskThreadId}`);
                console.log(`  state.sessionId: ${state.sessionId}`);
                
                try {
                    // Create NEW Terragon instance for contextless testing
                    // Detect branch for testing using branch tracker
                    let targetBranch = 'master';
                    
                    // FRANK'S SIMPLE FIX: Just check branch tracker - Terragon is explicit
                    console.log(`Branch detection for thread: ${mainThreadId}`);
                    console.log(`Test criteria: "${criteria.description}"`);
                    
                    try {
                        // FRANK'S REAL FIX: Use the ORIGINAL Terragon thread ID, not test thread
                        const originalThreadId = state.taskThreadId || mainThreadId;
                        console.log(`Looking up branch for original thread: ${originalThreadId}`);
                        
                        // FRANK'S WORKAROUND: Also check if we have the branch in state
                        if (state.currentBranch) {
                            targetBranch = state.currentBranch;
                            console.log(`Using branch from state: ${targetBranch}`);
                            addLog(`📌 Using tracked branch: ${targetBranch}`, 'success');
                        }
                        
                        // FRANK'S FALLBACK: Try to get branch from window/global if available
                        if (targetBranch === 'master' && window.lastDetectedBranch) {
                            targetBranch = window.lastDetectedBranch;
                            console.log(`Using branch from window: ${targetBranch}`);
                            addLog(`📌 Using last detected branch: ${targetBranch}`, 'info');
                        }
                        
                        // FRANK'S DIRECT: Check if branch was passed through checkpoint
                        if (targetBranch === 'master' && checkpoint._detectedBranch) {
                            targetBranch = checkpoint._detectedBranch;
                            console.log(`Using branch from checkpoint: ${targetBranch}`);
                            addLog(`📌 Using checkpoint branch: ${targetBranch}`, 'success');
                        }
                        
                        const branchResponse = await fetch('/api/branch-tracker', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'get',
                                threadId: originalThreadId
                            })
                        });
                        
                        if (branchResponse.ok) {
                            const branchData = await branchResponse.json();
                            if (branchData.branch) {
                                targetBranch = branchData.branch;
                                console.log(`Testing on tracked branch: ${targetBranch}`);
                                addLog(`📌 Testing on branch: ${targetBranch}`, 'info');
                                
                                // FRANK'S DEBUG: Log if branch seems wrong
                                if (targetBranch.includes('mongodb') && !criteria.description.toLowerCase().includes('mongodb')) {
                                    console.warn(`WARNING: Branch mismatch? Testing '${criteria.description}' on MongoDB branch '${targetBranch}'`);
                                    addLog(`⚠️ Branch name doesn't match test criteria - possible stale branch tracking`, 'warning');
                                }
                            } else {
                                console.log(`No branch found for thread ${mainThreadId}`);
                                addLog(`⚠️ No branch tracked for thread ${mainThreadId} - using master`, 'warning');
                            }
                        } else {
                            console.error('Branch tracker request failed:', branchResponse.status);
                        }
                    } catch (e) {
                        console.error('Branch detection failed:', e);
                        addLog(`❌ Branch detection error: ${e.message}`, 'error');
                    }
                    
                    // FRANK'S LAST RESORT: If we still don't have a branch, log error
                    if (!targetBranch || targetBranch === 'master') {
                        console.error('BRANCH DETECTION FAILED - All methods returned master');
                        console.error('Available sources:', {
                            state: state.currentBranch,
                            window: window.lastDetectedBranch,
                            checkpoint: checkpoint._detectedBranch,
                            tracker: 'check logs above'
                        });
                    }
                    
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'test-real',
                            criteria,
                            testDescription: criteria.description,
                            mainThreadId: mainThreadId,
                            targetBranch: targetBranch
                        })
                    });
                    
                    if (!testResponse.ok) {
                        addLog(`Test instance creation failed: ${testResponse.status}`, 'error');
                        return false;
                    }
                    
                    const testResult = await testResponse.json();
                    
                    if (testResult.testInstanceCreated) {
                        addLog(`✅ Test instance created: ${testResult.testThreadId}`, 'success');
                        
                        // Register test instance with orchestrator
                        await registerWithOrchestrator(testResult.testThreadId, {
                            type: 'test',
                            parentId: executionThreadId || mainThreadId,
                            checkpoint: checkpoint,
                            branch: testResult.targetBranch,
                            criteria: criteria.description
                        });
                        
                        // FRANK'S WARNING: Check what branch was actually used
                        const actualBranch = testResult.targetBranch || 'master';
                        if (actualBranch === 'master' && targetBranch && targetBranch !== 'master') {
                            addLog(`❌ WARNING: Test created on MASTER but should be on ${targetBranch}!`, 'error');
                            addLog(`🔍 Branch detection failed - targetBranch was: ${targetBranch}`, 'error');
                        } else if (testResult.targetBranch && testResult.targetBranch !== 'master') {
                            addLog(`✅ Testing on branch: ${testResult.targetBranch}`, 'success');
                        } else {
                            addLog(`⚠️ Testing on master branch (no feature branch detected)`, 'warning');
                        }
                        addLog(`🔗 Test URL: ${testResult.testUrl}`, 'info');
                        addLog(`⏳ Polling test instance for REAL results...`, 'info');
                        
                        // FRANK'S REAL TEST RESULT POLLING - NO BULLSHIT
                        const testInstanceResult = await pollTestInstanceForResults(testResult.testThreadId, 60); // 5 minute max
                        
                        if (testInstanceResult.completed && testInstanceResult.result) {
                            const passed = testInstanceResult.result.toLowerCase().includes('pass');
                            addLog(`🧪 Test instance completed: ${passed ? 'PASS' : 'FAIL'}`, passed ? 'success' : 'error');
                            addLog(`📝 Test evidence: ${testInstanceResult.evidence}`, 'info');
                            return passed;
                        } else {
                            addLog(`❌ Test instance failed to complete or provide results`, 'error');
                            return false;
                        }
                        
                    } else {
                        addLog(`Test instance creation failed`, 'error');
                        return false;
                    }
                    
                } catch (error) {
                    addLog(`Contextless test error: ${error.message}`, 'error');
                    return false;
                }
            };

            // FRANK'S REAL TEST INSTANCE POLLING - NO FAKE RESULTS
            const pollTestInstanceForResults = async (testThreadId, maxPolls = 60, retryCount = 0) => {
                addLog(`🔄 Polling test instance ${testThreadId} for real results...`, 'info');
                
                for (let pollCount = 0; pollCount < maxPolls; pollCount++) {
                    try {
                        // Check test instance status
                        const statusResponse = await fetch('/api/execute', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                action: 'check-terragon-status',
                                threadId: testThreadId
                            })
                        });
                        
                        if (statusResponse.ok) {
                            let statusResult = await statusResponse.json();
                            
                            if (statusResult.completed) {
                                addLog(`✅ Test instance ${testThreadId} completed!`, 'success');
                                
                                // FRANK'S FIX: RED TEAM found the real bug - API sync delay
                                // Terragon UI updates before API syncs the full response
                                addLog(`⏳ Waiting 30s for Terragon API to sync full response...`, 'info');
                                await new Promise(resolve => setTimeout(resolve, 30000));
                                
                                // Re-fetch after sync delay to get complete response
                                const syncResponse = await fetch('/api/execute', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ 
                                        action: 'check-terragon-status',
                                        threadId: testThreadId
                                    })
                                });
                                
                                if (syncResponse.ok) {
                                    const syncResult = await syncResponse.json();
                                    // Use the synced result instead
                                    statusResult = syncResult;
                                }
                                
                                // FRANK'S DEBUG: Log what we're getting
                                console.log('Test status result after sync:', statusResult);
                                
                                // Parse the actual test result from Terragon response
                                // Look for RESULT: PASS/FAIL pattern in the response
                                const testContent = statusResult.lastResponse || statusResult.message || '';
                                
                                // If test content is empty, we have a problem
                                if (!testContent || testContent.length < 10) {
                                    console.error('Test content is empty or too short:', testContent);
                                    addLog(`⚠️ Test response appears empty, length: ${testContent.length}`, 'warning');
                                }
                                
                                let result = 'UNKNOWN';
                                let evidence = 'No evidence found';
                                
                                // Extract RESULT: and EVIDENCE: from Terragon response
                                const resultMatch = testContent.match(/RESULT:\s*(PASS|FAIL)/i);
                                const evidenceMatch = testContent.match(/EVIDENCE:\s*([^\n]+)/i);
                                
                                if (resultMatch) {
                                    result = resultMatch[1].toUpperCase();
                                }
                                if (evidenceMatch) {
                                    evidence = evidenceMatch[1].trim();
                                }
                                
                                // FRANK'S RETRY: If still no result, retry with delay
                                if (result === 'UNKNOWN' && retryCount < 3) {
                                    console.log(`Result not found, retry attempt ${retryCount + 1}/3...`);
                                    addLog(`⚠️ Result not found in response, retrying (${retryCount + 1}/3)...`, 'warning');
                                    await new Promise(resolve => setTimeout(resolve, 5000));
                                    return await pollTestInstanceForResults(testThreadId, maxPolls, retryCount + 1);
                                }
                                
                                return {
                                    completed: true,
                                    result: result,
                                    evidence: evidence,
                                    fullResponse: testContent
                                };
                            } else {
                                if (pollCount % 6 === 0) { // Log every 30 seconds
                                    addLog(`⏳ Test instance still running... (${pollCount * 5}s elapsed)`, 'info');
                                }
                            }
                        }
                        
                        // Wait 5 seconds before next poll
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        
                    } catch (error) {
                        addLog(`Test polling error: ${error.message}`, 'error');
                    }
                }
                
                // Max polls reached
                addLog(`🕐 Test instance polling timeout after ${maxPolls * 5} seconds`, 'error');
                return {
                    completed: false,
                    result: 'TIMEOUT',
                    evidence: 'Test instance did not complete within timeout period'
                };
            };

            // Validate checkpoint dependencies
            const validateDependencies = async (checkpoint) => {
                const currentIndex = state.currentCheckpointIndex || 0;
                const queue = state.checkpointQueue || state.checkpoints;
                
                // For the first checkpoint, no dependencies to check
                if (currentIndex === 0) {
                    return true;
                }
                
                // Check all previous checkpoints
                for (let i = 0; i < currentIndex; i++) {
                    const previousCheckpoint = queue[i];
                    const previousStatus = state.executionStatus[previousCheckpoint.id];
                    
                    // If previous checkpoint is blocking and hasn't passed, we can't proceed
                    if (previousCheckpoint.blocking && previousStatus?.status !== 'pass') {
                        addLog(`Blocked by ${previousCheckpoint.name} (status: ${previousStatus?.status || 'unknown'})`, 'error');
                        return false;
                    }
                    
                    // If previous checkpoint is still executing, wait for non-blocking
                    if (previousStatus?.status === 'in_progress' || previousStatus?.status === 'executing') {
                        if (previousCheckpoint.blocking) {
                            addLog(`Waiting for blocking checkpoint: ${previousCheckpoint.name}`, 'info');
                            return false;
                        } else {
                            // Non-blocking can run in parallel - this is allowed
                            addLog(`Running in parallel with non-blocking: ${previousCheckpoint.name}`, 'info');
                        }
                    }
                    
                    // If a blocking checkpoint failed, halt execution
                    if (previousCheckpoint.blocking && previousStatus?.status === 'fail') {
                        addLog(`Cannot proceed: blocking checkpoint ${previousCheckpoint.name} failed`, 'error');
                        return false;
                    }
                }
                
                // All dependency checks passed
                return true;
            };

            // Get dependency status for UI display
            const getDependencyStatus = (checkpoint) => {
                const currentIndex = state.checkpoints.findIndex(cp => cp.id === checkpoint.id);
                if (currentIndex === 0) return 'ready';
                
                // Check blocking dependencies
                for (let i = 0; i < currentIndex; i++) {
                    const previousCheckpoint = state.checkpoints[i];
                    const previousStatus = state.executionStatus[previousCheckpoint.id];
                    
                    if (previousCheckpoint.blocking && previousStatus?.status !== 'pass') {
                        return 'blocked';
                    }
                }
                
                return 'ready';
            };

            // Validate task completion - end-to-end validation
            const validateTaskCompletion = async () => {
                addLog('Running end-to-end task validation...', 'info');
                
                try {
                    if (!state.task || !state.task.acceptanceCriteria) {
                        addLog('No acceptance criteria defined for task', 'error');
                        return false;
                    }
                    
                    const taskValidation = {
                        taskId: state.task.id || 'current-task',
                        taskName: state.task.name,
                        totalCriteria: state.task.acceptanceCriteria.length,
                        passedCriteria: [],
                        failedCriteria: [],
                        checkpointSummary: {},
                        passed: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    // First, verify all checkpoints have passed
                    let allCheckpointsPassed = true;
                    state.checkpoints.forEach(checkpoint => {
                        const status = state.executionStatus[checkpoint.id];
                        taskValidation.checkpointSummary[checkpoint.id] = {
                            name: checkpoint.name,
                            status: status?.status || 'unknown',
                            blocking: checkpoint.blocking
                        };
                        
                        if (checkpoint.blocking && status?.status !== 'pass') {
                            allCheckpointsPassed = false;
                            addLog(`Critical checkpoint failed: ${checkpoint.name}`, 'error');
                        }
                    });
                    
                    if (!allCheckpointsPassed) {
                        addLog('Task validation failed: critical checkpoints not passed', 'error');
                        return false;
                    }
                    
                    // Test each acceptance criteria
                    for (let i = 0; i < state.task.acceptanceCriteria.length; i++) {
                        const criteria = state.task.acceptanceCriteria[i];
                        addLog(`Validating acceptance criteria: ${criteria}`, 'info');
                        
                        try {
                            // Call API for end-to-end testing
                            const validationResponse = await fetch(EXECUTE_URL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    action: 'validate-task',
                                    task: state.task,
                                    criteria,
                                    checkpointResults: state.executionStatus,
                                    sessionId: state.taskThreadId
                                })
                            });
                            
                            // REAL VALIDATION - NO FAKE SHIT
                            const criteriaPassed = await executeRealTaskValidation(criteria);
                            
                            if (criteriaPassed) {
                                taskValidation.passedCriteria.push({
                                    description: criteria,
                                    status: 'pass',
                                    details: `✓ ${criteria} validated successfully`
                                });
                                addLog(`✓ Acceptance criteria passed: ${criteria}`, 'success');
                            } else {
                                taskValidation.failedCriteria.push({
                                    description: criteria,
                                    status: 'fail',
                                    details: `✗ ${criteria} does not meet requirements`
                                });
                                addLog(`✗ Acceptance criteria failed: ${criteria}`, 'error');
                            }
                            
                        } catch (validationError) {
                            taskValidation.failedCriteria.push({
                                description: criteria,
                                status: 'error',
                                details: `Error validating ${criteria}: ${validationError.message}`
                            });
                            addLog(`Error validating ${criteria}: ${validationError.message}`, 'error');
                        }
                    }
                    
                    // Determine overall task completion
                    taskValidation.passed = taskValidation.failedCriteria.length === 0;
                    
                    if (taskValidation.passed) {
                        addLog(`🎉 Task validation successful! All ${taskValidation.totalCriteria} criteria passed`, 'success');
                        addLog('Task is ready for human review', 'success');
                        
                        // Update task status to awaiting review
                        setState(prev => ({
                            ...prev,
                            taskStatus: 'Awaiting Review',
                            taskValidationResults: taskValidation
                        }));
                        
                        // Add to review queue
                        const reviewTask = {
                            id: `task-${Date.now()}`,
                            name: state.task.name,
                            objective: state.task.objective,
                            status: 'Awaiting Review',
                            branch: `terragon/${state.task.name.toLowerCase().replace(/\s+/g, '-')}`,
                            threadId: state.taskThreadId,
                            acceptanceCriteria: state.task.acceptanceCriteria,
                            completedAt: new Date().toISOString(),
                            validationResults: taskValidation
                        };
                        
                        setState(prev => ({
                            ...prev,
                            reviewTasks: [...prev.reviewTasks, reviewTask]
                        }));
                        
                    } else {
                        addLog(`Task validation failed: ${taskValidation.failedCriteria.length}/${taskValidation.totalCriteria} criteria failed`, 'error');
                        addLog('Task requires additional work before review', 'error');
                    }
                    
                    return taskValidation.passed;
                    
                } catch (error) {
                    addLog(`Task validation error: ${error.message}`, 'error');
                    return false;
                }
            };

            // REAL TASK VALIDATION - NO FAKE BULLSHIT
            const executeRealTaskValidation = async (criteria) => {
                addLog(`REAL TASK VALIDATION: ${criteria}`, 'info');
                
                try {
                    // Call API to run actual task-level validation
                    const validationResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            criteria,
                            task: state.task,
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (!validationResponse.ok) {
                        addLog(`Task validation API failed: ${validationResponse.status}`, 'error');
                        return false;
                    }
                    
                    const validationResult = await validationResponse.json();
                    addLog(`Task validation: ${validationResult.passed ? 'PASSED' : 'FAILED'} - ${validationResult.details}`, 
                           validationResult.passed ? 'success' : 'error');
                    
                    return validationResult.passed;
                    
                } catch (error) {
                    addLog(`Task validation error: ${error.message}`, 'error');
                    return false;
                }
            };

            // No longer executing checkpoints individually
            const executeCheckpoint = async (checkpoint) => {
                // DEPRECATED - we now send all checkpoints to one thread
                addLog(`Executing: ${checkpoint.name}`, 'info');
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { status: 'in_progress', logs: [] }
                    }
                }));
                
                try {
                    // Execute via Terragon
                    const execResponse = await fetch(EXECUTE_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: state.sessionId
                        })
                    });
                    
                    const execData = await execResponse.json();
                    if (!execResponse.ok) throw new Error(execData.error);
                    
                    const threadUrl = `https://www.terragonlabs.com/task/${execData.threadId}`;
                    addLog(`${checkpoint.name}: Created in thread ${execData.threadId}`, 'success');
                    
                    // Update status to show execution was sent to Terragon
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'sent',
                                threadId: execData.threadId,
                                logs: [{ 
                                    message: `Executing in Terragon thread: ${execData.threadId}`,
                                    url: threadUrl
                                }]
                            }
                        },
                        activeThreads: {
                            ...prev.activeThreads,
                            [checkpoint.id]: execData.threadId
                        }
                    }));
                    
                } catch (error) {
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }]
                            }
                        }
                    }));
                    addLog(`${checkpoint.name} failed: ${error.message}`, 'error');
                }
            };

            // Checkpoint status badge
            const StatusBadge = ({ status }) => {
                const colors = {
                    pending: 'bg-gray-600',
                    in_progress: 'bg-blue-600',
                    sent: 'bg-purple-600',
                    pass: 'bg-green-600',
                    fail: 'bg-red-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status}
                    </span>
                );
            };

            // Chat functions
            const sendChatMessage = async () => {
                if (!state.chatInput.trim() || !state.chatThreadId) return;
                
                const message = state.chatInput;
                setState(prev => ({
                    ...prev,
                    chatMessages: [...prev.chatMessages, { 
                        type: 'user', 
                        text: message, 
                        timestamp: new Date().toLocaleTimeString() 
                    }],
                    chatInput: ''
                }));
                
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            threadId: state.chatThreadId, 
                            message 
                        })
                    });
                    
                    const data = await response.json();
                    if (data.responses) {
                        data.responses.forEach(resp => {
                            setState(prev => ({
                                ...prev,
                                chatMessages: [...prev.chatMessages, { 
                                    type: 'assistant', 
                                    text: resp.text, 
                                    timestamp: resp.timestamp 
                                }]
                            }));
                        });
                    }
                } catch (error) {
                    addLog(`Chat error: ${error.message}`, 'error');
                }
            };

            const startChatSession = async () => {
                const threadId = `chat-${Date.now()}-${Math.random().toString(36).substring(7)}`;
                setState(prev => ({
                    ...prev,
                    chatThreadId: threadId,
                    chatVisible: true,
                    chatMessages: [{
                        type: 'system',
                        text: 'Chat connected to UncleFrank system. You can create tasks by describing what you want.',
                        timestamp: new Date().toLocaleTimeString()
                    }]
                }));
                addLog(`Chat session started: ${threadId}`, 'success');
            };

            const createTaskFromChat = (message) => {
                setState(prev => ({ ...prev, request: message }));
                addLog('Task request populated from chat', 'info');
            };

            // Task Review handlers
            const handleUpdateTaskStatus = (taskId, newStatus) => {
                setState(prev => ({
                    ...prev,
                    reviewTasks: prev.reviewTasks.map(task =>
                        task.id === taskId ? { ...task, status: newStatus } : task
                    )
                }));
                addLog(`Task ${taskId} status updated to ${newStatus}`, 'info');
            };

            const handleViewChanges = (task) => {
                addLog(`Opening diff viewer for ${task.name}`, 'info');
                setSelectedTask(task);
                setDiffViewerOpen(true);
            };

            const handleRunTests = async (task) => {
                addLog(`Running comprehensive tests for ${task.name}`, 'info');
                
                try {
                    // FRANK'S REAL TEST RUNNER - NO TODOS
                    const testResponse = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'validate-task-real',
                            task: task,
                            criteria: task.acceptanceCriteria || task.description,
                            checkpointResults: state.executionStatus
                        })
                    });
                    
                    if (testResponse.ok) {
                        const testData = await testResponse.json();
                        addLog(`Task validation: ${testData.passed ? 'PASSED' : 'FAILED'}`, 
                               testData.passed ? 'success' : 'error');
                        addLog(`Details: ${testData.details}`, 'info');
                        return testData.passed;
                    } else {
                        addLog('Task validation API failed', 'error');
                        return false;
                    }
                } catch (error) {
                    addLog(`Test runner error: ${error.message}`, 'error');
                    return false;
                }
            };

            const handleApprove = async (task) => {
                try {
                    if (task.prUrl) {
                        // PR already exists, just open it
                        addLog(`Opening existing PR for ${task.name}...`, 'info');
                        window.open(task.prUrl, '_blank');
                        return;
                    }
                    
                    addLog(`Creating PR for ${task.name}...`, 'info');
                    
                    // Create PR body with task details
                    const prBody = `## Task: ${task.name}

### Objective
${task.objective}

### Acceptance Criteria
${task.acceptanceCriteria ? task.acceptanceCriteria.map(criteria => `- ${criteria}`).join('\n') : 'No criteria specified'}

### Branch
\`${task.branch}\`

### Terragon Thread
https://www.terragonlabs.com/task/${task.threadId}

---
🤖 This PR was automatically created by Uncle Frank's Task Review System`;

                    // Create the actual PR via GitHub API
                    const pr = await GitHubService.createPullRequest(
                        `Task: ${task.name}`,
                        prBody,
                        task.branch,
                        'master'
                    );
                    
                    if (pr) {
                        addLog(`PR created: ${pr.html_url}`, 'success');
                        
                        // Update task with PR info and status
                        setState(prev => ({
                            ...prev,
                            reviewTasks: prev.reviewTasks.map(t =>
                                t.id === task.id ? { 
                                    ...t, 
                                    status: 'In Review',
                                    prUrl: pr.html_url,
                                    prNumber: pr.number
                                } : t
                            )
                        }));
                        
                        // Open the PR in a new tab
                        window.open(pr.html_url, '_blank');
                    } else {
                        // Fallback: try to open compare view
                        const compareUrl = GitHubService.getCompareUrl('master', task.branch);
                        addLog(`PR creation failed, opening compare view: ${compareUrl}`, 'error');
                        window.open(compareUrl, '_blank');
                        
                        // Update status to In Review anyway
                        handleUpdateTaskStatus(task.id, 'In Review');
                    }
                    
                } catch (error) {
                    addLog(`Failed to create PR: ${error.message}`, 'error');
                    
                    // Fallback: open compare view
                    const compareUrl = GitHubService.getCompareUrl('master', task.branch);
                    addLog(`Opening compare view instead: ${compareUrl}`, 'info');
                    window.open(compareUrl, '_blank');
                }
            };

            const handleRequestChanges = (task) => {
                handleUpdateTaskStatus(task.id, 'Changes Requested');
                addLog(`Changes requested for ${task.name}`, 'info');
            };

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl">
                    <h1 className="text-4xl font-bold mb-2">🔨 Uncle Frank's Bootstrap Core</h1>
                    <p className="text-gray-400 mb-8">No BS Autonomous LLM Development Platform</p>

                    {/* Task Review Queue */}
                    <div className="mb-6">
                        {loadingTasks ? (
                            <div className="bg-gray-800 rounded-lg p-6">
                                <div className="text-center py-8">
                                    <div className="text-blue-400">Loading tasks from GitHub...</div>
                                </div>
                            </div>
                        ) : (
                            <TaskQueue 
                                tasks={state.reviewTasks}
                                onUpdateTaskStatus={handleUpdateTaskStatus}
                                onViewChanges={handleViewChanges}
                                onRunTests={handleRunTests}
                                onApprove={handleApprove}
                                onRequestChanges={handleRequestChanges}
                            />
                        )}
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/* Left Panel - Input */}
                        <div>
                            <div className="bg-gray-800 rounded-lg p-6 mb-6">
                                <h2 className="text-2xl font-semibold mb-4">Create New Task</h2>
                                
                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Request</label>
                                    <textarea 
                                        value={state.request}
                                        onChange={(e) => setState(prev => ({ ...prev, request: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="e.g., Add Discord bot integration"
                                    />
                                </div>

                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Project Context (optional)</label>
                                    <textarea 
                                        value={state.projectContext}
                                        onChange={(e) => setState(prev => ({ ...prev, projectContext: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="Paste your Project.md content here..."
                                    />
                                </div>

                                <div className="flex gap-2">
                                    <button 
                                        onClick={classifyRequest}
                                        disabled={loading}
                                        className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded transition disabled:opacity-50"
                                    >
                                        Classify
                                    </button>
                                    <button 
                                        onClick={decomposeTask}
                                        disabled={loading}
                                        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded transition disabled:opacity-50"
                                    >
                                        Decompose Task
                                    </button>
                                    {state.checkpoints.length > 0 && (
                                        <button 
                                            onClick={executeCheckpointsSequentially}
                                            disabled={executing}
                                            className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition disabled:opacity-50"
                                        >
                                            {executing ? 'Executing...' : 'Execute Sequential'}
                                        </button>
                                    )}
                                </div>
                            </div>

                            {/* Task Summary */}
                            {state.task && (
                                <div className="bg-gray-800 rounded-lg p-6">
                                    <h3 className="text-lg font-semibold mb-2">{state.task.name}</h3>
                                    <p className="text-gray-400 mb-2">{state.task.objective}</p>
                                    <p className="text-sm">{state.task.acceptanceCriteria.length} acceptance criteria</p>
                                    
                                    {/* Task-level Terragon Chat */}
                                    {state.taskThreadId && (
                                        <div className="mt-4 pt-4 border-t border-gray-700">
                                            <div className="flex items-center justify-between mb-2">
                                                <span className="text-sm font-semibold">Terragon Thread</span>
                                                <span className="text-xs text-gray-500">{state.taskThreadId}</span>
                                            </div>
                                            <button 
                                                onClick={() => window.open(`https://www.terragonlabs.com/task/${state.taskThreadId}`, '_blank')}
                                                className="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                                            >
                                                Open in Terragon →
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Right Panel - Checkpoints & Logs */}
                        <div>
                            {/* Checkpoints */}
                            {state.checkpoints.length > 0 && (
                                <div className="bg-gray-800 rounded-lg p-6 mb-6">
                                    <h3 className="text-lg font-semibold mb-4">Checkpoints</h3>
                                    <div className="space-y-3">
                                        {state.checkpoints.map((cp, i) => (
                                            <div key={cp.id} className="p-3 bg-gray-700 rounded">
                                                <div className="flex justify-between items-start mb-2">
                                                    <div>
                                                        <p className="font-semibold">{i + 1}. {cp.name}</p>
                                                        <p className="text-sm text-gray-400">{cp.objective}</p>
                                                    </div>
                                                    <StatusBadge status={state.executionStatus[cp.id]?.status || 'pending'} />
                                                </div>
                                                <div className="text-xs mt-2">
                                                    <span className={`text-${cp.blocking ? 'red' : 'green'}-400`}>
                                                        {cp.blocking ? 'Blocking' : 'Non-blocking'}
                                                    </span>
                                                    <span className="text-gray-500 ml-2">• {cp.passCriteria.length} tests</span>
                                                </div>
                                                {state.executionStatus[cp.id]?.logs?.length > 0 && (
                                                    <div className="mt-2 text-xs">
                                                        {state.executionStatus[cp.id].logs.map((log, idx) => (
                                                            <div key={idx} className="text-gray-300">
                                                                {log.message}
                                                                {log.url && (
                                                                    <a 
                                                                        href={log.url} 
                                                                        target="_blank" 
                                                                        className="text-blue-400 hover:underline ml-2"
                                                                    >
                                                                        Open in Terragon →
                                                                    </a>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Execution Logs */}
                            <div className="bg-gray-800 rounded-lg p-6">
                                <h3 className="text-lg font-semibold mb-4">Execution Logs</h3>
                                <div className="h-64 overflow-y-auto bg-gray-900 rounded p-3 font-mono text-xs">
                                    {state.logs.map((log, i) => (
                                        <div key={i} className={`mb-1 ${
                                            log.level === 'error' ? 'text-red-400' : 
                                            log.level === 'success' ? 'text-green-400' : 
                                            'text-gray-300'
                                        }`}>
                                            <span className="text-gray-500">[{log.timestamp}]</span> {log.message}
                                        </div>
                                    ))}
                                    {state.logs.length === 0 && (
                                        <div className="text-gray-500">No logs yet...</div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Diff Viewer Modal */}
                    <DiffViewer 
                        isOpen={diffViewerOpen}
                        onClose={() => setDiffViewerOpen(false)}
                        task={selectedTask}
                    />
                    
                    {/* Orchestrator Status */}
                    <OrchestratorStatus />
                </div>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>