<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncle Frank's Bootstrap Core</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/diff-match-patch@1.0.5/index.js"></script>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // GitHub API Service
        const GitHubService = {
            baseUrl: 'https://api.github.com',
            owner: 'bhuman-ai',
            repo: 'unclefrank-bootstrap',

            async getBranches() {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/branches`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch branches:', error);
                    return [];
                }
            },

            async getBranchDetails(branchName) {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/branches/${branchName}`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch branch details:', error);
                    return null;
                }
            },

            async getCommitDiff(baseBranch = 'master', headBranch) {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`);
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                    return null;
                }
            },

            async createPullRequest(title, body, headBranch, baseBranch = 'master') {
                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/pulls`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            // Note: In production, you'd need proper authentication
                        },
                        body: JSON.stringify({
                            title,
                            body,
                            head: headBranch,
                            base: baseBranch
                        })
                    });
                    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error('Failed to create PR:', error);
                    return null;
                }
            },

            getCompareUrl(baseBranch = 'master', headBranch) {
                return `https://github.com/${this.owner}/${this.repo}/compare/${baseBranch}...${headBranch}`;
            },

            getBranchUrl(branchName) {
                return `https://github.com/${this.owner}/${this.repo}/tree/${branchName}`;
            }
        };

        // Review Actions Component
        const ReviewActions = ({ task, onViewChanges, onRunTests, onApprove, onRequestChanges }) => {
            const [testStatus, setTestStatus] = useState(null);
            const [loading, setLoading] = useState(false);

            const handleRunTests = async () => {
                setLoading(true);
                setTestStatus('running');
                
                try {
                    // Simulate test run
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    setTestStatus('passed');
                    onRunTests(task);
                } catch (error) {
                    setTestStatus('failed');
                } finally {
                    setLoading(false);
                }
            };

            const getTestStatusColor = () => {
                switch (testStatus) {
                    case 'running': return 'bg-blue-600';
                    case 'passed': return 'bg-green-600';
                    case 'failed': return 'bg-red-600';
                    default: return 'bg-gray-600';
                }
            };

            return (
                <div className="flex gap-1">
                    <button 
                        onClick={() => onViewChanges(task)}
                        className="px-2 py-1 bg-gray-600 hover:bg-gray-700 rounded text-xs transition"
                    >
                        View Changes
                    </button>
                    <button 
                        onClick={handleRunTests}
                        disabled={loading}
                        className={`px-2 py-1 rounded text-xs transition ${getTestStatusColor()} hover:opacity-80 disabled:opacity-50`}
                    >
                        {loading ? 'Running...' : testStatus === 'passed' ? 'âœ“ Tests' : testStatus === 'failed' ? 'âœ— Tests' : 'Run Tests'}
                    </button>
                    <button 
                        onClick={() => onApprove(task)}
                        className="px-2 py-1 bg-green-600 hover:bg-green-700 rounded text-xs transition"
                    >
                        Approve
                    </button>
                    <button 
                        onClick={() => onRequestChanges(task)}
                        className="px-2 py-1 bg-orange-600 hover:bg-orange-700 rounded text-xs transition"
                    >
                        Request Changes
                    </button>
                </div>
            );
        };

        // Diff Viewer Component
        const DiffViewer = ({ isOpen, onClose, task, diffData }) => {
            const [loading, setLoading] = useState(false);
            const [files, setFiles] = useState([]);

            useEffect(() => {
                if (isOpen && task && task.branch) {
                    fetchDiffData();
                }
            }, [isOpen, task]);

            const fetchDiffData = async () => {
                setLoading(true);
                try {
                    const diff = await GitHubService.getCommitDiff('master', task.branch);
                    if (diff && diff.files) {
                        setFiles(diff.files);
                    }
                } catch (error) {
                    console.error('Failed to fetch diff:', error);
                } finally {
                    setLoading(false);
                }
            };

            const renderDiffLines = (patch) => {
                if (!patch) return null;
                
                const lines = patch.split('\n');
                return lines.map((line, index) => {
                    let className = 'font-mono text-sm px-4 py-1 ';
                    if (line.startsWith('+')) {
                        className += 'bg-green-900 text-green-200';
                    } else if (line.startsWith('-')) {
                        className += 'bg-red-900 text-red-200';
                    } else if (line.startsWith('@@')) {
                        className += 'bg-blue-900 text-blue-200 font-semibold';
                    } else {
                        className += 'bg-gray-800 text-gray-300';
                    }
                    
                    return (
                        <div key={index} className={className}>
                            {line || ' '}
                        </div>
                    );
                });
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-gray-800 rounded-lg max-w-6xl max-h-[90vh] w-full mx-4 flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-gray-700">
                            <h2 className="text-xl font-semibold">
                                Changes for: {task?.name}
                            </h2>
                            <button 
                                onClick={onClose}
                                className="text-gray-400 hover:text-white text-2xl"
                            >
                                Ã—
                            </button>
                        </div>
                        
                        <div className="flex-1 overflow-auto p-4">
                            {loading ? (
                                <div className="text-center py-8">
                                    <div className="text-blue-400">Loading diff...</div>
                                </div>
                            ) : files.length > 0 ? (
                                <div className="space-y-6">
                                    {files.map((file, index) => (
                                        <div key={index} className="border border-gray-700 rounded">
                                            <div className="bg-gray-700 px-4 py-2 font-mono text-sm">
                                                <span className="text-gray-300">{file.filename}</span>
                                                <span className="ml-4 text-green-400">+{file.additions}</span>
                                                <span className="ml-2 text-red-400">-{file.deletions}</span>
                                            </div>
                                            <div className="max-h-96 overflow-auto">
                                                {renderDiffLines(file.patch)}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="text-center py-8">
                                    <div className="text-gray-500">No changes found</div>
                                    <a 
                                        href={GitHubService.getCompareUrl('master', task?.branch)}
                                        target="_blank"
                                        className="text-blue-400 hover:underline mt-2 inline-block"
                                    >
                                        View on GitHub â†’
                                    </a>
                                </div>
                            )}
                        </div>
                        
                        <div className="p-4 border-t border-gray-700 flex justify-end gap-2">
                            <button 
                                onClick={onClose}
                                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
                            >
                                Close
                            </button>
                            <a 
                                href={GitHubService.getCompareUrl('master', task?.branch)}
                                target="_blank"
                                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
                            >
                                View on GitHub
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // Task Queue Component
        const TaskQueue = ({ tasks, onUpdateTaskStatus, onViewChanges, onRunTests, onApprove, onRequestChanges }) => {
            const [filter, setFilter] = useState('Awaiting Review');
            
            const filteredTasks = tasks.filter(task => 
                !filter || task.status === filter
            );

            const StatusBadge = ({ status }) => {
                const colors = {
                    'Awaiting Review': 'bg-yellow-600',
                    'In Review': 'bg-blue-600',
                    'Approved': 'bg-green-600',
                    'Changes Requested': 'bg-red-600',
                    'Merged': 'bg-purple-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status}
                    </span>
                );
            };

            return (
                <div className="bg-gray-800 rounded-lg p-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-xl font-semibold">Task Queue</h2>
                        <select 
                            value={filter}
                            onChange={(e) => setFilter(e.target.value)}
                            className="px-3 py-1 bg-gray-700 rounded border border-gray-600 text-sm"
                        >
                            <option value="">All Tasks</option>
                            <option value="Awaiting Review">Awaiting Review</option>
                            <option value="In Review">In Review</option>
                            <option value="Approved">Approved</option>
                            <option value="Changes Requested">Changes Requested</option>
                            <option value="Merged">Merged</option>
                        </select>
                    </div>
                    
                    <div className="overflow-x-auto">
                        <table className="w-full text-sm">
                            <thead>
                                <tr className="border-b border-gray-700">
                                    <th className="text-left py-2 px-3">Task Name</th>
                                    <th className="text-left py-2 px-3">Status</th>
                                    <th className="text-left py-2 px-3">Branch</th>
                                    <th className="text-left py-2 px-3">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {filteredTasks.map(task => (
                                    <tr key={task.id} className="border-b border-gray-700 hover:bg-gray-750">
                                        <td className="py-3 px-3">
                                            <div>
                                                <div className="font-medium">{task.name}</div>
                                                <div className="text-xs text-gray-400">{task.objective}</div>
                                            </div>
                                        </td>
                                        <td className="py-3 px-3">
                                            <StatusBadge status={task.status} />
                                        </td>
                                        <td className="py-3 px-3">
                                            {task.branch ? (
                                                <a 
                                                    href={GitHubService.getBranchUrl(task.branch)}
                                                    target="_blank"
                                                    className="text-blue-400 hover:underline text-xs"
                                                >
                                                    {task.branch}
                                                </a>
                                            ) : (
                                                <span className="text-gray-500 text-xs">No branch</span>
                                            )}
                                        </td>
                                        <td className="py-3 px-3">
                                            <ReviewActions 
                                                task={task}
                                                onViewChanges={onViewChanges}
                                                onRunTests={onRunTests}
                                                onApprove={onApprove}
                                                onRequestChanges={onRequestChanges}
                                            />
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                        {filteredTasks.length === 0 && (
                            <div className="text-center py-8 text-gray-500">
                                No tasks found with status "{filter}"
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // State management
        const initialState = {
            request: 'Implement Task Review UI that shows completed tasks awaiting human review with GitHub integration. This must include: 1) Task Queue view showing tasks with "Awaiting Review" status after Terragon completes them, 2) Display the GitHub branch created by Terragon, 3) Show acceptance criteria as a review checklist, 4) Provide View Changes, Run Tests, Approve, and Request Changes buttons, 5) Integration with GitHub API to detect branches and create PRs, 6) Merge Review Screen showing diffs, 7) Update task status from "sent" through "completed", "awaiting review", to "merged"',
            projectContext: `# Current State
The system can execute tasks in Terragon, which creates GitHub branches, but there's no UI to review and approve these completed tasks. According to Interface.md, we need screens #3 (Task Queue), #7 (Merge Review), #9 (GitHub Integration), and #15 (Escalation Notifications).

# Requirements from Interface.md
- Task Queue must show task status management
- Merge Review Screen must show Draft vs Production diff viewer  
- GitHub Integration Panel must show repo browser and PR statuses
- System must enforce the immutable flow - no bypassing allowed
- Every action must have immediate feedback

# Technical Context
- Tasks are executed in Terragon and push to branches like "terragon/project-md-validation-system"
- System uses GitHub API for integration
- React-based UI in public/index.html
- Task state is managed in React component state`,
            task: null,
            checkpoints: [],
            executionStatus: {},
            sessionId: null,
            logs: [],
            activeThreads: {}, // Track thread IDs for each checkpoint
            taskThreadId: null, // One thread per task
            reviewTasks: [
                {
                    id: 'task-1',
                    name: 'Task Review UI Implementation',
                    objective: 'Build review interface for completed Terragon tasks with GitHub integration',
                    status: 'Awaiting Review',
                    branch: 'terragon/task-review-ui-github-integration',
                    threadId: 'thread-123',
                    acceptanceCriteria: [
                        'Task Queue component renders without errors',
                        'GitHub API integration works correctly',
                        'Review actions update task status',
                        'PR creation flow functions properly'
                    ]
                },
                {
                    id: 'task-2',
                    name: 'Discord Bot Integration',
                    objective: 'Add Discord bot for task notifications',
                    status: 'In Review',
                    branch: 'terragon/discord-bot-integration',
                    threadId: 'thread-456',
                    acceptanceCriteria: [
                        'Bot connects to Discord successfully',
                        'Notifications sent on task completion'
                    ]
                }
            ]
        };

        function App() {
            const [state, setState] = useState(initialState);
            const [loading, setLoading] = useState(false);
            const [executing, setExecuting] = useState(false);
            const [diffViewerOpen, setDiffViewerOpen] = useState(false);
            const [selectedTask, setSelectedTask] = useState(null);
            const executionInterval = useRef(null);

            const API_URL = '/api/task';
            const EXECUTE_URL = '/api/execute';

            // Add log entry
            const addLog = (message, level = 'info') => {
                setState(prev => ({
                    ...prev,
                    logs: [...prev.logs, {
                        timestamp: new Date().toLocaleTimeString(),
                        message,
                        level
                    }]
                }));
            };

            // Classify request
            const classifyRequest = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('Classifying request...', 'info');
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'classify', request: state.request })
                    });
                    
                    const data = await response.json();
                    if (response.ok) {
                        addLog(`Classification: ${data.classification.type} (${(data.classification.confidence * 100).toFixed(0)}%)`, 'success');
                    } else {
                        addLog(data.error || 'Classification failed', 'error');
                    }
                } catch (error) {
                    addLog(error.message, 'error');
                }
                setLoading(false);
            };

            // Decompose task
            const decomposeTask = async () => {
                if (!state.request) {
                    alert('Please enter a request');
                    return;
                }
                setLoading(true);
                addLog('Decomposing task into checkpoints...', 'info');
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'decompose', 
                            request: state.request, 
                            projectContext: state.projectContext 
                        })
                    });
                    
                    const data = await response.json();
                    if (response.ok) {
                        setState(prev => ({
                            ...prev,
                            task: data.task,
                            checkpoints: data.checkpoints,
                            executionStatus: data.checkpoints.reduce((acc, cp) => ({
                                ...acc,
                                [cp.id]: { status: 'pending', logs: [] }
                            }), {})
                        }));
                        addLog(`Task decomposed into ${data.checkpoints.length} checkpoints`, 'success');
                    } else {
                        addLog(data.error || 'Decomposition failed', 'error');
                    }
                } catch (error) {
                    addLog(error.message, 'error');
                }
                setLoading(false);
            };

            // Execute all checkpoints
            const executeAllCheckpoints = async () => {
                if (!state.checkpoints.length || !state.task) {
                    alert('No checkpoints to execute');
                    return;
                }
                
                setExecuting(true);
                addLog('Creating Terragon thread for task...', 'info');
                
                try {
                    // Create a real Terragon task via dashboard endpoint
                    addLog('Creating real Terragon task...', 'info');
                    
                    // Build the complete task message with all checkpoints
                    const taskMessage = `# TASK EXECUTION: ${state.task.name}

## Objective
${state.task.objective}

## Project Context
${state.projectContext || 'No additional context provided'}

## Checkpoints to Execute
${state.checkpoints.map((cp, i) => `
### ${i + 1}. ${cp.name}
**Objective:** ${cp.objective}
**Instructions:**
${cp.instructions.map((inst, j) => `  ${j + 1}. ${inst}`).join('\n')}
**Pass Criteria:**
${cp.passCriteria.map(pc => `  - ${pc.description}`).join('\n')}
`).join('\n')}

Please execute each checkpoint sequentially and report the results for each one.`;

                    // Create a new Terragon task via dashboard
                    const dashboardPayload = [{
                        message: {
                            type: 'user',
                            model: 'sonnet',
                            parts: [{
                                type: 'rich-text',
                                nodes: [{
                                    type: 'text',
                                    text: taskMessage
                                }]
                            }],
                            timestamp: new Date().toISOString()
                        },
                        githubRepoFullName: 'bhuman-ai/unclefrank-bootstrap',
                        repoBaseBranchName: 'master',
                        saveAsDraft: false
                    }];

                    const response = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'create-task',
                            payload: dashboardPayload
                        })
                    });
                    
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.error || `Failed to create Terragon task: ${response.status}`);
                    }
                    
                    const threadId = result.threadId;
                    const threadUrl = `https://www.terragonlabs.com/task/${threadId}`;
                    
                    addLog(`Task created with ID: ${threadId}`, 'success');
                    
                    // Set the thread ID for the entire task
                    setState(prev => ({ 
                        ...prev, 
                        sessionId: threadId,
                        taskThreadId: threadId 
                    }));
                    
                    // Update all checkpoints to show they're in the same thread
                    const newActiveThreads = {};
                    const newExecutionStatus = {};
                    
                    state.checkpoints.forEach(cp => {
                        newActiveThreads[cp.id] = threadId;
                        newExecutionStatus[cp.id] = {
                            status: 'sent',
                            threadId: threadId,
                            logs: [{ 
                                message: `Queued in Terragon thread`,
                                url: threadUrl
                            }]
                        };
                    });
                    
                    setState(prev => ({
                        ...prev,
                        activeThreads: newActiveThreads,
                        executionStatus: newExecutionStatus
                    }));
                    
                    addLog('All checkpoints sent to Terragon!', 'success');
                    addLog(`Monitor progress at: ${threadUrl}`, 'info');
                    
                } catch (error) {
                    addLog(`Execution error: ${error.message}`, 'error');
                }
                
                setExecuting(false);
            };

            // No longer executing checkpoints individually
            const executeCheckpoint = async (checkpoint) => {
                // DEPRECATED - we now send all checkpoints to one thread
                addLog(`Executing: ${checkpoint.name}`, 'info');
                
                // Update status to in_progress
                setState(prev => ({
                    ...prev,
                    executionStatus: {
                        ...prev.executionStatus,
                        [checkpoint.id]: { status: 'in_progress', logs: [] }
                    }
                }));
                
                try {
                    // Execute via Terragon
                    const execResponse = await fetch(EXECUTE_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            action: 'execute',
                            checkpoint,
                            projectContext: state.projectContext,
                            sessionId: state.sessionId
                        })
                    });
                    
                    const execData = await execResponse.json();
                    if (!execResponse.ok) throw new Error(execData.error);
                    
                    const threadUrl = `https://www.terragonlabs.com/task/${execData.threadId}`;
                    addLog(`${checkpoint.name}: Created in thread ${execData.threadId}`, 'success');
                    
                    // Update status to show execution was sent to Terragon
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'sent',
                                threadId: execData.threadId,
                                logs: [{ 
                                    message: `Executing in Terragon thread: ${execData.threadId}`,
                                    url: threadUrl
                                }]
                            }
                        },
                        activeThreads: {
                            ...prev.activeThreads,
                            [checkpoint.id]: execData.threadId
                        }
                    }));
                    
                } catch (error) {
                    setState(prev => ({
                        ...prev,
                        executionStatus: {
                            ...prev.executionStatus,
                            [checkpoint.id]: {
                                status: 'fail',
                                logs: [{ message: error.message }]
                            }
                        }
                    }));
                    addLog(`${checkpoint.name} failed: ${error.message}`, 'error');
                }
            };

            // Checkpoint status badge
            const StatusBadge = ({ status }) => {
                const colors = {
                    pending: 'bg-gray-600',
                    in_progress: 'bg-blue-600',
                    sent: 'bg-purple-600',
                    pass: 'bg-green-600',
                    fail: 'bg-red-600'
                };
                
                return (
                    <span className={`px-2 py-1 text-xs rounded ${colors[status] || 'bg-gray-600'}`}>
                        {status}
                    </span>
                );
            };

            // Chat functions
            const sendChatMessage = async () => {
                if (!state.chatInput.trim() || !state.chatThreadId) return;
                
                const message = state.chatInput;
                setState(prev => ({
                    ...prev,
                    chatMessages: [...prev.chatMessages, { 
                        type: 'user', 
                        text: message, 
                        timestamp: new Date().toLocaleTimeString() 
                    }],
                    chatInput: ''
                }));
                
                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            threadId: state.chatThreadId, 
                            message 
                        })
                    });
                    
                    const data = await response.json();
                    if (data.responses) {
                        data.responses.forEach(resp => {
                            setState(prev => ({
                                ...prev,
                                chatMessages: [...prev.chatMessages, { 
                                    type: 'assistant', 
                                    text: resp.text, 
                                    timestamp: resp.timestamp 
                                }]
                            }));
                        });
                    }
                } catch (error) {
                    addLog(`Chat error: ${error.message}`, 'error');
                }
            };

            const startChatSession = async () => {
                const threadId = `chat-${Date.now()}-${Math.random().toString(36).substring(7)}`;
                setState(prev => ({
                    ...prev,
                    chatThreadId: threadId,
                    chatVisible: true,
                    chatMessages: [{
                        type: 'system',
                        text: 'Chat connected to UncleFrank system. You can create tasks by describing what you want.',
                        timestamp: new Date().toLocaleTimeString()
                    }]
                }));
                addLog(`Chat session started: ${threadId}`, 'success');
            };

            const createTaskFromChat = (message) => {
                setState(prev => ({ ...prev, request: message }));
                addLog('Task request populated from chat', 'info');
            };

            // Task Review handlers
            const handleUpdateTaskStatus = (taskId, newStatus) => {
                setState(prev => ({
                    ...prev,
                    reviewTasks: prev.reviewTasks.map(task =>
                        task.id === taskId ? { ...task, status: newStatus } : task
                    )
                }));
                addLog(`Task ${taskId} status updated to ${newStatus}`, 'info');
            };

            const handleViewChanges = (task) => {
                addLog(`Opening diff viewer for ${task.name}`, 'info');
                setSelectedTask(task);
                setDiffViewerOpen(true);
            };

            const handleRunTests = (task) => {
                addLog(`Running tests for ${task.name}`, 'info');
                // TODO: Implement actual test runner integration
            };

            const handleApprove = async (task) => {
                try {
                    addLog(`Creating PR for ${task.name}...`, 'info');
                    
                    // Create PR body with task details
                    const prBody = `## Task: ${task.name}

### Objective
${task.objective}

### Acceptance Criteria
${task.acceptanceCriteria ? task.acceptanceCriteria.map(criteria => `- ${criteria}`).join('\n') : 'No criteria specified'}

### Branch
\`${task.branch}\`

### Terragon Thread
https://www.terragonlabs.com/task/${task.threadId}

---
ðŸ¤– This PR was automatically created by Uncle Frank's Task Review System`;

                    // Note: In a real implementation, this would need proper GitHub authentication
                    // For now, we'll simulate the PR creation and update status
                    
                    handleUpdateTaskStatus(task.id, 'In Review');
                    addLog(`PR created for ${task.name}`, 'success');
                    addLog(`View PR: https://github.com/bhuman-ai/unclefrank-bootstrap/pull/[PR_NUMBER]`, 'info');
                    
                    // In a real implementation, uncomment this:
                    // const pr = await GitHubService.createPullRequest(
                    //     `Task: ${task.name}`,
                    //     prBody,
                    //     task.branch,
                    //     'master'
                    // );
                    // if (pr) {
                    //     addLog(`PR created: ${pr.html_url}`, 'success');
                    //     handleUpdateTaskStatus(task.id, 'In Review');
                    // }
                    
                } catch (error) {
                    addLog(`Failed to create PR: ${error.message}`, 'error');
                }
            };

            const handleRequestChanges = (task) => {
                handleUpdateTaskStatus(task.id, 'Changes Requested');
                addLog(`Changes requested for ${task.name}`, 'info');
            };

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl">
                    <h1 className="text-4xl font-bold mb-2">ðŸ”¨ Uncle Frank's Bootstrap Core</h1>
                    <p className="text-gray-400 mb-8">No BS Autonomous LLM Development Platform</p>

                    {/* Task Review Queue */}
                    <div className="mb-6">
                        <TaskQueue 
                            tasks={state.reviewTasks}
                            onUpdateTaskStatus={handleUpdateTaskStatus}
                            onViewChanges={handleViewChanges}
                            onRunTests={handleRunTests}
                            onApprove={handleApprove}
                            onRequestChanges={handleRequestChanges}
                        />
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/* Left Panel - Input */}
                        <div>
                            <div className="bg-gray-800 rounded-lg p-6 mb-6">
                                <h2 className="text-2xl font-semibold mb-4">Create New Task</h2>
                                
                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Request</label>
                                    <textarea 
                                        value={state.request}
                                        onChange={(e) => setState(prev => ({ ...prev, request: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="e.g., Add Discord bot integration"
                                    />
                                </div>

                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">Project Context (optional)</label>
                                    <textarea 
                                        value={state.projectContext}
                                        onChange={(e) => setState(prev => ({ ...prev, projectContext: e.target.value }))}
                                        className="w-full px-3 py-2 bg-gray-700 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                        rows="3"
                                        placeholder="Paste your Project.md content here..."
                                    />
                                </div>

                                <div className="flex gap-2">
                                    <button 
                                        onClick={classifyRequest}
                                        disabled={loading}
                                        className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded transition disabled:opacity-50"
                                    >
                                        Classify
                                    </button>
                                    <button 
                                        onClick={decomposeTask}
                                        disabled={loading}
                                        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded transition disabled:opacity-50"
                                    >
                                        Decompose Task
                                    </button>
                                    {state.checkpoints.length > 0 && (
                                        <button 
                                            onClick={executeAllCheckpoints}
                                            disabled={executing}
                                            className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition disabled:opacity-50"
                                        >
                                            {executing ? 'Executing...' : 'Execute All'}
                                        </button>
                                    )}
                                </div>
                            </div>

                            {/* Task Summary */}
                            {state.task && (
                                <div className="bg-gray-800 rounded-lg p-6">
                                    <h3 className="text-lg font-semibold mb-2">{state.task.name}</h3>
                                    <p className="text-gray-400 mb-2">{state.task.objective}</p>
                                    <p className="text-sm">{state.task.acceptanceCriteria.length} acceptance criteria</p>
                                    
                                    {/* Task-level Terragon Chat */}
                                    {state.taskThreadId && (
                                        <div className="mt-4 pt-4 border-t border-gray-700">
                                            <div className="flex items-center justify-between mb-2">
                                                <span className="text-sm font-semibold">Terragon Thread</span>
                                                <span className="text-xs text-gray-500">{state.taskThreadId}</span>
                                            </div>
                                            <button 
                                                onClick={() => window.open(`https://www.terragonlabs.com/task/${state.taskThreadId}`, '_blank')}
                                                className="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm transition"
                                            >
                                                Open in Terragon â†’
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Right Panel - Checkpoints & Logs */}
                        <div>
                            {/* Checkpoints */}
                            {state.checkpoints.length > 0 && (
                                <div className="bg-gray-800 rounded-lg p-6 mb-6">
                                    <h3 className="text-lg font-semibold mb-4">Checkpoints</h3>
                                    <div className="space-y-3">
                                        {state.checkpoints.map((cp, i) => (
                                            <div key={cp.id} className="p-3 bg-gray-700 rounded">
                                                <div className="flex justify-between items-start mb-2">
                                                    <div>
                                                        <p className="font-semibold">{i + 1}. {cp.name}</p>
                                                        <p className="text-sm text-gray-400">{cp.objective}</p>
                                                    </div>
                                                    <StatusBadge status={state.executionStatus[cp.id]?.status || 'pending'} />
                                                </div>
                                                <div className="text-xs mt-2">
                                                    <span className={`text-${cp.blocking ? 'red' : 'green'}-400`}>
                                                        {cp.blocking ? 'Blocking' : 'Non-blocking'}
                                                    </span>
                                                    <span className="text-gray-500 ml-2">â€¢ {cp.passCriteria.length} tests</span>
                                                </div>
                                                {state.executionStatus[cp.id]?.logs?.length > 0 && (
                                                    <div className="mt-2 text-xs">
                                                        {state.executionStatus[cp.id].logs.map((log, idx) => (
                                                            <div key={idx} className="text-gray-300">
                                                                {log.message}
                                                                {log.url && (
                                                                    <a 
                                                                        href={log.url} 
                                                                        target="_blank" 
                                                                        className="text-blue-400 hover:underline ml-2"
                                                                    >
                                                                        Open in Terragon â†’
                                                                    </a>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Execution Logs */}
                            <div className="bg-gray-800 rounded-lg p-6">
                                <h3 className="text-lg font-semibold mb-4">Execution Logs</h3>
                                <div className="h-64 overflow-y-auto bg-gray-900 rounded p-3 font-mono text-xs">
                                    {state.logs.map((log, i) => (
                                        <div key={i} className={`mb-1 ${
                                            log.level === 'error' ? 'text-red-400' : 
                                            log.level === 'success' ? 'text-green-400' : 
                                            'text-gray-300'
                                        }`}>
                                            <span className="text-gray-500">[{log.timestamp}]</span> {log.message}
                                        </div>
                                    ))}
                                    {state.logs.length === 0 && (
                                        <div className="text-gray-500">No logs yet...</div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Diff Viewer Modal */}
                    <DiffViewer 
                        isOpen={diffViewerOpen}
                        onClose={() => setDiffViewerOpen(false)}
                        task={selectedTask}
                    />
                </div>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>